<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2024-12-17T08:52:20.000Z" itemprop="datePublished">2024-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="字典树结构"><a href="#字典树结构" class="headerlink" title="字典树结构"></a>字典树结构</h2><pre><code class="cpp">
#include &lt;cstdio&gt; // 引入C标准输入输出库
using namespace std; // 使用标准命名空间

constexpr int N = 500010; // 定义常量N，表示数组的最大大小

char s[N]; // 定义字符数组s，用于存储输入的字符串
int n, m; // 定义整数n和m，分别用于存储字符串数量和查询次数
int ch[N][26]; // 定义二维数组ch，用于表示Trie树的子节点，ch[u][c]表示节点u的字符c的子节点
int tag[N]; // 定义数组tag，用于标记字符串的状态（未访问、已访问、重复访问等）
int tot = 1; // 定义并初始化变量tot为1，表示当前Trie树中节点的总数，根节点编号为1

int main() &#123;
  scanf(&quot;%d&quot;, &amp;n); // 从输入中读取整数n，表示要插入的字符串数量

  for (int i = 1; i &lt;= n; ++i) &#123; // 循环n次，处理每一个要插入的字符串
    scanf(&quot;%s&quot;, s + 1); // 从输入中读取一个字符串，存储在数组s的索引1开始的位置
    int u = 1; // 初始化当前节点u为根节点（编号为1）
    
    for (int j = 1; s[j]; ++j) &#123; // 遍历字符串s中的每一个字符，直到遇到字符串结束符
      int c = s[j] - &#39;a&#39;; // 将字符转换为对应的索引（&#39;a&#39;-&gt;0, &#39;b&#39;-&gt;1, ..., &#39;z&#39;-&gt;25）
      
      // 如果当前节点u的子节点中没有字符c对应的节点，则创建一个新的节点
      if (!ch[u][c]) ch[u][c] = ++tot; // 将ch[u][c]设置为新的节点编号，并递增tot
      u = ch[u][c]; // 移动到子节点u的字符c对应的节点，继续向下搜索
    &#125;
    
    tag[u] = 1; // 标记节点u为一个完整字符串的结尾，表示该字符串已经被插入
  &#125;

  scanf(&quot;%d&quot;, &amp;m); // 从输入中读取整数m，表示查询的次数

  while (m--) &#123; // 循环m次，处理每一个查询
    scanf(&quot;%s&quot;, s + 1); // 从输入中读取一个查询字符串，存储在数组s的索引1开始的位置
    int u = 1; // 初始化当前节点u为根节点（编号为1）
    
    for (int j = 1; s[j]; ++j) &#123; // 遍历查询字符串s中的每一个字符，直到遇到字符串结束符
      int c = s[j] - &#39;a&#39;; // 将字符转换为对应的索引（&#39;a&#39;-&gt;0, &#39;b&#39;-&gt;1, ..., &#39;z&#39;-&gt;25）
      u = ch[u][c]; // 移动到子节点u的字符c对应的节点
      
      if (!u) break; // 如果节点u不存在，说明该字符串不在Trie中，提前退出循环
    &#125;
    
    if (tag[u] == 1) &#123; // 如果节点u被标记为1，表示该字符串存在且尚未被访问
      tag[u] = 2; // 将节点u的标记更新为2，表示该字符串已经被访问
      puts(&quot;OK&quot;); // 输出&quot;OK&quot;表示第一次成功访问该字符串
    &#125; 
    else if (tag[u] == 2) &#123; // 如果节点u被标记为2，表示该字符串已经被访问过
      puts(&quot;REPEAT&quot;); // 输出&quot;REPEAT&quot;表示重复访问该字符串
    &#125;
    else &#123; // 如果节点u未被标记，或者u为0，表示该字符串不存在于Trie中
      puts(&quot;WRONG&quot;); // 输出&quot;WRONG&quot;表示字符串不存在或查询无效
    &#125;
  &#125;

  return 0; // 返回0，表示程序正常结束
&#125;

//正常结构体
struct trie &#123;
  int nex[100000][26], cnt; //横坐标表示数组几号 纵坐标表示英文字符多少
  bool exist[100000];  // 该结点结尾的字符串是否存在

  void insert(char *s, int l) &#123;  // 插入字符串
    int p = 0;
    for (int i = 0; i &lt; l; i++) &#123;
      int c = s[i] - &#39;a&#39;;
      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点
      p = nex[p][c];
    &#125;
    exist[p] = true;
  &#125;

  bool find(char *s, int l) &#123;  // 查找字符串
    int p = 0;
    for (int i = 0; i &lt; l; i++) &#123;
      int c = s[i] - &#39;a&#39;;
      if (!nex[p][c]) return 0;
      p = nex[p][c];
    &#125;
    return exist[p];
  &#125;
&#125;;

//用链表形式实现更好一点 容易理解：
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// 定义字典树节点结构
class TrieNode &#123;
public:
    TrieNode* children[26];  // 存储26个字母的子节点指针
    bool isEndOfWord;         // 是否是单词的结束节点

    // 构造函数，初始化节点
    TrieNode() &#123;
        for (int i = 0; i &lt; 26; ++i) &#123;
            children[i] = nullptr;  // 初始化为 nullptr，表示没有子节点
        &#125;
        isEndOfWord = false;  // 默认不是单词结束节点
    &#125;
&#125;;

// 字典树类
class Trie &#123;
public:
    TrieNode* root;  // 根节点

    // 构造函数，初始化字典树
    Trie() &#123;
        root = new TrieNode();  // 初始化根节点
    &#125;

    // 插入一个单词到字典树
    void insert(const string&amp; word) &#123;
        TrieNode* node = root;  // 从根节点开始
        for (char c : word) &#123;
            int index = c - &#39;a&#39;;  // 将字符转换为索引，&#39;a&#39; -&gt; 0, ..., &#39;z&#39; -&gt; 25
            if (node-&gt;children[index] == nullptr) &#123;
                node-&gt;children[index] = new TrieNode();  // 如果没有该字符的子节点，创建新的节点
            &#125;
            node = node-&gt;children[index];  // 向下移动到对应子节点
        &#125;
        node-&gt;isEndOfWord = true;  // 在最后一个字符的节点标记为单词结束
    &#125;

    // 查找一个单词是否在字典树中
    bool search(const string&amp; word) &#123;
        TrieNode* node = root;  // 从根节点开始
        for (char c : word) &#123;
            int index = c - &#39;a&#39;;  // 将字符转换为索引
            if (node-&gt;children[index] == nullptr) &#123;
                return false;  // 如果某个字符没有对应的子节点，返回 false
            &#125;
            node = node-&gt;children[index];  // 向下移动到对应子节点
        &#125;
        return node-&gt;isEndOfWord;  // 如果找到并且是单词结束节点，则返回 true
    &#125;

    // 查找是否有以某个前缀开始的单词
    bool startsWith(const string&amp; prefix) &#123;
        TrieNode* node = root;  // 从根节点开始
        for (char c : prefix) &#123;
            int index = c - &#39;a&#39;;  // 将字符转换为索引
            if (node-&gt;children[index] == nullptr) &#123;
                return false;  // 如果某个字符没有对应的子节点，返回 false
            &#125;
            node = node-&gt;children[index];  // 向下移动到对应子节点
        &#125;
        return true;  // 如果前缀存在，返回 true
    &#125;
&#125;;

// 主函数用于测试
int main() &#123;
    Trie trie;

    // 插入单词
    trie.insert(&quot;apple&quot;);
    trie.insert(&quot;app&quot;);
    trie.insert(&quot;banana&quot;);

    // 查找单词
    cout &lt;&lt; &quot;Search &#39;apple&#39;: &quot; &lt;&lt; trie.search(&quot;apple&quot;) &lt;&lt; endl;  // 应该输出 1 (true)
    cout &lt;&lt; &quot;Search &#39;app&#39;: &quot; &lt;&lt; trie.search(&quot;app&quot;) &lt;&lt; endl;      // 应该输出 1 (true)
    cout &lt;&lt; &quot;Search &#39;banana&#39;: &quot; &lt;&lt; trie.search(&quot;banana&quot;) &lt;&lt; endl;  // 应该输出 1 (true)
    cout &lt;&lt; &quot;Search &#39;bat&#39;: &quot; &lt;&lt; trie.search(&quot;bat&quot;) &lt;&lt; endl;      // 应该输出 0 (false)

    // 查找前缀
    cout &lt;&lt; &quot;Starts with &#39;ban&#39;: &quot; &lt;&lt; trie.startsWith(&quot;ban&quot;) &lt;&lt; endl;  // 应该输出 1 (true)
    cout &lt;&lt; &quot;Starts with &#39;bat&#39;: &quot; &lt;&lt; trie.startsWith(&quot;bat&quot;) &lt;&lt; endl;  // 应该输出 0 (false)

    return 0;
&#125;






//博客理解KMP强大 next数组 这里f数组的含义是：该最长相同前缀后缀中的前缀的结束字符的数组位置（从０开始编号
for (int i=1;i&lt;m;i++)
&#123;
    int j=F[i-1];
    while ((B[j+1]!=B[i])&amp;&amp;(j&gt;=0))
        j=F[j];
    if (B[j+1]==B[i])
        F[i]=j+1;
    else
        F[i]=-1;
&#125;
//利用next数组取匹配：
while (i&lt;n)
&#123;
    if (A[i]==B[j])
    &#123;
        i++;
        j++;
        if (j==m)
        &#123;
            printf(&quot;%d\n&quot;,i-m+1);//注意,这里输出的位置是从1开始标号的,如果你要输出从0开始标号的位置,应该是是i-m.这份代码是我做一道题时写的,那道题要求输出的字符串位置从1开始标号.感谢@Draymonder指出了这个疏漏,更多内容请看评论区
            j=F[j-1]+1;
        &#125;
    &#125;
    else
    &#123;
        if (j==0)
            i++;
        else
            j=F[j-1]+1;//j前一个数可以匹配找到之后 去看B[匹配加1]能不能匹配
    &#125;
&#125;
//AC自动机

#include &lt;bits/stdc++.h&gt;

using namespace std;

#define DEBUG (1)

#define Len(x)              sizeof(x)/sizeof(x[0]) 

/**********************************************
    aho corasick
**********************************************/
#define ALPHABET   (26)

int cnt = 0;                // debug

typedef struct _NODE
&#123;
    int name;               // debug
    vector&lt;int&gt; exist;
    _NODE *fail;
    _NODE *child[ALPHABET];
    _NODE()
    &#123;
        name = 0;           // debug
        fail = NULL;
        memset(child, NULL, ALPHABET*sizeof(_NODE *));
    &#125;
&#125;NODE;

/**********************************************
    &quot;he&quot; &quot;she&quot; &quot;hers&quot; &quot;his&quot; 
    ahishers
     his
       she
        he
        hers
**********************************************/
void print_matching_result(const char *T, int start, int len)
&#123;
    for(int i = 0; i &lt; start; i++)
        printf(&quot; &quot;);
    for(int i = 0; i &lt; len; i++)
        printf(&quot;%c&quot;,T[start+i]);
    printf(&quot;\n&quot;);
&#125;

/**********************************************
    用于debug确认构造完成的状态机的[fail指针]和[exist信息]
    bfs遍历一遍trie,按顺序给节点命名,同时输出fail指向信息
**********************************************/
void print_automaton_info(NODE *tmp)
&#123;
    printf(&quot;---------------------info----------------------\n&quot;);
    queue&lt;NODE *&gt; q;
    q.push(tmp);
    while(!q.empty())
    &#123;
        NODE *tmp = q.front(); q.pop();
        tmp-&gt;name = cnt++;
        if(tmp-&gt;fail)
            printf(&quot;%d --fail--&gt; %d, has %d word\n&quot;, tmp-&gt;name, tmp-&gt;fail-&gt;name, tmp-&gt;exist.size());
        for(int i = 0; i &lt; ALPHABET; i++)
            if(tmp-&gt;child[i])
                q.push(tmp-&gt;child[i]);
    &#125;
    printf(&quot;---------------------end----------------------\n&quot;);
&#125;

void trie_insert(NODE *root, const char *word)
&#123;
    NODE *tmp = root;

    for(int i = 0; i &lt; strlen(word); i++)
    &#123;
        int c = word[i]-&#39;a&#39;;
        if(NULL == tmp-&gt;child[c])
            tmp-&gt;child[c] = new NODE();
        tmp = tmp-&gt;child[c];
    &#125;
    tmp-&gt;exist.push_back(strlen(word));
&#125;

void ac_build(NODE *root, const char *P[], int n)
&#123;
    for(int i = 0; i &lt; n; i++)
        trie_insert(root, P[i]);
    
    queue&lt;NODE *&gt; q;
    for(int i = 0; i &lt; ALPHABET; i++)
    &#123;
        if(root-&gt;child[i])
        &#123;
            root-&gt;child[i]-&gt;fail = root;
            q.push(root-&gt;child[i]);
        &#125;
    &#125;

    while(!q.empty())
    &#123;
        NODE *x = q.front(); q.pop();
        for(int i = 0; i &lt; ALPHABET; i++)
        &#123;
            if(x-&gt;child[i])
            &#123;
                NODE *y = x-&gt;child[i], *fafail = x-&gt;fail;
                /*
                    x--fail-→fafail         x--fail-→fafail
                      ↘ⁱ             ==&gt;     ↘ⁱ        ↘ⁱ      
                        y                      y--fail--→★
                */
                while(fafail &amp;&amp; NULL == fafail-&gt;child[i])
                    fafail = fafail-&gt;fail;
                if(NULL == fafail)
                    y-&gt;fail = root;
                else
                    y-&gt;fail = fafail-&gt;child[i];

                if(y-&gt;fail-&gt;exist.size())
                    for(int j = 0; j &lt; y-&gt;fail-&gt;exist.size(); j++)
                        y-&gt;exist.push_back(y-&gt;fail-&gt;exist[j]);
                q.push(y);
            &#125;
        &#125;
    &#125;
&#125;

void ac_query(NODE *root, const char *T)
&#123;
    NODE *tmp = root;
    for(int i = 0; i &lt; strlen(T); i++)
    &#123;
        int c = T[i]-&#39;a&#39;;
        while(NULL == tmp-&gt;child[c] &amp;&amp; tmp-&gt;fail)
            tmp = tmp-&gt;fail;
        if(tmp-&gt;child[c])
            tmp = tmp-&gt;child[c];
        else
            continue;
        if(tmp-&gt;exist.size())
        &#123;
            for(int j = 0; j &lt; tmp-&gt;exist.size(); j++)
            &#123;
                int len = tmp-&gt;exist[j];
                print_matching_result(T, i-len+1, len);
            &#125;
        &#125;
    &#125;
&#125;

void aho_corasick(const char *P[], int n, const char *T)
&#123;
    printf(&quot;**********************************************\n&quot;);
    for(int i = 0; i &lt; n; i++)
        printf(&quot;\&quot;%s\&quot; &quot;, P[i]);
    printf(&quot;\n%s\n&quot;, T);

    NODE *root = new NODE();
    ac_build(root, P, n);
    ac_query(root, T);

    print_automaton_info(root);         // debug
&#125;

int main()
&#123;
    const char *P[] = &#123;&quot;he&quot;, &quot;she&quot;, &quot;hers&quot;, &quot;his&quot;, &quot;is&quot;&#125;; 
    const char *T = &quot;ahishersheishiser&quot;;

    aho_corasick(P, Len(P), T);

    return 0;
&#125;
//
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cm4tmk3y80000d8vqh51x3gug" data-title="字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-xv6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/13/xv6/" class="article-date">
  <time class="dt-published" datetime="2024-12-13T08:17:31.000Z" itemprop="datePublished">2024-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/13/xv6/">xv6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一些操作系统上的东西"><a href="#一些操作系统上的东西" class="headerlink" title="一些操作系统上的东西"></a>一些操作系统上的东西</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>mknod(“&#x2F;console”, 1, 1);<br>这行是关键。mknod 系统调用用来创建特殊文件。它接受三个参数：</p>
<p>第一个参数 &#x2F;console 是你要创建的设备文件的路径。<br>第二个参数 1 是主设备号（major device number）。<br>第三个参数 1 是次设备号（minor device number）</p>
<pre><code class="cpp">// find.c
#include &quot;kernel/types.h&quot;    // 引入基本数据类型定义
#include &quot;kernel/stat.h&quot;     // 引入文件状态结构体定义
#include &quot;user/user.h&quot;       // 引入用户空间的系统调用和函数声明
#include &quot;kernel/fs.h&quot;       // 引入文件系统相关结构体和常量定义

// 定义一个递归查找函数，接受两个参数：起始路径和目标文件名
void find(char *path, char *target) &#123;
    char buf[512], *p;          // buf用于构建新的路径，p是指向buf中当前操作位置的指针
    int fd;                     // 文件描述符，用于打开文件或目录
    struct dirent de;           // 目录项结构体，用于存储读取的目录项信息
    struct stat st;             // 文件状态结构体，用于存储文件的元数据

    // 尝试以只读方式打开指定路径
    if((fd = open(path, 0)) &lt; 0)&#123;
        fprintf(2, &quot;find: cannot open %s\n&quot;, path);  // 如果打开失败，向标准错误输出错误信息
        return;                                       // 返回，结束当前函数
    &#125;

    // 获取打开文件的状态信息
    if(fstat(fd, &amp;st) &lt; 0)&#123;
        fprintf(2, &quot;find: cannot stat %s\n&quot;, path);  // 如果获取失败，输出错误信息
        close(fd);                                    // 关闭文件描述符，释放资源
        return;                                       // 返回，结束当前函数
    &#125;

    // 根据文件类型进行不同的处理
    switch(st.type)&#123;
    case T_FILE:
        // 如果当前路径是一个文件，检查文件名是否以目标名结尾
        // 通过比较路径字符串的最后部分是否与目标字符串相同
        if(strcmp(path + strlen(path) - strlen(target), target) == 0) &#123;
            printf(&quot;%s\n&quot;, path);  // 如果匹配，打印文件的完整路径
        &#125;
        break;  // 结束当前case
    case T_DIR:
        // 如果当前路径是一个目录，首先检查构建新路径时是否会超出缓冲区大小
        if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123;
            printf(&quot;find: path too long\n&quot;);  // 如果超出，输出错误信息
            break;                             // 结束当前case
        &#125;
        strcpy(buf, path);          // 将当前路径复制到buf中
        p = buf + strlen(buf);     // 设置指针p指向buf的末尾
        *p++ = &#39;/&#39;;                 // 在buf末尾添加一个斜杠，准备拼接子目录或文件名

        // 循环读取目录中的每一个目录项
        while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123;
            if(de.inum == 0)
                continue;  // 如果目录项的inode号为0，表示无效，跳过

            memmove(p, de.name, DIRSIZ);  // 将目录项的名称复制到buf的当前指针位置
            p[DIRSIZ] = 0;                // 在复制的名称后添加字符串终止符

            // 获取新路径的文件状态信息
            if(stat(buf, &amp;st) &lt; 0)&#123;
                printf(&quot;find: cannot stat %s\n&quot;, buf);  // 如果获取失败，输出错误信息
                continue;                                 // 跳过当前目录项，继续下一个
            &#125;

            // 跳过当前目录和父目录，避免无限递归
            if(strcmp(buf + strlen(buf) - 2, &quot;/.&quot;) != 0 &amp;&amp; strcmp(buf + strlen(buf) - 3, &quot;/..&quot;) != 0) &#123;
                find(buf, target);  // 递归调用find函数，继续查找
            &#125;
        &#125;
        break;  // 结束当前case
    &#125;
    close(fd);  // 关闭文件描述符，释放资源
&#125;

// 程序的主入口函数
int main(int argc, char *argv[])
&#123;
    // 检查命令行参数的数量是否少于3个
    if(argc &lt; 3)&#123;
        exit(0);  // 如果参数不足，程序退出
    &#125;

    char target[512];        // 定义一个字符数组用于存储目标文件名
    target[0] = &#39;/&#39;;         // 在目标文件名前添加一个斜杠
    strcpy(target + 1, argv[2]);  // 将命令行的第三个参数（目标文件名）复制到target中，紧跟斜杠之后

    find(argv[1], target);   // 调用find函数，传入起始路径和目标文件名
    exit(0);                 // 程序正常退出
&#125;


</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/13/xv6/" data-id="cm4pqjdw6000004vqgfe1gzrn" data-title="xv6" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图论-总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2024-12-12T15:25:11.000Z" itemprop="datePublished">2024-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最短路径-起始我推荐去看代码原版-这是是我自己回归经验"><a href="#最短路径-起始我推荐去看代码原版-这是是我自己回归经验" class="headerlink" title="最短路径 起始我推荐去看代码原版 这是是我自己回归经验"></a>最短路径 起始我推荐去看代码原版 这是是我自己回归经验</h2><p>这里说的是最短路径 那么就是说不包含所有的点 有起点和终点就可以了</p>
<p>那么就有这些方法：<br>dijkstra朴素版<br>dijkstra堆优化版<br>Bellman_ford<br>Bellman_ford 队列优化算法（又名SPFA）<br>bellman_ford 算法判断负权回路<br>bellman_ford之单源有限最短路<br>Floyd 算法精讲<br>启发式搜索：A * 算法</p>
<p>dijkstra和bellman都是松弛操作 只不过前者是对没有采用的节点进行更新 后者对所有的节点都进行更新 所以一个是局部最优 一个是全局最优</p>
<p>dijkstra 不算动态规划只是贪心操作 每次更新 新的minDist里面的节点都是起始节点到当前节点的距离 （源点开始到选点的更新点）<br>第一个 dijkstra:<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）<br>复杂度O(N^2)</p>
<p>第二个 dijkstra堆优化：<br>换成了按照边进行排序<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）<br>原始的存储方式换成了邻接表的形式 同时因为是使用边来进行排序<br>所有使用了优先队列小顶堆  优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt;<br>复杂度O(ElogE)</p>
<p>第三个Bellman-Ford:和上面不同的点在于为动态规划方式 每次松弛操作都是<br>因为有了新要求：权值可以有负数 需要检测负权回路 加上有走过节点数量的限制<br>步骤是对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路<br>复杂度O(N*E)<br>可以判断负权回路：松弛超过n-1次就可以了 看数值是否还有变化<br>可以在节点数量限制下使用 注意既然要求严格控制边的数量限制 那么每次循环更新的minDist都要用上次的计算结果不要用一个数组进行控制</p>
<p>第四个SPFA 是Bellman-Ford:队列优化版<br>只需要对上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了<br>while(!que.empty()){&#x2F;&#x2F;代替for循环}<br>同时对这之后的做出松弛能得到相同的结果 但是动态规划这个就不能很好体现出现了 但是本质上松弛的节点和原始是一样的<br>复杂度O(N*K)</p>
<p>第五个Floyd 提出的需求是多个起点：也是动态规划<br>但是具体步骤在于：<br>grid[i][j][k] &#x3D; min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])<br>优化成这个：<br>grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);<br>但是还是三层遍历顺序解决问题<br>复杂度O(N^3)</p>
<p>使用单源且为正数权值 还没有负权回路直接使用dijkstra<br>使用单源且可以为负数 直接使用Bellman-Ford<br>多个源 可以使用Floyd</p>
<p>A*不一定得出最后准确结果 但是快</p>
<h2 id="图论总结篇"><a href="#图论总结篇" class="headerlink" title="图论总结篇"></a>图论总结篇</h2><p>首先是两种存储方式 邻接表和邻接矩阵</p>
<p>之后是基本的搜索方法 深搜和广搜</p>
<h2 id="深搜的两种写法"><a href="#深搜的两种写法" class="headerlink" title="深搜的两种写法"></a>深搜的两种写法</h2><p>dfs有两种一种是处理当前节点 一种是处理以下各节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是处理下一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这种处理方法必须要在主函数的时候使用第一个节点先处理了</span></span><br><span class="line"><span class="comment">// 写法一：处理当前访问的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> key, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[key] = <span class="literal">true</span>;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys) &#123;</span><br><span class="line">        <span class="comment">// 深度优先搜索遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, key, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：处理下一个要访问的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> key, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[key] == <span class="literal">false</span>) &#123; <span class="comment">// 确认下一个是没访问过的节点</span></span><br><span class="line">            visited[key] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(graph, key, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿问题系列-也就是染色系列不需要回溯-我得去看看"><a href="#岛屿问题系列-也就是染色系列不需要回溯-我得去看看" class="headerlink" title="岛屿问题系列 也就是染色系列不需要回溯 &#x2F;&#x2F;我得去看看"></a>岛屿问题系列 也就是染色系列不需要回溯 &#x2F;&#x2F;我得去看看</h2><p>路线问题必须回溯去掉头<br>完全可达只看能不能达到 不需要回溯</p>
<h2 id="广搜超时问题"><a href="#广搜超时问题" class="headerlink" title="广搜超时问题"></a>广搜超时问题</h2><p>要加入队列就代表走过，就需要标记，而不是从队列拿出来的时候再去标记走过。<br>是的 如果已经加入队列之后 其他的点也可能去加入这个已经加入队列的点导致重复问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串接龙自做无向图-这个需要注意一下"><a href="#字符串接龙自做无向图-这个需要注意一下" class="headerlink" title="字符串接龙自做无向图 这个需要注意一下"></a>字符串接龙自做无向图 这个需要注意一下</h2><p> unordered_map&lt;string, int&gt; visitMap; &#x2F;&#x2F; &lt;记录的字符串，路径长度&gt;<br>  visitMap.insert(pair&lt;string, int&gt;(beginStr, 1));</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集主要有两个功能：</p>
<p>将两个元素添加到一个集合中。<br>判断两个元素在不在同一个集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个<br>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上<br>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</p>
<h2 id="最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起"><a href="#最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起" class="headerlink" title="最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起"></a>最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起</h2><p>注意是所有边<br>prim 和 kruskal<br>在 稀疏图中，用Kruskal更优。 在稠密图中，用prim算法更优。<br>Prim 算法 时间复杂度为 O(n^2)其中 n 为节点数量<br>Kruskal算法 时间复杂度 为 O(nlogn)，其中n 为边的数量</p>
<h2 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h2><p>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</p>
<h2 id="kruscal"><a href="#kruscal" class="headerlink" title="kruscal"></a>kruscal</h2><p>边的权值排序，因为要优先选最小的边加入到生成树里<br>遍历排序后的边<br>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环<br>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (e--) &#123;</span><br><span class="line">      cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;</span><br><span class="line">      edges.<span class="built_in">push_back</span>(&#123;v1, v2, val&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行Kruskal算法</span></span><br><span class="line">  <span class="comment">// 按边的权值对边进行从小到大排序</span></span><br><span class="line">  <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">          <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line">      <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">          result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">          <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; result_val &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。<br>步骤：<br>找到入度为0 的节点，加入结果集<br>将该节点从图中移除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i] ==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始从队列里遍历入度为0 的节点，将其放入结果集。</span></span><br><span class="line"><span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> cur =que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="comment">//将该节点从图中移除</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取cur指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果cur有指向的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历cur指向的节点</span></span><br><span class="line">            inDegree[files[i]] --; <span class="comment">// cur指向的节点入度都做减一操作</span></span><br><span class="line">            <span class="comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/" data-id="cm4pqjdwh000304vq9q0k3n4g" data-title="图论-总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-杂项语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-12-10T12:24:17.000Z" itemprop="datePublished">2024-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/">杂项语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>优先队列实现小顶堆</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为优先队列本身是大的在顶部被排序排出的 所以小顶堆就得重写CMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myconparison</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hls,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt;rhs.second<span class="comment">//优先队列这么做是为了反过来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparsion&gt;pq;</span><br><span class="line"><span class="comment">//第一个参数是存储什么 第二个参数是用什么存储</span></span><br></pre></td></tr></table></figure>

<p>构造函数参数形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rdge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t,<span class="type">int</span> w):<span class="built_in">to</span>(t),<span class="built_in">val</span>(w)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;;<span class="comment">//;</span></span><br></pre></td></tr></table></figure>

<p>填充</p>
<p>memset(moves, 0, sizeof(moves));<br>moves ：目标内存区域的起始地址（通常是数组或指针）。<br>0填充的<br>sizeof(moves)：指定填充的内存字节数，这里是 moves 数组的总大小。</p>
<p>重载运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span>运算符 (参数列表) &#123;</span><br><span class="line">    <span class="comment">// 运算逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回迭代器最小的值并且解引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getFinalState</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = <span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            *iter *= multiplier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还学会一个快速幂<br>x是原始数值 n是次方也是 要转换的二进制数<br>首先判定n这个此项是否大于0小于0等于0 把他们改成大于0 等于0直接等于1的结果了<br>如果这个时候数值的二进制最小值是1 那么就把结果和当前的x 相乘<br>之后进入和数组二进制最小值不是1的一个分支 x变为x平方 之后把二进制数右移动一位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = N;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; <span class="comment">// x^-n = (1/x)^n</span></span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123; <span class="comment">// 从低到高枚举 n 的每个比特位</span></span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123; <span class="comment">// 这个比特位是 1</span></span><br><span class="line">                ans *= x; <span class="comment">// 把 x 乘到 ans 中</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x; <span class="comment">// x 自身平方</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 继续枚举下一个比特位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">填充</span><br><span class="line">unordered_set&lt;string&gt; strSet;</span><br><span class="line">strSet.<span class="built_in">insert</span>(str);</span><br><span class="line"></span><br><span class="line">结构绑定化声明</span><br><span class="line"><span class="keyword">auto</span> [u, v] 是 C+<span class="number">+17</span> 引入的 结构化绑定声明，它允许你从一个包含多个元素的对象（比如元组、pair 或数组）中提取多个值并将它们分别绑定到变量中。</span><br><span class="line"></span><br><span class="line">例如，考虑如下 pair 类型的元素：</span><br><span class="line"></span><br><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">你可以通过结构化绑定将 pair 的两个元素分别绑定到 u 和 v：</span><br><span class="line"></span><br><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">auto</span> [u, v] = p;  <span class="comment">// 结构化绑定</span></span><br><span class="line">这等价于：</span><br><span class="line"></span><br><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">auto</span> u = p.first;</span><br><span class="line"><span class="keyword">auto</span> v = p.second;</span><br></pre></td></tr></table></figure>
<h3 id="我好像做过质数筛法-找一下"><a href="#我好像做过质数筛法-找一下" class="headerlink" title="我好像做过质数筛法 找一下"></a>我好像做过质数筛法 找一下</h3><p>c++20<br> ranges::sort(cnt, greater());<br>默认升序 这是降序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/" data-id="cm4iipakm0001b0vqc7b5ez7b" data-title="杂项语法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图论-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/" class="article-date">
  <time class="dt-published" datetime="2024-12-07T07:46:36.000Z" itemprop="datePublished">2024-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/">图论-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>输入描述：</p>
<p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p>
<p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p>
<p>输出描述：</p>
<p>输出联通所有岛屿的最小路径总距离</p>
<p>输入示例：</p>
<p>7 11<br>1 2 1<br>1 3 1<br>1 5 2<br>2 6 1<br>2 4 2<br>2 3 2<br>3 4 1<br>4 5 1<br>5 6 2<br>5 7 1<br>6 7 1<br>输出示例：</p>
<p>6</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>官方解法在于三个步骤<br>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</p>
<p>minDist数组 是记录了 所有非生成树节点距离生成树的最小距离。</p>
<p>最后，minDist数组 也就是记录的是最小生成树所有边的权值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> x, y, k;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="comment">// 填一个默认最大值，题目描述val最大为10000</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">10001</span>));</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        <span class="comment">// 因为是双向图，所以两个方向都要填上</span></span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有节点到最小生成树的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(v + <span class="number">1</span>, <span class="number">10001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点是否在树里</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isInTree</span><span class="params">(v + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、prim三部曲，第一步：选距离生成树最近节点</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">-1</span>; <span class="comment">// 选中哪个节点 加入最小生成树</span></span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123; <span class="comment">// 1 - v，顶点编号，这里下标从1开始</span></span><br><span class="line">            <span class="comment">//  选取最小生成树节点的条件：</span></span><br><span class="line">            <span class="comment">//  （1）不在最小生成树里</span></span><br><span class="line">            <span class="comment">//  （2）距离最小生成树最近的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp;  minDist[j] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;<span class="comment">//   默认逻辑就是第一个节点就是加入的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span></span><br><span class="line">        isInTree[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="comment">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下</span></span><br><span class="line">        <span class="comment">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">            <span class="comment">// 更新的条件：</span></span><br><span class="line">            <span class="comment">// （1）节点是 非生成树里的节点</span></span><br><span class="line">            <span class="comment">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span></span><br><span class="line">            <span class="comment">// 其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">                minDist[j] = grid[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= v; i++) &#123; <span class="comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span></span><br><span class="line">        result += minDist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展同时打印出最小生成树的每一条边</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(v + <span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">//用来记录边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既然 minDist数组 记录了 最小生成树的边，是不是就是在更新 minDist数组 的时候，去更新parent数组来记录一下对应的边呢。所以 在 prim三部曲中的第三步，更新 parent数组，代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">        parent[j] = cur; <span class="comment">// 记录最小生成树的边 （注意数组指向的顺序很重要）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果写成 parent[cur] = j，在 for 循环中，有多个 j 满足要求， 那么 parent[cur] 就会被反复覆盖，因为 cur 是一个固定值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举个例子，cur = 1， 在 for循环中，可能 就 j = 2， j = 3，j =4 都符合条件，那么本来应该记录 节点1 与 节点 2、节点3、节点4相连的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 parent[cur] = j 这么写，最后更新的逻辑是 parent[1] = 2, parent[1] = 3， parent[1] = 4， 最后只能记录 节点1 与节点 4 相连，其他相连情况都被覆盖了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这么写 parent[j] = cur， 那就是 parent[2] = 1, parent[3] = 1， parent[4] = 1 ，这样 才能完整表示出 节点1 与 其他节点都是链接的，才没有被覆盖。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 最小生成树边的链接情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; parent[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>输入描述：</p>
<p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p>
<p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p>
<p>输出描述：</p>
<p>输出联通所有岛屿的最小路径总距离</p>
<p>输入示例：</p>
<p>7 11<br>1 2 1<br>1 3 1<br>1 5 2<br>2 6 1<br>2 4 2<br>2 3 2<br>3 4 1<br>4 5 1<br>5 6 2<br>5 7 1<br>6 7 1<br>输出示例：</p>
<p>6</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>题目一摸一样 换了个做法<br>和prim的区别在于<br>prim维护节点 这个维护边</p>
<p>kruscal的思路：</p>
<p>边的权值排序，因为要优先选最小的边加入到生成树里</p>
<p>遍历排序后的边:<br>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环<br>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</p>
<p>是否在一个集合使用并查集来判断问题 同时使用并查集添加节点<br>&#x2F;&#x2F;快排+并查集nlogn （快排） + logn （并查集）  -&gt;最后是nlogn</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l,r为 边两边的节点，val为边的数值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点数量</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10001</span>;</span><br><span class="line"><span class="comment">// 并查集标记节点关系的数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">// 节点编号是从1开始的，n要大一些</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的查找操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的加入集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> v1, v2, val;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    <span class="type">int</span> result_val = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;v1, v2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法</span></span><br><span class="line">    <span class="comment">// 按边的权值对边进行从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头开始遍历边</span></span><br><span class="line">    <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 并查集，搜出两个节点的祖先</span></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(edge.l);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">find</span>(edge.r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">            <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result_val &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这也加一个输出最小生成树的边</span></span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; result; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line"><span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(edge); <span class="comment">// 记录最小生成树的边</span></span><br><span class="line">    result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">    <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (Edge edge : result) &#123;</span><br><span class="line">        cout &lt;&lt; edge.l &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.r &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法比较"><a href="#方法比较" class="headerlink" title="方法比较"></a>方法比较</h2><p>Kruskal 与 prim 的关键区别在于，prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 如果 一个图中，节点多，但边相对较少，那么使用Kruskal 更优。</p>
<p>Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。</p>
<p>Kruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>题目描述：</p>
<p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;&#x3D; A, B &lt;&#x3D; N - 1）。请编写一个算法，用于确定文件处理的顺序。</p>
<p>输入描述：</p>
<p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p>
<p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p>
<p>输出描述：</p>
<p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p>
<p>如果不能成功处理（相互依赖），则输出 -1。</p>
<p>输入示例：</p>
<p>5 4<br>0 1<br>0 2<br>1 3<br>2 4<br>输出示例：</p>
<p>0 1 2 3 4</p>
<p>提示信息：</p>
<p>文件依赖关系如下：<br>0-&gt;1-&gt;3<br>0-&gt;2-&gt;4<br>所以，文件处理的顺序除了示例中的顺序，还存在</p>
<p>0 2 4 1 3</p>
<p>0 2 1 3 4</p>
<p>等等合法的顺序。</p>
<p>数据范围：</p>
<p>0 &lt;&#x3D; N &lt;&#x3D; 10 ^ 5<br>1 &lt;&#x3D; M &lt;&#x3D; 10 ^ 9</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。<br>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p>
<p>重点：所以拓扑排序也是图论中判断有向无环图的常用方法</p>
<p>其实只要能在把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序。</p>
<p>实现拓扑排序的算法有两种：卡恩算法（BFS）和DFS</p>
<p>你看节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p>
<p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。</p>
<p>所以当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点</p>
<p>具体步骤：</p>
<p>找到入度为0 的节点，加入结果集<br>将该节点从图中移除</p>
<p>循环以上两步，直到 所有节点都在图中被移除了。</p>
<p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">inDegree</span>(n,<span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    cin &gt;&gt;s&gt;&gt;t;</span><br><span class="line">    inDegree[t] ++;</span><br><span class="line">    umap[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i] ==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始从队列里遍历入度为0 的节点，将其放入结果集。</span></span><br><span class="line"><span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> cur =que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="comment">//将该节点从图中移除</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取cur指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果cur有指向的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历cur指向的节点</span></span><br><span class="line">            inDegree[files[i]] --; <span class="comment">// cur指向的节点入度都做减一操作</span></span><br><span class="line">            <span class="comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以，我们在代码实现的过程中，本质是要将 该节点作为出发点所连接的节点的 入度 减一 就可以了，这样好能根据入度找下一个节点，不用真在图里把这个节点删掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整体代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 记录每个文件的入度</span></span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; umap;<span class="comment">// 记录文件依赖关系</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 记录结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="comment">// s-&gt;t，先有s才能有t</span></span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        inDegree[t]++; <span class="comment">// t的入度加一</span></span><br><span class="line">        umap[s].<span class="built_in">push_back</span>(t); <span class="comment">// 记录s指向哪些文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 入度为0的文件，可以作为开头，先加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int count = 0;</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span>  cur = que.<span class="built_in">front</span>(); <span class="comment">// 当前选中的文件</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取该文件指向的文件</span></span><br><span class="line">        <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// cur有后续文件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                inDegree[files[i]] --; <span class="comment">// cur的指向的文件入度-1</span></span><br><span class="line">                <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; result[n - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断有无环</span></span><br><span class="line">如果我们发现结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p>
<p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>
<p>【输出描述】</p>
<p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p>
<p>输入示例</p>
<p>7 9<br>1 2 1<br>1 3 4<br>2 3 2<br>2 4 5<br>3 4 2<br>4 5 3<br>2 6 4<br>5 7 4<br>6 7 9<br>输出示例：12</p>
<p>【提示信息】</p>
<p>能够到达的情况：</p>
<p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p>
<h3 id="解法-dijkstra算法-和prim算法-原理相似-贪心原理"><a href="#解法-dijkstra算法-和prim算法-原理相似-贪心原理" class="headerlink" title="解法  dijkstra算法 (和prim算法)原理相似&#x2F; 贪心原理"></a>解法  dijkstra算法 (和prim算法)原理相似&#x2F; 贪心原理</h3><p>和上面不同的在于不是每一个点都要参与进去 同时属于有向图问题</p>
<p>本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。</p>
<p>接下来，我们来详细讲解最短路算法中的 dijkstra 算法。</p>
<p>dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</p>
<p>需要注意两点：</p>
<p>dijkstra 算法可以同时求 起点到所有节点的最短路径<br>权值不能为负数</p>
<p>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
<p>不同的点在于路径规划的时候填充表格的值是从源点开始到目标的距离值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;climits&gt;</span><span class="comment">//前缀作用</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,INT_MAX));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1][p2] =val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n<span class="number">+1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//遍历所有节点</span></span><br><span class="line">    <span class="type">int</span> minVal =INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur =<span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 1、选距离源点最近且未访问过的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; minDist[v] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[v];</span><br><span class="line">                cur = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         visited[cur] = <span class="literal">true</span>;  <span class="comment">// 2、标记该节点已被访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 被利用的节点加上这个节点到新的节点的距离 等于总的距离  被利用的节点之前就是最近节点的选择 就是这一点和prime不同的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应求路径</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">                parent[v] = cur; <span class="comment">// 记录边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意 不能出现负数<br>但是prime可以由负数权值 因为一个是双向一个是单向没有路径依赖 虽然都有visit</p>
<p>prim和dijkstra的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prim</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//因为 minDist表示 节点到最小生成树的最小距离，所以 新节点cur的加入，只需要 使用 grid[cur][j] ，grid[cur][j] 就表示 cur 加入生成树后，生成树到 节点j 的距离。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dijkstra</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">        minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//因为 minDist表示 节点到源点的最小距离，所以 新节点 cur 的加入，需要使用 源点到cur的距离 （minDist[cur]） + cur 到 节点 v 的距离 （grid[cur][v]），才是 源点到节点v的距离。</span></span><br></pre></td></tr></table></figure>
<h2 id="dijkstra（堆优化版）精讲"><a href="#dijkstra（堆优化版）精讲" class="headerlink" title="dijkstra（堆优化版）精讲"></a>dijkstra（堆优化版）精讲</h2><p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p>
<p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>
<p>【输出描述】</p>
<p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p>
<p>输入示例</p>
<p>7 9<br>1 2 1<br>1 3 4<br>2 3 2<br>2 4 5<br>3 4 2<br>4 5 3<br>2 6 4<br>5 7 4<br>6 7 9<br>输出示例：12</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>题目还是那个题目<br>优化方式用在了把数组改成邻接表的情况</p>
<p>三部分<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
<p>三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历 minDist 来寻找最近的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 遍历所有节点，第一层for循环 </span></span><br><span class="line">    <span class="type">int</span> minVal =INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;++v)&#123;<span class="comment">// 1、选距离源点最近且未访问过的节点 ， 第二层for循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!visited[v] &amp;&amp; minDist[v]&lt;minVal)&#123;</span><br><span class="line">            minVal =minDist[v];</span><br><span class="line">            cur =v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur] =<span class="literal">true</span>;<span class="comment">//这个点被标记访问过了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)&#123;<span class="comment">//更新没有访问过的节点到源点的最小距离</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v]&amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur]+grid[cur][v] &lt;minDist[v])&#123;</span><br><span class="line">            minDist[v] =minDist[cur] +grid[cur][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。</p>
<p>而且 直接把 边（带权值）加入到 小顶堆（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。</p>
<p>这样我们就不需要两层for循环来寻找最近的节点了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);<span class="comment">//邻接表图结构</span></span><br><span class="line"></span><br><span class="line">vector&lt;list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//第一个是节点 第二个是权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用类取代pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数 初始列表型构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 链接的节点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用边取代点从而使用堆优化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为优先队列本身是大的在顶部被排序排出的 所以小顶堆就得重写CMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myconparison</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hls,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt;rhs.second<span class="comment">//优先队列这么做是为了反过来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparsion&gt;pq;</span><br><span class="line"><span class="comment">//第一个参数是存储什么 第二个参数是用什么存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部曲中的第一步，我们不用 for循环去遍历，直接取堆顶元素：有了小顶堆自动对边的权值排序，那我们只需要直接从 堆里取堆顶元素（小顶堆中，最小的权值在上面），就可以取到离源点最近的节点了 （未访问过的节点，不会加到堆里进行排序）</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//第二步（该最近节点被标记访问过） 这个就是将 节点做访问标记，和 朴素dijkstra 一样 ，代码如下</span></span><br><span class="line"></span><br><span class="line">visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cur.first 就是cur节点编号， 参考上面pair的定义： pair&lt;节点编号，源点到该节点的权值&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来就是更新 非访问节点到源点的距离，代码实现和 朴素dijkstra 是一样的，代码如下：</span></span><br><span class="line"><span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line"><span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">    <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">    <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">        minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//整体代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个结构体来表示带权重的边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; </span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2, val));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> end = n;    <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储从源点到每个节点的最短距离</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录顶点是否被访问过</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(start, <span class="number">0</span>)); </span><br><span class="line">    </span><br><span class="line">    minDist[start] = <span class="number">0</span>;  <span class="comment">// 起始点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span></span><br><span class="line">        <span class="comment">// &lt;节点， 源点到该节点的距离&gt;</span></span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); </span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[cur.first]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 第二步，该最近节点被标记访问过</span></span><br><span class="line">        visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">            <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">                minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得讨论的复杂度O(ElogE) E 为边的数量</p>
<h2 id="Bellman-ford-算法"><a href="#Bellman-ford-算法" class="headerlink" title="Bellman_ford 算法"></a>Bellman_ford 算法</h2><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。</p>
<p>如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</p>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p>
<p>输入描述</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v（单向图）。</p>
<p>输出描述</p>
<p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p>
<p>输入示例：</p>
<p>6 7<br>5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>引入这个是因为 一个是最短路径 可以有没走过的 一个是有权值同时还有负数</p>
<p>这回题目唯一的区别在于权值有负数了 这下上个算法就有了局限性 所以引入新的算法<br>Bellman_ford算法的核心思想是 对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路。</p>
<p>学会了松弛操作<br>明白了松弛操作之后得到的是什么<br>松弛操作之后得到的就是<br>松弛具体操作：<br>minDist[B] 表示 到达B节点 最小权值，minDist[B] 有哪些状态可以推出来？</p>
<p>状态一： minDist[A] + value 可以推出 minDist[B] 状态二： minDist[B]本身就有权值 （可能是其他边链接的节点B 例如节点C，以至于 minDist[B]记录了其他边到minDist[B]的权值）</p>
<p>minDist[B] 应为如何取舍。</p>
<p>本题我们要求最小权值，那么 这两个状态我们就取最小的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minDist[B] &gt; minDist[A] + value) minDist[B] = minDist[A] + value</span><br></pre></td></tr></table></figure>
<p>松弛一次是一条边 一共n个点 所以松弛n-1次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;grid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt;val;</span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1,p2,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT+MAX)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;&amp;side :grid)&#123;</span><br><span class="line">            <span class="type">int</span> from =side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to =side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> prime =side[<span class="number">2</span>];<span class="comment">//这里的最大值判定也和VISTIS差不多 需要更新的是已经经过计算的节点往后的节点</span></span><br><span class="line">            <span class="keyword">if</span>(minDist[from] != INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] + price)&#123;</span><br><span class="line">                minDist[to] =minDist[from] +price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minDist[end] ==INT_MAX) cout &lt;&lt; <span class="string">&quot;unconnected&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt;minDist[end] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bellman-ford-队列优化算法（又名SPFA）"><a href="#Bellman-ford-队列优化算法（又名SPFA）" class="headerlink" title="Bellman_ford 队列优化算法（又名SPFA）"></a>Bellman_ford 队列优化算法（又名SPFA）</h2><p>题还是拿到题</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p> Bellman_ford 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。</p>
<p>只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了。</p>
<p>因为： if(minDist[from] !&#x3D; INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] + price){<br>                minDist[to] &#x3D;minDist[from] +price;<br>这个是只有计算过的点之后的边才能进行松弛 之前做的循环浪费效率<br>之前用的是数组形式，现在修改为临接表形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">a b c</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rdge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t,<span class="type">int</span> w):<span class="built_in">to</span>(t),<span class="built_in">val</span>(w)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">isInQueen</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">//保存输入边</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt;val;</span><br><span class="line"></span><br><span class="line">        grid[p1].push+<span class="built_in">back</span>(<span class="built_in">Edge</span>(p2,val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">minDist</span>(n<span class="number">+1</span>,INT_MAX);</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;<span class="comment">//代替for循环</span></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        isInQueue[node] =<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge edge:grid[node])&#123;</span><br><span class="line">            <span class="type">int</span> from =node;</span><br><span class="line">            <span class="type">int</span> to = edge.to;</span><br><span class="line">            <span class="type">int</span> value =edge.val;</span><br><span class="line">            <span class="keyword">if</span>(minDist[to] &gt;minDist[from] + value)&#123;<span class="comment">//这里开始不同 只看已经安排好的节点</span></span><br><span class="line">            minDist[to] =minDist[from] +value;</span><br><span class="line">            <span class="keyword">if</span>(isInQueue[to] == <span class="literal">false</span>)&#123;<span class="comment">//把更新的节点加入进来同时确保整个更新的节点不是已经在队列里面了</span></span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">                isInQueue[to] =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(minDist[end] ==INT_MAX)cout &gt;&gt;<span class="string">&quot;unconnected&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt;minDist[end] &lt;&lt;endl;<span class="comment">//到达终点最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我突然发现使用邻接表形式的都是需要用队列去取代大循环呢 因为是存储方式的不同吗？</p>
<p>效率分析O(KN) K是个数 N是边 用来取出放入的</p>
<p>说说这个while的问题 不会出现死循环 首先没有负权回路 就是走了一圈总的值变小的1环<br>那么对于一个有整数的环 会因为所有的边都松之后 不能更新新的节点进入对列而退出循环</p>
<h2 id="bellman-ford之判断负权回路"><a href="#bellman-ford之判断负权回路" class="headerlink" title="bellman_ford之判断负权回路"></a>bellman_ford之判断负权回路</h2><p>【题目描述】</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；</p>
<p>权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：图中可能出现负权回路。</p>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p>
<p>为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p>
<p>【输出描述】</p>
<p>如果没有发现负权回路，则输出一个整数，表示从城市 1 到城市 n 的最低运输成本（包括政府补贴）。</p>
<p>如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 “circle”。如果从城市 1 无法到达城市 n，则输出 “unconnected”。</p>
<p>输入示例</p>
<p>4 4<br>1 2 -1<br>2 3 1<br>3 1 -1<br>3 4 1<br>输出示例</p>
<p>circle</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>详细看了看题目发现就是允许负数的环存在了 可以无限跑下去 这里题目要求当这种情况直接输出一个值就可以了</p>
<p>解决方法就是用松弛法的性质 松弛法在n-1次之后在松弛已经没有变化了 可以通过是否有变化来判断有没有负权回路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;grid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1 &gt;&gt;p2 &gt;&gt;val;</span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1,p2,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag =<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;side :grid)&#123;</span><br><span class="line">            <span class="type">int</span> from =side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> price = side[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(minDist[from] !=INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] +price) minDist[to] =minDist[from] +price;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(minDist[from] !=INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] +price)flag =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag) cout &lt;&lt;<span class="string">&quot;cirile&quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(minDist[end] ==INT_MAX)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;unconnected&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;minDIst[end]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度： O(N * E) , N为节点数量，E为图中边的数量</span></span><br></pre></td></tr></table></figure>
<p>拓展<br>SPFA的情况就是用队列去判断了 队列每个点最后能被进入n-1次 因为它顶多把所有的边都连接上 同时如果又进入了说明又更新了一回 那么就是有负权回路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t,<span class="type">int</span> w):<span class="built_in">to</span>(t),<span class="built_in">val</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2,val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">minDist</span>(n<span class="number">+1</span>,INT_MAX);</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">count</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    count[start]++;<span class="comment">//第一个节点本身已经计入了？是的本身就是按照计入来计算的</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[node]) &#123;</span><br><span class="line">            <span class="type">int</span> from = node;</span><br><span class="line">            <span class="type">int</span> to = edge.to;</span><br><span class="line">            <span class="type">int</span> value = edge.val;</span><br><span class="line">            <span class="keyword">if</span> (minDist[to] &gt; minDist[from] + value) &#123; <span class="comment">// 开始松弛</span></span><br><span class="line">                minDist[to] = minDist[from] + value;</span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">                count[to]++; </span><br><span class="line">                <span class="keyword">if</span> (count[to] == n) &#123;<span class="comment">// 如果加入队列次数超过 n-1次 就说明该图与负权回路</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minDist[end] == INT_MAX) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unconnected&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; minDist[end] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bellman-ford之单源有限最短路"><a href="#bellman-ford之单源有限最短路" class="headerlink" title="bellman_ford之单源有限最短路"></a>bellman_ford之单源有限最短路</h2><p>【题目描述】</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；</p>
<p>权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p>
<p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。</p>
<p>【输出描述】</p>
<p>输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 “unreachable”，表示不存在符合条件的运输方案。</p>
<p>输入示例：</p>
<p>6 7<br>1 2 1<br>2 4 -3<br>2 5 2<br>1 3 5<br>3 5 1<br>4 6 4<br>5 6 -2<br>2 6 1<br>输出示例：</p>
<p>0</p>
<h3 id="解法-因为数量限制不能用贪心解决问题"><a href="#解法-因为数量限制不能用贪心解决问题" class="headerlink" title="解法 因为数量限制不能用贪心解决问题"></a>解法 因为数量限制不能用贪心解决问题</h3><p>看题目已经了解了区别：<br>最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径。<br>单源有限最短路问题的特定在于有了特定的起始点有了起始点中间数量的限制</p>
<p>所以本题就是求：起点最多经过k + 1 条边到达终点的最短距离。</p>
<p>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离，那么对所有边松弛 k + 1次，就是求 起点到达 与起点k + 1条边相连的节点的 最短距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> src, dst,k ,p1, p2, val ,m , n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1, p2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span> , INT_MAX)</span></span>;</span><br><span class="line">    minDist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) &#123; <span class="comment">// 对所有边松弛 k + 1次</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;side : grid) &#123;</span><br><span class="line">            <span class="type">int</span> from = side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> price = side[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (minDist[from] != INT_MAX &amp;&amp; minDist[to] &gt; minDist[from] + price) minDist[to] = minDist[from] + price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="string">&quot;unreachable&quot;</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[dst] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是错误的 k这个限制在这里并没用上 在：<br>for (vector<int> &amp;side : grid) {<br>            int from &#x3D; side[0];<br>            int to &#x3D; side[1];<br>            int price &#x3D; side[2];<br>            if (minDist[from] !&#x3D; INT_MAX &amp;&amp; minDist[to] &gt; minDist[from] + price) minDist[to] &#x3D; minDist[from] + price;<br>        }<br>这个代码中松弛回在已经更新的节点上进行更新 这就不符合松弛定义了 多了一个边<br>所以在每次计算 minDist 时候，要基于 对所有边上一次松弛的 minDist 数值才行，所以我们要记录上一次松弛的minDist。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> src, dst,k ,p1, p2, val ,m , n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1, p2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span> , INT_MAX)</span></span>;</span><br><span class="line">    minDist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist_copy</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// 用来记录上一次遍历的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minDist_copy = minDist; <span class="comment">// 获取上一次计算的结果  用上一次结果进行比较和更新</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;side : grid) &#123;</span><br><span class="line">            <span class="type">int</span> from = side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> price = side[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 注意使用 minDist_copy 来计算 minDist </span></span><br><span class="line">            <span class="keyword">if</span> (minDist_copy[from] != INT_MAX &amp;&amp; minDist[to] &gt; minDist_copy[from] + price) &#123;  </span><br><span class="line">                minDist[to] = minDist_copy[from] + price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="string">&quot;unreachable&quot;</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[dst] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新来看为什么：那么前面讲解过的 94.城市间货物运输I 和 95.城市间货物运输II 也是bellman_ford经典算法，也没使用 minDist_copy，怎么就没问题呢？<br>94.城市间货物运输I， 是没有 负权回路的，那么 多松弛多少次，对结果都没有影响。</p>
<p>求 节点1 到 节点n 的最短路径，松弛n-1 次就够了，松弛 大于 n-1次，结果也不会变。</p>
<p>那么在对所有边进行第一次松弛的时候，如果基于 本次计算的 minDist 来计算 minDist （相当于多做松弛了），也是对最终结果没影响。</p>
<p>95.城市间货物运输II 是判断是否有 负权回路，一旦有负权回路， 对所有边松弛 n-1 次以后，在做松弛 minDist 数值一定会变，根据这一点来判断是否有负权回路。</p>
<p>所以，95.城市间货物运输II 只需要判断minDist数值变化了就行，而 minDist 的数值对不对，并不是我们关心的。</p>
<p>其关键在于本题的两个因素：</p>
<p>本题可以有负权回路，说明只要多做松弛，结果是会变的。<br>本题要求最多经过k个节点，对松弛次数是有限制的。<br>如果本题中 没有负权回路的测试用例， 那版本一的代码就可以过了，</p>
<p>松弛做多了会变<br>松弛还有必须的数量限制</p>
<p>使用SPFA进行：<br>SPFA是针对已经更新的节点进行新的节点计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">to</span>(a),<span class="built_in">val</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1].<span class="built_in">push_bcak</span>(<span class="built_in">Edge</span>(p2,val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start,end;k;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; end &gt;&gt;k;</span><br><span class="line">    k++;<span class="comment">//k+1次边</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist_copy</span><span class="params">(n<span class="number">+1</span>)</span></span>;<span class="comment">//为了防止出现用遍历新的更新新的结果 存储老的更新新的</span></span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="type">int</span> que_size;</span><br><span class="line">    <span class="keyword">while</span>(k-- &amp;&amp;!que.<span class="built_in">empty</span>())<span class="comment">//表示k+1次松弛每次松弛同时保证que有节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        minDist_copy =minDist;</span><br><span class="line">        que_size =que.<span class="built_in">size</span>();<span class="comment">// 记录上次入队列的节点个数</span></span><br><span class="line">        <span class="keyword">while</span>(que_size--)&#123;</span><br><span class="line"><span class="comment">// 上一轮松弛入队列的节点，这次对应的边都要做松弛</span></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(Edge edge :grid[node])<span class="comment">//对更新后的节点为起始点做松弛</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> from =node;</span><br><span class="line">            <span class="type">int</span> to =edge.to;</span><br><span class="line">            <span class="type">int</span> price =edge.val;</span><br><span class="line">            <span class="keyword">if</span>(minDist[to] &gt;minDist_copy[from] + price)&#123;</span><br><span class="line">                minDist[to] =minDist_copy[from] +price;</span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="string">&quot;unreachable&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"> <span class="keyword">while</span> (k-- &amp;&amp; !que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 每一轮松弛中，控制节点不用重复入队列</span></span><br><span class="line">        minDist_copy = minDist; </span><br><span class="line">        que_size = que.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">while</span> (que_size--) &#123; </span><br><span class="line">            <span class="type">int</span> node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : grid[node]) &#123;</span><br><span class="line">                <span class="type">int</span> from = node;</span><br><span class="line">                <span class="type">int</span> to = edge.to;</span><br><span class="line">                <span class="type">int</span> price = edge.val;</span><br><span class="line">                <span class="keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) &#123;</span><br><span class="line">                    minDist[to] = minDist_copy[from] + price;</span><br><span class="line">                    <span class="keyword">if</span>(visited[to]) <span class="keyword">continue</span>; <span class="comment">// 不用重复放入队列，但需要重复松弛，所以放在这里位置</span></span><br><span class="line">                    visited[to] = <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里的含义是允许了到时候新的节点是由最小的节点计算的 但是对于放入一次之后的节点就不用再放入了 无用功 队列还会重复计算</span></span><br></pre></td></tr></table></figure>

<h2 id="Floyd-算法精"><a href="#Floyd-算法精" class="headerlink" title="Floyd 算法精"></a>Floyd 算法精</h2><p>【题目描述】</p>
<p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。</p>
<p>给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p>
<p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p>
<p>【输入描述】</p>
<p>第一行包含两个整数 N, M, 分别表示景点的数量和道路的数量。</p>
<p>接下来的 M 行，每行包含三个整数 u, v, w，表示景点 u 和景点 v 之间有一条长度为 w 的双向道路。</p>
<p>接下里的一行包含一个整数 Q，表示观景计划的数量。</p>
<p>接下来的 Q 行，每行包含两个整数 start, end，表示一个观景计划的起点和终点。</p>
<p>【输出描述】</p>
<p>对于每个观景计划，输出一行表示从起点到终点的最短路径长度。如果两个景点之间不存在路径，则输出 -1。</p>
<p>【输入示例】</p>
<p>7 3 1 2 4 2 5 6 3 6 8 2 1 2 2 3</p>
<p>【输出示例】</p>
<p>4 -1</p>
<p>【提示信息】</p>
<p>从 1 到 2 的路径长度为 4，2 到 3 之间并没有道路。</p>
<p>1 &lt;&#x3D; N, M, Q &lt;&#x3D; 1000.</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>按照这个含义就是<br>73<br>124<br>256<br>368<br>2<br>12<br>23<br>输出<br>4<br>-1</p>
<p>和前面不同在于 求得是多个起点到多个终点的最短路径  双向问题倒是没谈</p>
<p>Floyd 算法对边的权值正负没有要求，都可以处理。</p>
<p>Floyd算法核心思想是动态规划。</p>
<p>节点1 到 节点9 的最短距离 可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成， 也可以有 节点1 到节点7的最短距离 + 节点7 到节点9的最短距离的距离组成。</p>
<p>那么这个dp就是很多选择啊</p>
<p>一dp数组  这个DP数组真的很难想啊<br>grid[i][j][k] &#x3D; m，表示 节点i 到哪个集合来求和<br>通过将大问题分解为小问题来逐步求解<br>通过限制路径的中间节点集合 [1, 2, …, k]，我们可以从小的集合开始递推，逐步扩大集合范围直到 [1, 2, …, n]<br>具体含义就是表示允许走这些节点以到达的最小距离   记住是中间节点</p>
<p>二<br>递推关系<br>在上面的分析中我们已经初步感受到了递推的关系。</p>
<p>我们分两种情况：</p>
<p>节点i 到 节点j 的最短路径经过节点k<br>节点i 到 节点j 的最短路径不经过节点k<br>对于第一种情况，grid[i][j][k] &#x3D; grid[i][k][k - 1] + grid[k][j][k - 1]</p>
<p>节点i 到 节点k 的最短距离 是不经过节点k，中间节点集合为[1…k-1]，所以 表示为grid[i][k][k - 1]</p>
<p>节点k 到 节点j 的最短距离 也是不经过节点k，中间节点集合为[1…k-1]，所以表示为 grid[k][j][k - 1]</p>
<p>第二种情况，grid[i][j][k] &#x3D; grid[i][j][k - 1]</p>
<p>如果节点i 到 节点j的最短距离 不经过节点k，那么 中间节点集合[1…k-1]，表示为 grid[i][j][k - 1]</p>
<p>因为我们是求最短路，对于这两种情况自然是取最小值。</p>
<p>即： grid[i][j][k] &#x3D; min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</p>
<p>三初始化<br>k等于其他的时候也不知道所以只能让k等于0 没有这个节点的时候开始才行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>)));  <span class="comment">// C++定义了一个三位数组，10005是因为边的最大距离是10^4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">    grid[p1][p2][<span class="number">0</span>] = val;</span><br><span class="line">    grid[p2][p1][<span class="number">0</span>] = val; <span class="comment">// 注意这里是双向图</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>本题求的是最小值，所以输入数据没有涉及到的节点的情况都应该初始为一个最大数。</p>
<p>四 遍历顺序<br>grid[i][j][k] &#x3D; min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])<br>ij k 三个变量<br>而 k 依赖于 k - 1， i 和j 的到 并不依赖与 i - 1 或者 j - 1 等等。<br>最外层遍历k 把k-1的所有情况都计算好了再遍历k</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            grid[i][j][k] = <span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>], grid[i][k][k<span class="number">-1</span>] + grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化k是0开始的 无法用上一层的结果进行计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">10005</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1 &gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1][p2][<span class="number">0</span>] =val;</span><br><span class="line">        grid[p1][p2][<span class="number">0</span>] =val;<span class="comment">//双向图所以这么填入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                grid[i][j][k] =<span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>],grid[i][k][k<span class="number">-1</span>]+grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z,start,end;</span><br><span class="line">    cin &gt;&gt;z;</span><br><span class="line">    <span class="keyword">while</span>(z--)&#123;</span><br><span class="line">        cin &gt;&gt;start &gt;&gt;end;</span><br><span class="line">        <span class="keyword">if</span>(grid[start][end][n] ==<span class="number">10005</span>) cout &gt;&gt;<span class="number">-1</span>&gt;&gt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt;grid[start][end][n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化空间</span></span><br><span class="line">k 只依赖k<span class="number">-1</span> 那么我们只需要记录 grid[i][j][<span class="number">1</span>] 和 grid[i][j][<span class="number">0</span>] 就好，之后就是 grid[i][j][<span class="number">1</span>] 和 grid[i][j][<span class="number">0</span>] 交替滚动。</span><br><span class="line">所以三维数组维度不变 但是数量变成了<span class="number">2</span></span><br><span class="line">这里有难度了</span><br><span class="line"><span class="comment">//这是通过三维变换二维理解的二维</span></span><br><span class="line">这个k<span class="number">-1</span>这个对应的层级可以直接拿来就用 条件在下面说了</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是直接去理解的二维</span></span><br><span class="line">直接用k去替换j和i的位置</span><br><span class="line">本身的定义改变了变成了和k无关的东西 表示从i到j 经过k 的最小路径了 这样的话理解起来就是i到j的距离通过遍历</span><br><span class="line">经过期间的节点(特定节点) 之后最后结果就是没有节点了</span><br><span class="line">grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这里就会想到是否会用到本层计算好的数据呢</span><br><span class="line">如果 本层刚计算好的 grid[i][k] 比上一层 （即k<span class="number">-1</span>层）计算的 grid[i][k] 小，说明确实有 i 到 k 的更短路径，那么基于 更小的 grid[i][k] 去计算 gird[i][j] 没有问题。</span><br><span class="line"></span><br><span class="line">如果 本层刚计算好的 grid[i][k] 比上一层 （即k<span class="number">-1</span>层）计算的 grid[i][k] 大， 这不可能，因为这样也不会做更新 grid[i][k]的操作</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>));  <span class="comment">// 因为边的最大距离是10^4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid[p1][p2] = val;</span><br><span class="line">        grid[p2][p1] = val; <span class="comment">// 注意这里是双向图</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始 floyd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="type">int</span> z, start, end;</span><br><span class="line">    cin &gt;&gt; z;</span><br><span class="line">    <span class="keyword">while</span> (z--) &#123;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">        <span class="keyword">if</span> (grid[start][end] == <span class="number">10005</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; grid[start][end] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n^3)<br>再说一遍适用范围：源点多 点还多 因为是数组存储 发现双向图直接反向定义就可以了 不是什么方法的使用限制</p>
<h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>题目描述</p>
<p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p>
<p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p>
<p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）</p>
<p>输入描述</p>
<p>第一行包含一个整数 n，表示测试用例的数量。</p>
<p>接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p>
<p>输出描述</p>
<p>输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p>
<p>输入示例</p>
<p>6<br>5 2 5 4<br>1 1 2 2<br>1 1 8 8<br>1 1 8 7<br>2 1 3 3<br>4 6 4 6<br>输出示例</p>
<p>2<br>4<br>6<br>5<br>1<br>0</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>广搜是个方法 可以看出最多的是什么 在新的数组位置上更新步数就行<br>就是超时了<br>A*为广搜变体</p>
<p>其实只是场景不同而已 我们在搜索最短路的时候， 如果是无权图（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）</p>
<p>如果是有权图（边有不同的权值），优先考虑 dijkstra。</p>
<p>A*使用启发式算法<br>原理上来说呢 就是在下一次队列计算的取出的时候先把存入的哪些数据进行排序 之后先计算权重高的<br>使用欧拉式启发算法：</p>
<p>新的理解还有一个补充 就是我新加入的会在一些旧的前面 所有旧的不一定能排上了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> moves[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b1, b2;</span><br><span class="line"><span class="comment">// F = G + H</span></span><br><span class="line"><span class="comment">// G = 从起点到该节点路径消耗</span></span><br><span class="line"><span class="comment">// H = 该节点到终点的预估消耗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Knight</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> g,h,f;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Kinght &amp;k) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k.f &lt;f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Knight&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Heuristic</span><span class="params">(<span class="type">const</span> Knight&amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (k.x-b1)*(k.x-b1) + (k.y-b2) *(k.y-b2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">astar</span><span class="params">(<span class="type">const</span> Kinght&amp; k)</span></span>&#123;</span><br><span class="line">    Kinght cur,next;</span><br><span class="line">    que.<span class="built_in">push</span>(k);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cur =que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.x ==b1 &amp;&amp;cur.y ==b2)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        next.x =cur.x +dir[i][<span class="number">0</span>];</span><br><span class="line">        next.y =cur.y +dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(next.x &lt;<span class="number">1</span> || next.x &gt;<span class="number">1000</span> ||next.y &lt;<span class="number">1</span>||next.y &gt;<span class="number">1000</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!movex[next.x][next.y])&#123;</span><br><span class="line">            moves[next.x][next.y] =moves[cur.x][cur.y] <span class="number">+1</span>;</span><br><span class="line">            next.g = cur.g + <span class="number">5</span>;<span class="comment">// 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5         ext.h = Heuristic(next);</span></span><br><span class="line">                next.f = next.g + next.h;</span><br><span class="line">                que.<span class="built_in">push</span>(next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a1,a2;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin &gt;&gt;a1 &gt;&gt;a2 &gt;&gt;b1&gt;&gt;b2;<span class="comment">//b1b2没定义</span></span><br><span class="line">        <span class="built_in">memset</span>(moves,<span class="number">0</span>,<span class="built_in">sizeof</span>(moves));</span><br><span class="line">        Knight start;</span><br><span class="line">        start.x =a1;</span><br><span class="line">        start.y =a2;</span><br><span class="line">        start.g =<span class="number">0</span>;</span><br><span class="line">        start.h =<span class="built_in">Heuristic</span>(start);</span><br><span class="line">        start.f = start.g + start.h;</span><br><span class="line">        <span class="built_in">astar</span>(start);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>(); <span class="comment">// 队列清空</span></span><br><span class="line">        cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>缺点在于<br>不一定得到准确的结果 这是最大的问题<br>如果题目中，给出 多个可能的目标，然后在这多个目标中 选择最近的目标，这种 A * 就不擅长了， A 只擅长给出明确的目标 然后找到最短路径。 这是第二个问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/07/%E5%9B%BE%E8%AE%BA-2/" data-id="cm4iipakk0000b0vq3nm2a1xp" data-title="图论-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-每日一题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-12-04T10:05:36.000Z" itemprop="datePublished">2024-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2056"><a href="#2056" class="headerlink" title="2056"></a>2056</h2><p>有一个 8 x 8 的棋盘，它包含 n 个棋子（棋子包括车，后和象三种）。给你一个长度为 n 的字符串数组 pieces ，其中 pieces[i] 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 n 的二维整数数组 positions ，其中 positions[i] &#x3D; [ri, ci] 表示第 i 个棋子现在在棋盘上的位置为 (ri, ci) ，棋盘下标从 1 开始。</p>
<p>棋盘上每个棋子都可以移动 至多一次 。每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p>
<p>车可以 水平或者竖直 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1) 或者 (r, c-1) 移动。<br>后可以 水平竖直或者斜对角 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。<br>象可以 斜对角 从 (r, c) 沿着方向 (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。<br>移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 0 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。</p>
<p>请你返回 有效 移动组合的数目。</p>
<p>注意：</p>
<p>初始时，不会有两个棋子 在 同一个位置 。<br>有可能在一个移动组合中，有棋子不移动。<br>如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Move</span> &#123;</span><br><span class="line">    <span class="type">int</span> x0, y0; <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> dx, dy; <span class="comment">// 移动方向</span></span><br><span class="line">    <span class="type">int</span> step;   <span class="comment">// 移动次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; DIRS = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;; <span class="comment">// 上下左右 + 斜向</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; PIECE_DIRS = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;r&#x27;</span>, &#123;DIRS.<span class="built_in">begin</span>(), DIRS.<span class="built_in">begin</span>() + <span class="number">4</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;b&#x27;</span>, &#123;DIRS.<span class="built_in">begin</span>() + <span class="number">4</span>, DIRS.<span class="built_in">end</span>()&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;q&#x27;</span>, DIRS&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算位于 (x0,y0) 的棋子在 dirs 这些方向上的所有合法移动</span></span><br><span class="line">    <span class="function">vector&lt;Move&gt; <span class="title">generate_moves</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; dirs)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">8</span>;</span><br><span class="line">        vector&lt;Move&gt; moves = &#123;&#123;x0, y0, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 原地不动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [dx, dy] : dirs) &#123;</span><br><span class="line">            <span class="comment">// 往 d 方向走 1,2,3,... 步</span></span><br><span class="line">            <span class="type">int</span> x = x0 + dx, y = y0 + dy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">1</span>; <span class="number">0</span> &lt; x &amp;&amp; x &lt;= SIZE &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt;= SIZE; step++) &#123;</span><br><span class="line">                moves.<span class="built_in">emplace_back</span>(x0, y0, dx, dy, step);</span><br><span class="line">                x += dx;</span><br><span class="line">                y += dy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> moves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个移动是否合法，即不存在同一时刻两个棋子重叠的情况</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_valid</span><span class="params">(Move&amp; m1, Move&amp; m2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x1 = m<span class="number">1.</span>x0, y1 = m<span class="number">1.</span>y0;</span><br><span class="line">        <span class="type">int</span> x2 = m<span class="number">2.</span>x0, y2 = m<span class="number">2.</span>y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>(m<span class="number">1.</span>step, m<span class="number">2.</span>step); i++) &#123;</span><br><span class="line">            <span class="comment">// 每一秒走一步</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m<span class="number">1.</span>step) &#123;</span><br><span class="line">                x1 += m<span class="number">1.</span>dx;</span><br><span class="line">                y1 += m<span class="number">1.</span>dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m<span class="number">2.</span>step) &#123;</span><br><span class="line">                x2 += m<span class="number">2.</span>dx;</span><br><span class="line">                y2 += m<span class="number">2.</span>dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) &#123; <span class="comment">// 重叠</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countCombinations</span><span class="params">(vector&lt;string&gt;&amp; pieces, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pieces.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 预处理所有合法移动</span></span><br><span class="line">        vector&lt;vector&lt;Move&gt;&gt; <span class="built_in">all_moves</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            all_moves[i] = <span class="built_in">generate_moves</span>(positions[i][<span class="number">0</span>], positions[i][<span class="number">1</span>], PIECE_DIRS[pieces[i][<span class="number">0</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;Move&gt; <span class="title">path</span><span class="params">(n)</span></span>; <span class="comment">// 注意 path 的长度是固定的</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 枚举当前棋子的所有合法移动</span></span><br><span class="line">            <span class="keyword">for</span> (Move&amp; move1 : all_moves[i]) &#123;</span><br><span class="line">                <span class="comment">// 判断合法移动 move1 是否有效</span></span><br><span class="line">                <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_valid</span>(move1, path[j])) &#123;</span><br><span class="line">                        ok = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                    path[i] = move1; <span class="comment">// 直接覆盖，无需恢复现场</span></span><br><span class="line">                    <span class="built_in">dfs</span>(dfs, i + <span class="number">1</span>); <span class="comment">// 枚举后续棋子的所有合法移动组合</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//大循环套着小循环 无敌的存在</span></span><br></pre></td></tr></table></figure>

<h2 id="3001-捕捉黑皇后需要的最少移动次数"><a href="#3001-捕捉黑皇后需要的最少移动次数" class="headerlink" title="3001 捕捉黑皇后需要的最少移动次数"></a>3001 捕捉黑皇后需要的最少移动次数</h2><p>现有一个下标从 1 开始的 8 x 8 棋盘，上面有 3 枚棋子。</p>
<p>给你 6 个整数 a 、b 、c 、d 、e 和 f ，其中：</p>
<p>(a, b) 表示白色车的位置。<br>(c, d) 表示白色象的位置。<br>(e, f) 表示黑皇后的位置。<br>假定你只能移动白色棋子，返回捕获黑皇后所需的最少移动次数。</p>
<p>请注意：</p>
<p>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。<br>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。<br>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。<br>皇后不能移动。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>黑皇后无法移动 那么建立只需要判断移动路径上是否有黑皇后就可以了<br>这种迅速捕捉返回的问题属于回溯问题 当捕捉到有的时候count+1或者true<br>&#x2F;&#x2F; 但是有了可以挡住的问题 所以需要放弃回溯加入分类讨论算法<br>本身走的步数就很少所以直接把情况都列举出来<br>首先就是1步解决问题：<br>像和皇后在一条斜线上 中间没有车<br>车和皇后在一条行或者列上 中间没有象<br>这都是一步<br>剩下都是两步解决<br>象和皇后不在一条斜线上 ：车去解决问题 因为也不在一行上 所以两步<br>象和皇后在一条写线上：车把它挡住了 那么车移开 两步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// m 在 l 和 r 之间（写不写等号都可以）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">in_between</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(l, r) &lt; m &amp;&amp; m &lt; <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minMovesToCaptureTheQueen</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == e &amp;&amp; (c != e || !<span class="built_in">in_between</span>(b, d, f)) || <span class="comment">// 车直接攻击到皇后（同一行）</span></span><br><span class="line">            b == f &amp;&amp; (d != f || !<span class="built_in">in_between</span>(a, c, e)) || <span class="comment">// 车直接攻击到皇后（同一列）</span></span><br><span class="line">            c + d == e + f &amp;&amp; (a + b != e + f || !<span class="built_in">in_between</span>(c, a, e)) || <span class="comment">// 象直接攻击到皇后</span></span><br><span class="line">            c - d == e - f &amp;&amp; (a - b != e - f || !<span class="built_in">in_between</span>(c, a, e)))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="可以被一步捕获的棋子数"><a href="#可以被一步捕获的棋子数" class="headerlink" title="可以被一步捕获的棋子数"></a>可以被一步捕获的棋子数</h2><p>给定一个 8 x 8 的棋盘，只有一个 白色的车，用字符 ‘R’ 表示。棋盘上还可能存在白色的象 ‘B’ 以及黑色的卒 ‘p’。空方块用字符 ‘.’ 表示。</p>
<p>车可以按水平或竖直方向（上，下，左，右）移动任意个方格直到它遇到另一个棋子或棋盘的边界。如果它能够在一次移动中移动到棋子的方格，则能够 吃掉 棋子。</p>
<p>注意：车不能穿过其它棋子，比如象和卒。这意味着如果有其它棋子挡住了路径，车就不能够吃掉棋子。</p>
<p>返回白车将能 吃掉 的 卒的数量。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRookCaptures</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, st = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    st = i;</span><br><span class="line">                    ed = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">0</span>;; step++) &#123;</span><br><span class="line">                <span class="type">int</span> tx = st + step * dx[i];</span><br><span class="line">                <span class="type">int</span> ty = ed + step * dy[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">8</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">8</span> || board[tx][ty] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[tx][ty] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="骑士在棋盘上的概率"><a href="#骑士在棋盘上的概率" class="headerlink" title="骑士在棋盘上的概率"></a>骑士在棋盘上的概率</h2><p>在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。</p>
<p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格</p>
<p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p>
<p>骑士继续移动，直到它走了 k 步或离开了棋盘。</p>
<p>返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。</p>
<p>示例 1：</p>
<p>输入: n &#x3D; 3, k &#x3D; 2, row &#x3D; 0, column &#x3D; 0<br>输出: 0.0625<br>解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。<br>在每一个位置上，也有两种移动可以让骑士留在棋盘上。<br>骑士留在棋盘上的总概率是0.0625。<br>示例 2：</p>
<p>输入: n &#x3D; 1, k &#x3D; 0, row &#x3D; 0, column &#x3D; 0<br>输出: 1.00000</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这道题拿出来先分类 这种排列组合最后算概率的问题需要先把所有步数都拍出来 之后把在或者不在棋牌上的个数排出来进行除法<br>那么这是一个组合问题 一个暴力搜索组合 所以可以算作回溯问题的一种 把所有的步数列举出来 走路次数作为一个计数器 到了最后的次数之后判断是否在棋盘上<br>把不在棋盘山的个数统计出来 最后除法<br>试过了 记忆化搜索回溯没有问题能运行 那么记忆化搜索可以更换成递推</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义方向数组，骑士的8种可能移动方式</span></span><br><span class="line">    <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions = &#123;</span><br><span class="line">        &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义递归函数，带记忆化</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果越界，概率为0</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= n || c &lt; <span class="number">0</span> || c &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果步数耗尽，概率为1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经计算过，直接返回缓存值</span></span><br><span class="line">        <span class="keyword">if</span> (memo[r][c][k] != <span class="number">-1.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[r][c][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 累加概率</span></span><br><span class="line">        <span class="type">double</span> prob = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> newRow = r + dir.first;</span><br><span class="line">            <span class="type">int</span> newCol = c + dir.second;</span><br><span class="line">            prob += <span class="built_in">dfs</span>(n, k - <span class="number">1</span>, newRow, newCol, memo) / <span class="number">8.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存结果</span></span><br><span class="line">        memo[r][c][k] = prob;</span><br><span class="line">        <span class="keyword">return</span> prob;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化三维记忆化数组，全部填充为 -1.0</span></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&gt; <span class="built_in">memo</span>(n, vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(k + <span class="number">1</span>, <span class="number">-1.0</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用递归函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n, k, row, column, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">这是反过来的dp 加了虚拟边界和概率计算 突然发现即使不反过来直接dp计算也能跑通</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> DIRS[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&gt; <span class="built_in">f</span>(k + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;(n + <span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n + <span class="number">4</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fill</span>(f[<span class="number">0</span>][i].<span class="built_in">begin</span>() + <span class="number">2</span>, f[<span class="number">0</span>][i].<span class="built_in">begin</span>() + n + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">1</span>; step &lt;= k; step++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [dx, dy] : DIRS) &#123;</span><br><span class="line">                        f[step][i][j] += f[step - <span class="number">1</span>][i + dx][j + dy];</span><br><span class="line">                    &#125;</span><br><span class="line">                    f[step][i][j] /= <span class="number">8</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[k][row + <span class="number">2</span>][column + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="782-变为棋盘"><a href="#782-变为棋盘" class="headerlink" title="782 变为棋盘"></a>782 变为棋盘</h2><p>一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能交换任意两列或是两行的位置。</p>
<p>返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。</p>
<p>“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>
<p>示例 1:</p>
<p>输入: board &#x3D; [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]<br>输出: 2<br>解释:一种可行的变换方式如下，从左到右：<br>第一次移动交换了第一列和第二列。<br>第二次移动交换了第二行和第三行。<br>示例 2:</p>
<p>输入: board &#x3D; [[0, 1], [1, 0]]<br>输出: 0<br>解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.<br>示例 3:</p>
<p>输入: board &#x3D; [[1, 0], [1, 0]]<br>输出: -1<br>解释: 任意的变换都不能使这个输入变为合法的棋盘。</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movesToChessboard</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; first_row = board[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">first_col</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> row_cnt[<span class="number">2</span>]&#123;&#125;, col_cnt[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            row_cnt[first_row[i]]++; <span class="comment">// 统计 0 和 1 的个数</span></span><br><span class="line">            first_col[i] = board[i][<span class="number">0</span>];</span><br><span class="line">            col_cnt[first_col[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行，0 和 1 的个数之差不能超过 1</span></span><br><span class="line">        <span class="comment">// 第一列，0 和 1 的个数之差不能超过 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(row_cnt[<span class="number">0</span>] - row_cnt[<span class="number">1</span>]) &gt; <span class="number">1</span> || <span class="built_in">abs</span>(col_cnt[<span class="number">0</span>] - col_cnt[<span class="number">1</span>]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一行和第一行比较，要么完全相同，要么完全不同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : board) &#123;</span><br><span class="line">            <span class="type">bool</span> same = row[<span class="number">0</span>] == first_row[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row[i] == first_row[i]) != same) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最小交换次数</span></span><br><span class="line">        <span class="keyword">auto</span> min_swap = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> cnt[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> x0 = cnt[<span class="number">1</span>] &gt; cnt[<span class="number">0</span>]; <span class="comment">// 如果 n 是偶数，x0 是 0</span></span><br><span class="line">            <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                diff += i % <span class="number">2</span> ^ arr[i] ^ x0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n % <span class="number">2</span> ? diff / <span class="number">2</span> : <span class="built_in">min</span>(diff, n - diff) / <span class="number">2</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min_swap</span>(first_row, row_cnt) + <span class="built_in">min_swap</span>(first_col, col_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1812-判断国际象棋的颜色"><a href="#1812-判断国际象棋的颜色" class="headerlink" title="1812 判断国际象棋的颜色"></a>1812 判断国际象棋的颜色</h2><p>给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。</p>
<p>如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。</p>
<p>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>碰运气</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">squareIsWhite</span><span class="params">(string coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((coordinates[<span class="number">0</span>] ) + (coordinates[<span class="number">1</span>])) %<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="935骑士拨号器"><a href="#935骑士拨号器" class="headerlink" title="935骑士拨号器"></a>935骑士拨号器</h2><p>象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。</p>
<p>象棋骑士可能的移动方式如下图所示:</p>
<p>我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。</p>
<p>给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。</p>
<p>你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。</p>
<p>因为答案可能很大，所以输出答案模 109 + 7.</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>传统的记忆化回溯</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; NEXT[<span class="number">10</span>] = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> memo[<span class="number">5000</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : NEXT[j]) &#123;</span><br><span class="line">        res = (res + <span class="built_in">dfs</span>(i - <span class="number">1</span>, k)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(n - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态机记忆法</span></span><br><span class="line">把不同的数分成不同的状态 最后计算不同状态能得到的步数 再合起来</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; NEXT[<span class="number">10</span>] = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> memo[<span class="number">5000</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : NEXT[j]) &#123;</span><br><span class="line">        res = (res + <span class="built_in">dfs</span>(i - <span class="number">1</span>, k)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(n - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改成dp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MX = <span class="number">5000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MX][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数，初始化 f 数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">2</span>] = f[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MX; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = (f[i - <span class="number">1</span>][<span class="number">1</span>] + f[i - <span class="number">1</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">2</span> % MOD;</span><br><span class="line">        f[i][<span class="number">2</span>] = (f[i - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">2</span> + f[i - <span class="number">1</span>][<span class="number">3</span>]) % MOD;</span><br><span class="line">        f[i][<span class="number">3</span>] = f[i - <span class="number">1</span>][<span class="number">2</span>] * <span class="number">2</span> % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里调用 init 函数进行初始化</span></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f[n - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">4</span> + f[n - <span class="number">1</span>][<span class="number">1</span>] * <span class="number">2</span> +</span><br><span class="line">                f[n - <span class="number">1</span>][<span class="number">2</span>] * <span class="number">2</span> + f[n - <span class="number">1</span>][<span class="number">3</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2931-购买物品的最大开销"><a href="#2931-购买物品的最大开销" class="headerlink" title="2931. 购买物品的最大开销"></a>2931. 购买物品的最大开销</h2><p>给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 &lt;&#x3D; j &lt; n - 1 都有 values[i][j] &gt;&#x3D; values[i][j + 1] 。</p>
<p>每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：</p>
<p>选择商店 i 。<br>购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。<br>注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。</p>
<p>请你返回购买所有 m * n 件物品需要的 最大开销 。</p>
<p>示例 1：</p>
<p>输入：values &#x3D; [[8,5,2],[6,4,1],[9,7,3]]<br>输出：285<br>解释：第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 &#x3D; 1 。<br>第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 &#x3D; 4 。<br>第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 &#x3D; 9 。<br>第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 &#x3D; 16 。<br>第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 &#x3D; 25 。<br>第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 &#x3D; 36 。<br>第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 &#x3D; 49 。<br>第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 &#x3D; 64 。<br>第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 &#x3D; 81 。<br>所以总开销为 285 。<br>285 是购买所有 m * n 件物品的最大总开销。<br>示例 2：</p>
<p>输入：values &#x3D; [[10,8,6,4,2],[9,7,5,3,2]]<br>输出：386<br>解释：第一天，从商店 0 购买物品 4 ，开销为 values[0][4] * 1 &#x3D; 2 。<br>第二天，从商店 1 购买物品 4 ，开销为 values[1][4] * 2 &#x3D; 4 。<br>第三天，从商店 1 购买物品 3 ，开销为 values[1][3] * 3 &#x3D; 9 。<br>第四天，从商店 0 购买物品 3 ，开销为 values[0][3] * 4 &#x3D; 16 。<br>第五天，从商店 1 购买物品 2 ，开销为 values[1][2] * 5 &#x3D; 25 。<br>第六天，从商店 0 购买物品 2 ，开销为 values[0][2] * 6 &#x3D; 36 。<br>第七天，从商店 1 购买物品 1 ，开销为 values[1][1] * 7 &#x3D; 49 。<br>第八天，从商店 0 购买物品 1 ，开销为 values[0][1] * 8 &#x3D; 64 。<br>第九天，从商店 1 购买物品 0 ，开销为 values[1][0] * 9 &#x3D; 81 。<br>第十天，从商店 0 购买物品 0 ，开销为 values[0][0] * 10 &#x3D; 100 。<br>所以总开销为 386 。<br>386 是购买所有 m * n 件物品的最大总开销。</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>首先拿过来发现这是一个选择问题啊 选择之前没选过的才行 那么就是贪心 直接选择这里面价值最小的完了之后开始求和就可以了<br>怎么进行排序呢 合并数组进行快排吗 不对 本身就是从大到小了 但是之间的界限没定下来啊<br>定义一个数组表示每一行没有使用的最小值 这不就是优先队列吗 把最小的直接拿出来的同时把<br>最小的这一行的剩余一个加入进去 如果没了就跳过 直到所有的数都计算过来 用计数器进行计数 或者直接没了就行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//优先队列灭有问题 用的确实是pair 把最后一行数先掉进去</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSpending</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = values.<span class="built_in">size</span>(), n = values[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">          pq.<span class="built_in">push</span>(&#123;values[i].<span class="built_in">back</span>(), i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= m * n; d++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [v, i] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans += (<span class="type">long</span> <span class="type">long</span>) v * d;</span><br><span class="line">            values[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (!values[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(values[i].<span class="built_in">back</span>(), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3264-K次乘运算后的最终数组"><a href="#3264-K次乘运算后的最终数组" class="headerlink" title="3264.K次乘运算后的最终数组"></a>3264.K次乘运算后的最终数组</h2><p>给你一个整数数组 nums ，一个整数 k  和一个整数 multiplier 。</p>
<p>你需要对 nums 执行 k 次操作，每次操作中：</p>
<p>找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个。<br>将 x 替换为 x * multiplier 。<br>请你返回执行完 k 次乘运算之后，最终的 nums 数组。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,1,3,5,6], k &#x3D; 5, multiplier &#x3D; 2</p>
<p>输出：[8,4,6,5,6]</p>
<p>解释：</p>
<p>操作	结果<br>1 次操作后	[2, 2, 3, 5, 6]<br>2 次操作后	[4, 2, 3, 5, 6]<br>3 次操作后	[4, 4, 3, 5, 6]<br>4 次操作后	[4, 4, 6, 5, 6]<br>5 次操作后	[8, 4, 6, 5, 6]<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2], k &#x3D; 3, multiplier &#x3D; 4</p>
<p>输出：[16,8]</p>
<p>解释：</p>
<p>操作	结果<br>1 次操作后	[4, 2]<br>2 次操作后	[4, 8]<br>3 次操作后	[16, 8]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; k &lt;&#x3D; 10<br>1 &lt;&#x3D; multiplier &lt;&#x3D; 5</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>直接每次找到最小的赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_min</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> result =INT_MAX;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a =<span class="number">0</span>;a&lt;nums.<span class="built_in">size</span>();a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a] &lt; result)&#123;</span><br><span class="line">                result =nums[a];</span><br><span class="line">                i =a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getFinalState</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find_min</span>(nums);</span><br><span class="line">            nums[a] = multiplier * nums[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1338-数组大小减半"><a href="#1338-数组大小减半" class="headerlink" title="1338 数组大小减半"></a>1338 数组大小减半</h2><p>给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。</p>
<p>返回 至少 能删除数组中的一半整数的整数集合的最小大小。</p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [3,3,3,3,5,5,5,2,2,7]<br>输出：2<br>解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。<br>大小为 2 的可行集合有 {3,5},{3,2},{5,2}。<br>选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。<br>示例 2：</p>
<p>输入：arr &#x3D; [7,7,7,7,7,7]<br>输出：1<br>解释：我们只能选择集合 {7}，结果数组为空。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>arr.length 为偶数<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 105</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>贪心  找最大的先删去在进行比较<br>这种字符在字符串出现次数的排序可以用map<br>之后把map后面的数据都相加做 while循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSetSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;  <span class="comment">// 用于存储每个元素的出现次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计 arr 中每个元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">            freq[x]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将频率信息提取到一个新的 vector 中</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, c] : freq) &#123;</span><br><span class="line">            cnt.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ranges::sort 排序，按频率从大到小排序</span></span><br><span class="line">        ranges::<span class="built_in">sort</span>(cnt, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;  <span class="comment">// 用来记录当前已删除元素的总数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            s += cnt[i];  <span class="comment">// 增加当前最大频率的元素数</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= arr.<span class="built_in">size</span>() / <span class="number">2</span>) &#123;  <span class="comment">// 当已删除的元素数大于等于原数组的一半时</span></span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回最小集合的大小，即删除的元素个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最近的房间"><a href="#最近的房间" class="headerlink" title="最近的房间"></a>最近的房间</h2><p>一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] &#x3D; [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。</p>
<p>同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] &#x3D; [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：</p>
<p>房间的面积 至少 为 minSizej ，且<br>abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。<br>如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。</p>
<p>请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。</p>
<p>示例 1：</p>
<p>输入：rooms &#x3D; [[2,2],[1,2],[3,2]], queries &#x3D; [[3,1],[3,3],[5,2]]<br>输出：[3,-1,3]<br>解释：查询的答案如下：<br>查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) &#x3D; 0 ，所以答案为 3 。<br>查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。<br>查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) &#x3D; 2 ，所以答案为 3 。<br>示例 2：</p>
<p>输入：rooms &#x3D; [[1,4],[2,3],[3,5],[4,1],[5,2]], queries &#x3D; [[2,3],[2,4],[2,5]]<br>输出：[2,1,3]<br>解释：查询的答案如下：<br>查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) &#x3D; 0 ，所以答案为 2 。<br>查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。<br>查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。</p>
<p>提示：</p>
<p>n &#x3D;&#x3D; rooms.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>k &#x3D;&#x3D; queries.length<br>1 &lt;&#x3D; k &lt;&#x3D; 104<br>1 &lt;&#x3D; roomIdi, preferredj &lt;&#x3D; 107<br>1 &lt;&#x3D; sizei, minSizej &lt;&#x3D; 107</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" data-id="cm4ckzpei00014gvq4siw57l7" data-title="每日一题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/%E5%9B%BE%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2024-12-01T13:28:34.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/%E5%9B%BE%E8%AE%BA/">图论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="两种存储写法"><a href="#两种存储写法" class="headerlink" title="两种存储写法"></a>两种存储写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="comment">// 使用邻接矩阵 ，1 表示 节点s 指向 节点t</span></span><br><span class="line">    graph[s][t] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">    graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度搜索模板"><a href="#深度搜索模板" class="headerlink" title="深度搜索模板"></a>深度搜索模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="所有可达路径"><a href="#所有可达路径" class="headerlink" title="所有可达路径"></a>所有可达路径</h2><p>【题目描述】</p>
<p>给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。</p>
<p>【输入描述】</p>
<p>第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边</p>
<p>后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径</p>
<p>【输出描述】</p>
<p>输出所有的可达路径，路径中所有节点的后面跟一个空格，每条路径独占一行，存在多条路径，路径输出的顺序可任意。</p>
<p>如果不存在任何一条路径，则输出 -1。</p>
<p>注意输出的序列中，最后一个节点后面没有空格！ 例如正确的答案是 1 3 5,而不是 1 3 5， 5后面没有空格！</p>
<p>【输入示例】</p>
<p>5 5<br>1 3<br>3 5<br>1 2<br>2 4<br>4 5<br>【输出示例】</p>
<p>1 3 5<br>1 2 4 5  </p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>每到一个新的节点就遍历所有节点进入下一个节点 当节点够了就放变量里存储起来<br>同时在每次进入新的节点之后回来要回溯</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 1节点到终点的路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前遍历的节点x 到达节点n </span></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> (graph[x][i] == <span class="number">1</span>) &#123; <span class="comment">// 找到 x链接的节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span></span><br><span class="line">        graph[s][t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, n); <span class="comment">// 开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph,<span class="type">int</span> x,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:graph[x])&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(graph,i,n);</span><br><span class="line">        path.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">graph</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grapt,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa:result)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cout&lt;&lt;pa[i]&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;pa[pa.<span class="built_in">size</span>()<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>使用队列<br>注意坐标越界的条件grid.size()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">nt dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p>
<p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p>
<p>输出描述：</p>
<p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p>
<p>输入示例：</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>看了题解之后发现和上一个题目一样 如果用深度搜索就是把搜索的每个位置都记录下来 所以新的陆地一定没有被记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nexty &gt;= grid.<span class="built_in">size</span>() || nexty&lt;<span class="number">0</span> || nexty&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] ==<span class="number">1</span>)&#123;</span><br><span class="line">            visited[nextx][nexty] =<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid,visited,nextx,nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                visited[i][j] =<span class="literal">true</span>;</span><br><span class="line">                result++;</span><br><span class="line">                <span class="built_in">dfs</span>(grid,visited,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;result &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广搜版解法 加了个队列同时标记边上的点<br>如果从队列拿出节点，再去标记这个节点走过，就会发生高复杂度的结果，会导致很多节点重复加入队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x,y&#125;);<span class="comment">//这里没写对</span></span><br><span class="line">    visited[x][y] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cur =que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nextx&gt;=grid.<span class="built_in">size</span>() || nexty &lt;<span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())&#123;<span class="comment">//这也没写对</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx,nexty&#125;);</span><br><span class="line">                visited[nextx][nexty] =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;<span class="built_in">visited</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++&gt;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                result ++;</span><br><span class="line">                <span class="built_in">bfs</span>(grid,visited,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;result&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><p>题目描述</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述</p>
<p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p>
<p>输入示例</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1<br>输出示例</p>
<p>4</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>和上面一摸一样 区别就是加了个每次进行函数使用的时候都要比较当前处理的和以前处理的的大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp;visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x+ dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty =y +dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> ||nexty &gt;= grid.<span class="built_in">size</span>() || nexty&lt;<span class="number">0</span> || nexty &gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>())<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//忘了这个了</span></span><br><span class="line">            visited[next][nexty] =<span class="literal">true</span>;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="built_in">dfs</span>(grid,visited,nextx,nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt;grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                count =<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid,visited,i,j);</span><br><span class="line">                result =<span class="built_in">max</span>(result,count)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs 这个广搜的队列改成Int格式了</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> dirp[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(x);</span><br><span class="line">    que.<span class="built_in">push</span>(y);</span><br><span class="line">    visited[x][y] =<span class="literal">true</span>;</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> xx = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> yy =que.<span class="built_in">front</span>()；</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = xx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = yy + die[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nexty &gt;=grid.<span class="built_in">size</span>() || nexty &lt;<span class="number">0</span> ||nexty &gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] ==<span class="number">1</span>)&#123;</span><br><span class="line">                    visited[nextx][nexty] =<span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(nextx);</span><br><span class="line">                    que.<span class="built_in">push</span>(nexty);</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, visited, i, j); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                    result = <span class="built_in">max</span>(result, count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="孤岛的总面积"><a href="#孤岛的总面积" class="headerlink" title="孤岛的总面积"></a>孤岛的总面积</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>
<p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p>
<p>输出描述</p>
<p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p>
<p>输入示例</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>把每次计算最大的改成个加法计数 同时题目要去不能靠着边<br>所以在深度优先搜多里面的时候进行边缘遍历同时把1都变成0<br>之后再把已经去掉边缘的部分都遍历一遍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    grid[x][y] =<span class="number">0</span>;<span class="comment">//处理</span></span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() ||nexty &lt;<span class="number">0</span> || nexty &gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[nextx][nexty] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid,nextx,nexty);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//?</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][<span class="number">0</span>] == <span class="number">1</span>)<span class="built_in">dfs</span>(grid,i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(grid[i][m<span class="number">-1</span>] ==<span class="number">1</span>)<span class="built_in">dfs</span>(grid,i,m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][j] == <span class="number">1</span>)<span class="built_in">dfs</span>(grid,<span class="number">0</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(grid[n<span class="number">-1</span>][j] == <span class="number">1</span>) <span class="built_in">dfs</span>(gris,n<span class="number">-1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] ==<span class="number">1</span>)<span class="built_in">dfs</span>(grid,i,j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;count &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> count =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid, <span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    count ++;</span><br><span class="line">    grid[x][y] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = curx +dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury +dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nextx &gt;=grid.<span class="built_in">size</span>() || nexty &lt;<span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(grid[nextx][nexty] == <span class="number">1</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx,nexty&#125;);</span><br><span class="line">                count ++;<span class="comment">//注意</span></span><br><span class="line">                grid[nextx][nexty] = <span class="number">0</span>;<span class="comment">//处理</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &lt;&lt;n &lt;&lt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;i&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt;grid[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (grid[i][m - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从上边和下边 向中间遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (grid[n - <span class="number">1</span>][j] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, n - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="沉没孤岛"><a href="#沉没孤岛" class="headerlink" title="沉没孤岛"></a>沉没孤岛</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>
<p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p>
<p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述</p>
<p>输出将孤岛“沉没”之后的岛屿矩阵。</p>
<p>输入示例：</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1<br>输出示例：</p>
<p>1 1 0 0 0<br>1 1 0 0 0<br>0 0 0 0 0<br>0 0 0 1 1</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>太机智了 先把所有边缘的变成2，   后续直接遍历判断再把按照条件中间的变成0 孤岛变成1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// 保存四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 向四个方向遍历</span></span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 超过边界</span></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 不符合条件，不继续遍历</span></span><br><span class="line">        <span class="keyword">if</span> (grid[nextx][nexty] == <span class="number">0</span> || grid[nextx][nexty] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span> (grid, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：</span></span><br><span class="line">    <span class="comment">// 从左侧边，和右侧边 向中间遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (grid[i][m - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上边和下边 向中间遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (grid[n - <span class="number">1</span>][j] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, n - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤二、步骤三</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cout &lt;&lt; grid[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="水流问题"><a href="#水流问题" class="headerlink" title="水流问题"></a>水流问题</h2><p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p>
<p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p>
<p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p>
<p>输出描述：</p>
<p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p>
<p>输入示例：</p>
<p>5 5<br>1 3 1 2 4<br>1 2 1 3 2<br>2 4 7 2 1<br>4 5 6 1 1<br>1 4 1 2 1<br>输出示例：</p>
<p>0 4<br>1 3<br>2 2<br>3 0<br>3 1<br>3 2<br>4 0<br>4 1</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>为了复杂度问题 逆向解决</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] &gt; grid[nextx][nexty]) <span class="keyword">continue</span>; <span class="comment">// 注意：这里是从低向高遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span> (grid, visited, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">firstBorder</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">secondBorder</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最上和最下行的节点出发，向高处遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span> (grid, firstBorder, i, <span class="number">0</span>); <span class="comment">// 遍历最左列，接触第一组边界</span></span><br><span class="line">        <span class="built_in">dfs</span> (grid, secondBorder, i, m - <span class="number">1</span>); <span class="comment">// 遍历最右列，接触第二组边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最左和最右列的节点出发，向高处遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span> (grid, firstBorder, <span class="number">0</span>, j); <span class="comment">// 遍历最上行，接触第一组边界</span></span><br><span class="line">        <span class="built_in">dfs</span> (grid, secondBorder, n - <span class="number">1</span>, j); <span class="comment">// 遍历最下行，接触第二组边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span></span><br><span class="line">            <span class="keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造最大岛屿"><a href="#建造最大岛屿" class="headerlink" title="建造最大岛屿"></a>建造最大岛屿</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p>
<p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述：</p>
<p>输出一个整数，表示最大的岛屿面积。</p>
<p>输入示例：</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1<br>输出示例</p>
<p>6</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>首先给是1的陆地打上标签 之后再遍历所有为0的数 同时看和没和不同的陆地相互联系<br>这里需要加一个map来存储每一块的陆地本身含有的面积 加上一个set来再每次遍历的时候看有没有不同的标签标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> mark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y] || grid[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 终止条件：访问过的节点 或者 遇到海水</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 标记访问过</span></span><br><span class="line">    grid[x][y] = mark; <span class="comment">// 给陆地标记新标签</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, visited, nextx, nexty, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>)); <span class="comment">// 标记访问过的点</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; gridNum;</span><br><span class="line">    <span class="type">int</span> mark = <span class="number">2</span>; <span class="comment">// 记录每个岛屿的编号</span></span><br><span class="line">    <span class="type">bool</span> isAllGrid = <span class="literal">true</span>; <span class="comment">// 标记是否整个地图都是陆地</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) isAllGrid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, visited, i, j, mark); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                gridNum[mark] = count; <span class="comment">// 记录每一个岛屿的面积</span></span><br><span class="line">                mark++; <span class="comment">// 记录下一个岛屿编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAllGrid) &#123;</span><br><span class="line">        cout &lt;&lt; n * m &lt;&lt; endl; <span class="comment">// 如果都是陆地，返回全面积</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 记录最后结果</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; visitedGrid; <span class="comment">// 标记访问过的岛屿</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            count = <span class="number">1</span>; <span class="comment">// 记录连接之后的岛屿数量</span></span><br><span class="line">            visitedGrid.<span class="built_in">clear</span>(); <span class="comment">// 每次使用时，清空</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;<span class="comment">//上下左右观察</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> neari = i + dir[k][<span class="number">1</span>]; <span class="comment">// 计算相邻坐标</span></span><br><span class="line">                    <span class="type">int</span> nearj = j + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (neari &lt; <span class="number">0</span> || neari &gt;= n || nearj &lt; <span class="number">0</span> || nearj &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visitedGrid.<span class="built_in">count</span>(grid[neari][nearj])) <span class="keyword">continue</span>; <span class="comment">// 添加过的岛屿不要重复添加</span></span><br><span class="line">                    <span class="comment">// 把相邻四面的岛屿数量加起来</span></span><br><span class="line">                    count += gridNum[grid[neari][nearj]];</span><br><span class="line">                    visitedGrid.<span class="built_in">insert</span>(grid[neari][nearj]); <span class="comment">// 标记该岛屿已经添加过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串接龙"><a href="#字符串接龙" class="headerlink" title="字符串接龙"></a>字符串接龙</h2><p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：</p>
<p>序列中第一个字符串是 beginStr。</p>
<p>序列中最后一个字符串是 endStr。</p>
<p>每次转换只能改变一个字符。</p>
<p>转换过程中的中间字符串必须是字典 strList 中的字符串。</p>
<p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p>
<p>输入描述</p>
<p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。</p>
<p>输出描述</p>
<p>输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。</p>
<p>输入示例</p>
<p>6<br>abc def<br>efc<br>dbc<br>ebc<br>dec<br>dfc<br>yhn<br>输出示例</p>
<p>4</p>
<p>提示信息</p>
<p>从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4</p>
<p>数据范围：</p>
<p>2 &lt;&#x3D; N &lt;&#x3D; 500</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>这道题也是看题解做出来的<br>这道题属于图论的原因是每个新的节点都可能和其他节点有连接 之后在加上这是一个无向图<br>因为无向图的原因需要加上一个记录节点的表防止进入死循环<br>每一个字节都需要遍历24个字母来看有没有节点变化和它相等用作新的节点<br>这道题要求最小的路程 那么就是说可以当作bfs来解决问题这样第一个和最后相等的直接返回路程一定是最短的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string beginStr，endStr，str</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;string&gt; strSet;<span class="comment">//用作存储输入字符串的</span></span><br><span class="line">    cin &gt;&gt; beginStr&gt;&gt; endStr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt;str;</span><br><span class="line">        strSet.<span class="built_in">insert</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; visitedMap;<span class="comment">//选择的字符串 从开始到达当前字符串走过的路程</span></span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(beginStr);</span><br><span class="line">    visitMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(beginStr,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        string word =que.<span class="built_in">frong</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> path = visitMap[word];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string newWord = word;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line">                newWord[i] = <span class="string">&#x27;a&#x27;</span> + j;<span class="comment">//全都换一遍</span></span><br><span class="line">                <span class="keyword">if</span>(newWord == endStr)&#123;</span><br><span class="line">                    cout &lt;&lt; path <span class="number">+1</span> &lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(strStr.<span class="built_in">find</span>(newWord) != strSet.<span class="built_in">end</span>() &amp;&amp; visitedMap.<span class="built_in">find</span>() ==  visitMap.<span class="built_in">end</span>())&#123;<span class="comment">//为了不陷入死循环</span></span><br><span class="line">                    visitMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(newWord,path + <span class="number">1</span>));</span><br><span class="line">                    que.<span class="built_in">push</span>(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有向图的完全可达性"><a href="#有向图的完全可达性" class="headerlink" title="有向图的完全可达性"></a>有向图的完全可达性</h2><p>【题目描述】</p>
<p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p>
<p>【输出描述】</p>
<p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p>
<p>【输入示例】</p>
<p>4 4<br>1 2<br>2 1<br>1 3<br>2 4</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>这是我第一次接触有向图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> key, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[key] = <span class="literal">true</span>;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys) &#123;</span><br><span class="line">        <span class="comment">// 深度优先搜索遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, key, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, visited);</span><br><span class="line">    <span class="comment">//检查是否都访问到了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p>
<p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述</p>
<p>输出一个整数，表示岛屿的周长。</p>
<p>输入示例</p>
<p>5 5<br>0 0 0 0 0<br>0 1 0 1 0<br>0 1 1 1 0<br>0 1 1 1 0<br>0 0 0 0 0</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>这道题和搜索没有关系 分类讨论即可<br>遍历每一个边 如果新的地方有水则是一条边 或者到了边界也是一条边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;       <span class="comment">// 上下左右四个方向</span></span><br><span class="line">                    <span class="type">int</span> x = i + direction[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> y = j + direction[k][<span class="number">1</span>];    <span class="comment">// 计算周边坐标x,y</span></span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span>                       <span class="comment">// x在边界上</span></span><br><span class="line">                            || x &gt;= grid.<span class="built_in">size</span>()     <span class="comment">// x在边界上</span></span><br><span class="line">                            || y &lt; <span class="number">0</span>                <span class="comment">// y在边界上</span></span><br><span class="line">                            || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()  <span class="comment">// y在边界上</span></span><br><span class="line">                            || grid[x][y] == <span class="number">0</span>) &#123;   <span class="comment">// x,y位置是水域</span></span><br><span class="line">                        result++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。<br>将两个元素添加到一个集合中。<br>判断两个元素在不在同一个集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始设定</span></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向</span></span><br><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找根节点</span></span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="comment">//直接让字节点指向接住根节点  结果没有变化 但是让指向变成了直接指向</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是一个根</span></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总体模板</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个<br>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上<br>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</p>
<p>另外一种表示 按秩合并</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>); <span class="comment">// 初始每棵树的高度都为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>; <span class="comment">// 也可以不写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : <span class="built_in">find</span>(father[u]);<span class="comment">// 注意这里不做路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="comment">// rank小的树合入到rank大的树</span></span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h2><p>题目描述</p>
<p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p>
<p>你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p>
<p>输入描述</p>
<p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p>
<p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。</p>
<p>最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p>
<p>输出描述</p>
<p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p>
<p>输入示例</p>
<p>5 4<br>1 2<br>1 3<br>2 4<br>3 4<br>1 4<br>输出示例</p>
<p>1</p>
<h3 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h3><p>并查集可以解决什么问题呢？</p>
<p>主要就是集合问题，两个节点在不在一个集合，也可以将两个节点添加到一个集合中。<br>照抄一遍模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n =<span class="number">1000</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        father[i] =i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u:father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//v-&gt;u</span></span><br><span class="line">    u =<span class="built_in">find</span>(u);</span><br><span class="line">    v =<span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体使用操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 节点数量</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">101</span>, <span class="number">0</span>); <span class="comment">// 按照节点大小定义数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s, t, source, destination;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">join</span>(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; source &gt;&gt; destination;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSame</span>(source, destination)) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冗余操作"><a href="#冗余操作" class="headerlink" title="冗余操作"></a>冗余操作</h2><p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图（其实就是一个线形图）<br>现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图<br>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p>
<p>输入描述</p>
<p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p>
<p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。</p>
<p>输出描述</p>
<p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p>
<p>输入示例</p>
<p>3<br>1 2<br>2 3<br>1 3<br>输出示例</p>
<p>1 3</p>
<h3 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h3><p>重点还是思路 他想变成使得结果图是一个有着N个节点的树（即：只有一个根节点）。<br>所以就是当有同一个根节点的时候不能建立连接了 要不就成为环路了<br>那么就遍历所有的边 如果之前的边有相联的关系 那么就是要输出这个边 如果没有就加入这个边</p>
<p>这道题在我看来没有很好的和并查集进行符合 但是并查集因为可以做到查看是否在一个集合中所有可以通过这个并查集来判断这个边该不该存在 如果在一个集合里面<br>那么新的边就是多余的 但是我认为不一定环形 题意是冗余有一条 那么这个冗余会造成已经一个集合的边在集合一遍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 节点数量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 按照节点大小范围定义数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSame</span>(s, t)) &#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">join</span>(s, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冗余连接2"><a href="#冗余连接2" class="headerlink" title="冗余连接2"></a>冗余连接2</h2><p>有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。</p>
<p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。</p>
<p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p>
<p>输入描述</p>
<p>第一行输入一个整数 N，表示有向图中节点和边的个数。</p>
<p>后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边</p>
<p>输出描述</p>
<p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。</p>
<p>输入示例</p>
<p>3<br>1 2<br>1 3<br>2 3<br>输出示例</p>
<p>2 3</p>
<h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><p>回头看解法处理最重要的问题是在回头遍历寻找边<br>当有两个入点的边 存入到数组里<br>之后正向循环并查集 通过并查集看没有这个节点构成的边是否是正常的连接 如果是边<br>分类条论 如果入度有两个 一种是删除其中一条边之后没问题<br>另一种删除一条边之后会发现丢了一个节点 同时环这个问题没有解决 可以通过并查集来判断环来判断这个问题影响<br>&#x2F;&#x2F;上边这两种情况属于有多个边的从后往前遍历</p>
<p>入度不为2的时候是一种为环的情况  这个时候就通过并查集判断是否有环就可以了-&gt;删除为环的那个边界 最后一个所以从前向后遍历就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span> <span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经典并查集集合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在有向图里找到删除的那条边，使其变成树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRemoveEdge</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历所有的边</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">same</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) &#123; <span class="comment">// 构成有向环了，就是要删除的边</span></span><br><span class="line">            cout &lt;&lt; edges[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删一条边之后判断是不是树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTreeAfterRemoveEdge</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> deleteEdge)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == deleteEdge) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">same</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) &#123; <span class="comment">// 构成有向环了，一定不是树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 记录节点入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        inDegree[t]++;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;s, t&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 记录入度为2的边（如果有的话就两条边）</span></span><br><span class="line">    <span class="comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[edges[i][<span class="number">1</span>]] == <span class="number">2</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(i);<span class="comment">//这里0和1的边界没有判断明白</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况一、情况二</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="number">0</span>])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[<span class="number">0</span>]][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="number">0</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[<span class="number">1</span>]][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理情况三</span></span><br><span class="line">    <span class="comment">// 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了</span></span><br><span class="line">    <span class="built_in">getRemoveEdge</span>(edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/01/%E5%9B%BE%E8%AE%BA/" data-id="cm4ckzpek00034gvq45z12egg" data-title="图论" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-单调栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2024-11-28T07:48:52.000Z" itemprop="datePublished">2024-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这道题是单调栈的第一道题<br>首要要明白单调栈的排序顺序<br>记住当要求求右边第一个比自己大的距离 那么这个单调栈就应该设定为从栈头开头到栈底递增顺序才行<br>这样的话当第一个比自己大的时候就开始弹出计算<br>那么求右边第一个比自己小的 那么这个栈就是递减栈才行 放入了比自己小的就该弹出了</p>
<p>注意等于的时候应该也入库而不是计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; T)</span> </span>&#123;<span class="comment">//注意第一个入栈是0 因为result计算是按照栈顶元素开始所以不用担心第一个元素的问题</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(T.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i]&lt;T[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T[i] == T[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;T[i]&gt;T[st.top])&#123;</span><br><span class="line">                result[st.top] = i-st.top;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);<span class="comment">//这是关键</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="下一个更大元素1"><a href="#下一个更大元素1" class="headerlink" title="下一个更大元素1"></a>下一个更大元素1</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 1:</p>
<p>输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>示例 2:<br>输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 </p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>移行变换<br>相当于变换位置之后比较大小<br>我的想法是还是单调栈进行比较<br>首先确定是递增栈 这样才能求大的 大的才能弹出小的继续放<br>那么最后做一个映射就可以了 在计算第二个数组所有的距离的时候对比一下是否含有第一个数组的值之后纳入计算结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立映射</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; umap;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums<span class="number">1.</span>size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        umap[nums1[i]] =i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始建立单调栈关系</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums2[st.<span class="built_in">top</span>()]&gt;=nums2[i]) st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">if</span>(umap.count[nums2[st.<span class="built_in">top</span>()]])&#123;</span><br><span class="line">                    <span class="type">int</span> index = umap[nums2[st.top]];</span><br><span class="line">                    result[index] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);<span class="comment">//判断完了之后加进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大的元素2"><a href="#下一个更大的元素2" class="headerlink" title="下一个更大的元素2"></a>下一个更大的元素2</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。<br>数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，<br>这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例 1:</p>
<p>输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>和前面一样唯一的问题是加了个循环 可以通过拼接数组或者去余数去解决 还是拼接数组吧单调栈起码能<br>做出来<br>好吧题解就是这两种方法 服了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; i++) &#123; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] &lt; nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] == nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>()); </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例 2：</p>
<p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>双指针对比当前列有多少可以解<br>但是用单调栈<br>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</p>
<p>而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。</p>
<p>我先写个双指针的接雨水</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意这个</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    right[height.<span class="built_in">size</span>()<span class="number">-1</span>] = height [height.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;<span class="comment">//这有个不小的问题就是在考虑左右柱子的时候需要考虑一下自己这么做有两个方面 首先是能全局比较 第二面就是能在最后计算的时候如果自己最高能计入进去不算这个积累</span></span><br><span class="line">        left[i] = <span class="built_in">max</span>(left[i<span class="number">-1</span>],height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=height.<span class="built_in">size</span>()<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j-- )&#123;</span><br><span class="line">        right[j] = <span class="built_in">max</span>(right[j<span class="number">+1</span>],height[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        result +=<span class="built_in">min</span>(left[i],right[i])-height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个单调栈写法<br>单调栈这个其实更好理解 不在执着于求每一列，而是遇到凹槽的时候直接把凹槽的求了<br>所以可以直接求很多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">  st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//既然是凹槽形式的 那么肯定是新的比旧的大才让旧的弹出去 那么本身应该就是递增栈 小的才能放进去</span></span><br><span class="line">  <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(height[i] &lt;<span class="built_in">height</span>(st.<span class="built_in">top</span>()))</span><br><span class="line">      &#123;</span><br><span class="line">          st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == <span class="built_in">height</span>(st.<span class="built_in">top</span>()))&#123;</span><br><span class="line">          st.<span class="built_in">pop</span>();</span><br><span class="line">          st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; <span class="built_in">height</span>(st.top) )&#123;</span><br><span class="line">              <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">              st.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                  <span class="type">int</span> h = <span class="built_in">min</span>(height[st.top],height[i]) - height[mid];</span><br><span class="line">                  <span class="type">int</span> w = i - st.top - <span class="number">1</span>;</span><br><span class="line">                  result += h * w;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>第一点求面积最大 应该是当前高度下不低于它的高度的最大宽度这么取比较<br>第二点 接雨水的时候第一个柱子和最后一个柱子不能接雨水 但是求面积的时候 都能算上了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(heights.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(heights.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    right[height.<span class="built_in">size</span>()<span class="number">-1</span>] =heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> t =i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;=<span class="number">0</span> &amp;&amp; heights[t] &gt;=heights[i]) t = left[t];</span><br><span class="line">        left[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    right[heights.<span class="built_in">size</span>()<span class="number">-1</span>] =size;<span class="comment">//初始化用来跳出循环的最后一个条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=heights.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> t = t<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;heights.<span class="built_in">size</span>() &amp;&amp; heights[t] &gt;=heights[i] ) t = right[t];</span><br><span class="line">        right[i] =t;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum =heights[i] *(right[i]-left[i]<span class="number">-1</span>);</span><br><span class="line">        result =<span class="built_in">max</span>(sum,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的双指针难点在跳跃和初始化<br>下面用单调栈做一下 思路：<br>和接雨水反过来 当接下来的比它下就开始弹出去做一个面积计算<br>那么这个栈就是递减栈才行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// 数组头部加入元素0</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 数组尾部加入元素0</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素已经入栈，从下标1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 情况一</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] == heights[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 情况二</span></span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 这个可以加，可以不加，效果一样，思路不同</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况三</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 注意是while</span></span><br><span class="line">                    <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="type">int</span> right = i;</span><br><span class="line">                        <span class="type">int</span> w = right - left - <span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> h = heights[mid];</span><br><span class="line">                        result = <span class="built_in">max</span>(result, w * h);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/" data-id="cm4ckzpen000b4gvqh8h134p8" data-title="单调栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/" class="article-date">
  <time class="dt-published" datetime="2024-11-25T09:06:24.000Z" itemprop="datePublished">2024-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/">动态规划-3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1<br>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这个竟然可以用动态规划解决？离谱<br>从原理上来说就是回溯问题 回溯可以修改成dp<br>我看一下标准解答<br>看了解答了 非常的劲爆<br>设定dp[i]为以[i]为结尾的最长字串个数<br>递推公式<br>if(nums[i] &gt;nums[j]){<br>    dp[i] &#x3D;max(dp[j]+1,dp[i])这里的max单纯是更新dp[i]的最大值 这外面套了两层循环<br>}<br>初始化<br>dp[0] &#x3D; 1 表示长度为1的字串<br>遍历顺序<br>都按照从头开始遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">1</span>);<span class="comment">//每个最少都是1</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();<span class="comment">//起始节点单独判断</span></span><br><span class="line">   <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">           dp[i] = <span class="built_in">max</span>(dp[j]<span class="number">+1</span>,dp[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result =<span class="built_in">max</span>(result,dp[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。<br>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>多了个连续 感觉回溯更能做了 但是会超时<br>那么继续用上面的dp？ 递推公式需要修改 数组设置倒是不需要修改<br>在递推的时候就不需要考虑在前面循环去找最大的了 只需要考虑前一个和当前这个比较大小</p>
<p>没想到贪心这么好做：比前面大 ++ 不如前面就 &#x3D;1</p>
<p>用dp做一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() ,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 连续记录</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例：</p>
<p>输入：</p>
<p>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3, 2, 1] 。<br>提示：</p>
<p>1 &lt;&#x3D; len(A), len(B) &lt;&#x3D; 1000<br>0 &lt;&#x3D; A[i], B[i] &lt; 100</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这个从解法上来说使用了dp[i][j]<br>因为不想初始化<br>就设置dp[i][j]是前一个作为结尾相等的个数<br>这样递推公式<br>dp[i][j] &#x3D; dp[i-1]dp[j-1] +1;<br>从二维数组的角度来想<br>如果dp[i][j]表示当前这个为结尾的相等个数<br>那么第一行和第一列都需要初始化才行 这样才能递推后面的<br>这样-1的情况我就全变成0 可以当作起始位置<br>遍历条件二维数组怎么遍历顺序都可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(nums<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123; <span class="comment">//主要是-1</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="number">+1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(dp[i][j],result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">变成一维数组:</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;(B.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = B.<span class="built_in">size</span>(); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> dp[j] = <span class="number">0</span>; <span class="comment">// 注意这里不相等的时候要有赋0的操作</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; result) result = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//一维数组的情况具体来说就是二维数组的变形 这么使用需要从后往前遍历防止覆盖前一个不能得到后一个  同时因为当前如果不是相等的情况那么 需要重置为0 这样让后面续不上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:</p>
<p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。<br>提示:</p>
<p>1 &lt;&#x3D; text1.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; text2.length &lt;&#x3D; 1000 输入的字符串只含有小写英文字符。</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这个看来是加了可以断连的情况<br>离谱啊离谱 太难想了离谱中的离谱<br>在判定完dp[i][j]之后（相等的情况）还要判定一下dp[i-1][j] dp[i][j-1]；<br>多了两种判定是因为原有的[i-1][j-1]判定被否决了 同时[i-2][j-2]的判定已经完成了<br>到了[i-1][j-1]这种范围限制的时候分别用[i-2][j-1]  [i-1][j-2]尝试进行看看哪一种比较大<br>适合[i-1][j-1]同时[i-2][j-1]  [i-1][j-2]的两个值在进行当前判定的时候都已经求完了 而且默认比[i-2][j-2]等于大于看能不能多捞着一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span>  </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(text<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;text<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;text<span class="number">2.</span><span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] =  dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text<span class="number">1.</span><span class="built_in">size</span>()][text<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>从题目分析这个题求得就是最长公共子序列所以代码是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()][B.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>贪心就是求和之后如果等于0直接从下一个开始<br>dp的话<br>dp[i]表示一直到i为结尾的这个连续和的最大值&#x2F;&#x2F;这样递推公式好写<br>那么dp[i]有两种选择 加入之前的和放弃之前的用现在的<br>递推公式<br>dp[i] &#x3D; max(nums[i],dp[i-1]+nums[i])<br>初始化<br>dp[0] &#x3D; nums[0]<br>遍历顺序<br>从前向后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> result = dp[<span class="number">0</span>];<span class="comment">//注意这个初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i] =<span class="built_in">max</span>(nums[i].dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        result =<span class="built_in">max</span>(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “abc”, t &#x3D; “ahbgdc”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “axc”, t &#x3D; “ahbgdc”<br>输出：false<br>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 100<br>0 &lt;&#x3D; t.length &lt;&#x3D; 10^4<br>两个字符串都只由小写字符组成</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>最简单的就是双指针解法了</p>
<p>到手里可以用回溯去处理<br>那么dp的话开始设置也是只有两种状态<br>为了递推公式好些需要想好我这个dp的定义<br>题解的递推公式表示的含义是dp[i][j]以i-1 j-1结尾的两个数组所含有的最多公共子串有多少个<br>那么递推公式就得修改了<br>在nums[i-1] &#x3D;&#x3D; nums[j-1]的时候<br>dp[i][j] &#x3D;dp[i-1][j-1]<br>在不相等的时候<br>dp[i][j] &#x3D; dp[i-1][j]  这个时候不能j-1 因为我们要求得是s是否是t的字串所以s不能节省去和t匹配 一旦节省匹配上了 那么后续可能省略s中的一个<br>但是 但是 我发现只要最后判断是否数量上相等就可以了 所以省略不省略无所谓了 所以还是上文的代码最后进行一个判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>这道题的解法就是可以有重复的 那么对于当前的dp[i][j]它的个数既可以采用当前的i-1和j-1这两个特定数对应的数量dp[i-1][j-1] 同时dp[i][j]的个数还有不采用这个当前s这个对应的数量dp[i-1][j1]<br>这样就是分成两种情况对于当前的这个t序列采用不采用当前s来进行t的匹配 把情况占满了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置dp数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">szie</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//还有第一排和第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=t.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][j.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<p>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>理论上来说可以用相同的子序列算法 之后用所有的大小减去一下 等一下试试 本身肯定不难 但是为了铺垫距离计算只能用这个特殊方法了<br>现在用正常思路的dp<br>确定dp数组（dp table）以及下标的含义<br>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。<br>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] &#x3D; dp[i - 1][j - 1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] &#x3D; min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p>
<p>因为 dp[i][j - 1] + 1 &#x3D; dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] &#x3D; min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</p>
<p>需要注意的是dp[i - 1][j - 1] + 2 相当于不考虑一个的同时还删去了另一个 相当于不考虑两个所以<br>dp[i - 1][j - 1] + 2 &#x3D;另外两种方式 + 1 所以比较大小比较两个就可以了</p>
<p>遍历公式<br>从左到右<br>从上到下</p>
<p>初始化<br>dp[0][0] &#x3D; 0;<br>dp[i][0] &#x3D; i;i-1为结尾的字符删除多少个才能是空的字符串 0到i-1一共有i个<br>dp[0][j] &#x3D; j;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>，<span class="number">0</span>))；</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>]<span class="number">+1</span>,dp[i<span class="number">-1</span>][j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符</p>
<p>删除一个字符</p>
<p>替换一个字符</p>
<p>示例 1：</p>
<p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</p>
<p>输出：3</p>
<p>解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：</p>
<p>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”</p>
<p>输出：5</p>
<p>解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’)</p>
<p>提示：</p>
<p>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500<br>word1 和 word2 由小写英文字母组成</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>顶级了属于 增删查改<br>删除和上面一样<br>dp[i][j] &#x3D; min(dp[i-1][j]+1,dp[i][j-1]+1);<br>添加<br>dp[i][j] &#x3D; min(dp[i-1][j]+1,dp[i][j-1]+1);<br>添加也是有一个不同之后按照多出来的的一个的dp基础上进行添加操作 最后比大小<br>替换<br>当前的不对应 所以替换后对应了 这是1次操作 之前的操作是dp[i-1][j-1]<br>dp[i][j] &#x3D;dp[i-1][j-1]+1 &#x2F;&#x2F;这里想了想其他操作 如果按照顺序替换逻辑来说这么写没毛病</p>
<p>当我们不管是添加还是删除操作的时候因为当前两个元素不相等 那么多出来的那一个和没多出来的那一行本身匹配的次数再加上当前没多出来的那一行未被包含的那一个被删除的次数（+1）<br>添加操作也是如此本身也搭配不上多出来的那一个 那么就用原有的上一个状态加上添加这个操作<br>删除和添加都是为了尽量匹配 为不是一下就能匹配上</p>
<p>那么替换这个操作表示的则是当前两个i和j直接进行替换就能匹配上 那么就是原有的个数+1个 要是向增加和删除学习的话无法替换了 因为那种情况你都匹配完了 不知道该替换成什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化 第一列和第一行</span></span><br><span class="line">    <span class="comment">//如果一个是空字符串的话 其他的也只能全部删除了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;)<span class="number">+1</span>;<span class="comment">//起始我理解的也是没错的 因为是求最小值所以不能省略最后一个 要是求最大值直接把最后一个删去了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>(),word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<p>输入：”abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”<br>示例 2：</p>
<p>输入：”aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”<br>提示：输入的字符串长度不会超过 1000 。</p>
<h3 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h3><p>回溯能做到分割回文子串 为此我可以最后结果存在set里面<br>暴力可以做到两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文<br>我之前回溯的时候写过判断回文子串的函数等会粘一下<br>哈哈 我构建的函数原来就是dp数组求解方式哈哈</p>
<p>这道题dp的话<br>首先构建数组dp[i][j]表示i到j这个字符串可以判定是否是回文字符串<br>递推三种情况<br>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串<br>情况二：下标i 与 j相差为1，例如aa，也是回文子串<br>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。<br>初始化<br>都为false<br>遍历顺序 一个是从+1推出来的 一个是从-1推导出来的 那么就是从下到上 从左到右</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 只包含小写英文字母</p>
<h3 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h3><p>那就dp的时候加个距离最大判断呗<br>这就错了 子序列不要求连续<br>不能连续的话dp怎么判定数组呢 设置一个dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。</p>
<p>递推公式&#x2F;&#x2F;这里递推公式也有个不同的地方在于不能同时出发了 最少差了一个的遍历环境<br>如果s[i]与s[j]相同，那么dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;<br>不相等的话应该比较一下最大值<br>加入s[j]的回文子序列长度为dp[i + 1][j]。</p>
<p>加入s[i]的回文子序列长度为dp[i][j - 1]。<br>dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</p>
<p>初始化可能有些费劲了从下到上遍历 从左到右遍历 那么就是最下面那一行和最左面那一列<br>从表格来看可以设定对角线来设置最开始的数<br>从另外一个角度考虑就是这dp数组无法得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][i] =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递推公式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =i<span class="number">+1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">+1</span>][j<span class="number">-1</span>] <span class="number">+2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="交替组2"><a href="#交替组2" class="headerlink" title="交替组2"></a>交替组2</h2><p>给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：</p>
<p>colors[i] &#x3D;&#x3D; 0 表示第 i 块瓷砖的颜色是 红色 。<br>colors[i] &#x3D;&#x3D; 1 表示第 i 块瓷砖的颜色是 蓝色 。<br>环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。</p>
<p>请你返回 交替 组的数目。</p>
<p>注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的</p>
<h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><p>之前是用的k为固定所以很好解决 但是这一次k不固定了<br>那么拼接数组或者 取余数之后滑动窗口进行判定呢？<br>10101010<br>怎么用滑动窗口判定这个窗口是否符合呢 这类似与暴力了 会超时是的<br>拼接数组加枚举右端点解决 记住枚举右侧端点 下面这代码逻辑也改不了确实就是右侧端点逻辑<br>开始用第二个数组进行罗列的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfAlternatingGroups</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; colors, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//环的问题可以用%去解决 但是数这个问题  </span></span><br><span class="line">        <span class="type">int</span> n = colors.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; colors[i % n] == colors[(i - <span class="number">1</span>) % n]) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            ans += i &gt;= n &amp;&amp; cnt &gt;= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/" data-id="cm4ckzpeh00004gvq2eed6ll8" data-title="动态规划-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2/" class="article-date">
  <time class="dt-published" datetime="2024-11-21T12:31:04.000Z" itemprop="datePublished">2024-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2/">动态规划-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]</p>
<p>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]</p>
<p>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>题目说只买卖一次<br>贪心的方法循环的时候就是找到最小的价格 同时不断记录最大区间利润</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);  <span class="comment">// 取最左最小价格</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, prices[i] - low); <span class="comment">// 直接取最大区间利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp的方法<br>我感觉主要问题还是只能买卖一次了 加上因为买卖所以状态就有了两个<br>dp[i][0]表示持有股票的时候手里的金额<br>dp[i][1]表示没持有股票的时候手里的金额<br>递推公式<br>dp[i][0] &#x3D; max(dp[i-1][0],-prices[0])<br>dp[i][1] &#x3D; max(dp[i-1][1],dp[i-1][0]+price[i])<br>初始化<br>dp[0][0] &#x3D; -price[0]<br>dp[0][1] &#x3D; 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]</p>
<p>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</p>
<p>示例 2:</p>
<p>输入: [1,2,3,4,5]</p>
<p>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3:</p>
<p>输入: [7,6,4,3,1]</p>
<p>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10 ^ 4<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10 ^ 4</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>贪心做过 这回用dp<br>设置数组和之前那一样<br>递推关系有所改变<br>dp[i][0] &#x3D; max(dp[i-1][0] ,dp[i-1][1] -price[i] )<br>dp[i][1] &#x3D;max(dp[i-1][1],dp[i-1][0] + price[i])<br>初始化<br>dp[0][0] &#x3D; -price[0]<br>dp[0][1] &#x3D; 0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(price.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] =-peices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;price.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][i] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] =<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + price[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[price.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票3"><a href="#买卖股票3" class="headerlink" title="买卖股票3"></a>买卖股票3</h3><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入：prices &#x3D; [3,3,5,0,0,3,1,4]</p>
<p>输出：6 解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3。</p>
<p>示例 2：</p>
<p>输入：prices &#x3D; [1,2,3,4,5]</p>
<p>输出：4 解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]</p>
<p>输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。</p>
<p>示例 4：</p>
<p>输入：prices &#x3D; [1] 输出：0</p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^5</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>交易次数变成了2<br>那么递推就有了限制<br>可以再列举一个空间用来 记录买卖几次？可以直接状态表示不用多余的空间</p>
<p>没有操作 （其实我们也可以不设置这个状态）<br>第一次持有股票<br>第一次不持有股票<br>第二次持有股票<br>第二次不持有股票</p>
<p>递推公式<br>达到dp[i][1]状态，有两个具体操作：</p>
<p>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i-1][0] - prices[i]<br>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]<br>那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？</p>
<p>一定是选最大的，所以 dp[i][1] &#x3D; max(dp[i-1][0] - prices[i], dp[i - 1][1]);</p>
<p>同理dp[i][2]也有两个操作：</p>
<p>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]<br>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]<br>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p>
<p>同理可推出剩下状态部分：</p>
<p>dp[i][3] &#x3D; max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</p>
<p>dp[i][4] &#x3D; max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</p>
<p>这个状态确实太恶心了<br>我重新写一遍代码尝试一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机4"><a href="#买卖股票的最佳时机4" class="headerlink" title="买卖股票的最佳时机4"></a>买卖股票的最佳时机4</h2><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1：</p>
<p>输入：k &#x3D; 2, prices &#x3D; [2,4,1]</p>
<p>输出：2 解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2。</p>
<p>示例 2：</p>
<p>输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</p>
<p>输出：7 解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p>
<p>提示：</p>
<p>0 &lt;&#x3D; k &lt;&#x3D; 100<br>0 &lt;&#x3D; prices.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 1000</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>和上一道题本质一样 但是交易次数变成了k次<br>那么就得找规律得到递推公式和初始化<br>那么奇数就是持有股票的状态<br>偶数就是没有持有股票的状态<br>递推公式<br>交易j次<br>那么总共有2<em>j +1个值可以进行操作<br>从0开始那么最大的值就是2</em>j</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; <span class="number">2</span>*j;j+=<span class="number">2</span>)&#123;</span><br><span class="line">    dp[i][j<span class="number">+1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">+1</span>],dp[i<span class="number">-1</span>][j]-prices[i]);</span><br><span class="line">    dp[i][j<span class="number">+2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">+2</span>],dp[i<span class="number">-1</span>][j<span class="number">+1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">初始化</span><br><span class="line">所有的[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">第一天的dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">那么所有偶数次都是<span class="number">0</span> 表示当天交易了多少次之后还卖了出去</span><br><span class="line">所有的奇数次都是-prices[<span class="number">0</span>] </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;<span class="number">2</span>*k;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*k,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; <span class="number">2</span>*j;j+=<span class="number">2</span>)&#123;</span><br><span class="line">    dp[i][j<span class="number">+1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">+1</span>],dp[i<span class="number">-1</span>][j]-prices[i]);</span><br><span class="line">    dp[i][j<span class="number">+2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">+2</span>],dp[i<span class="number">-1</span>][j<span class="number">+1</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; <span class="number">2</span>*j;j+=<span class="number">2</span>)&#123;</span><br><span class="line">    dp[i][j<span class="number">+1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">+1</span>],dp[i<span class="number">-1</span>][j]-prices[i]);</span><br><span class="line">    dp[i][j<span class="number">+2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">+2</span>],dp[i<span class="number">-1</span>][j<span class="number">+1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>*k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</p>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>首先不限制了买卖次数 同时加入了冷冻期<br>不限制次数这个本身可以贪心解决 也可以最简单dp<br>冷冻期这个需要在dp的时候多加入一个状态 状态机dp了<br>开始分类状态<br>状态1 持有股票<br>状态2 不持有股票<br>状态3 冷冻期<br>但是冷冻期的状态不能根据状态2推出来<br>所以状态2拆分一下<br>状态2 不持有股票而且不冷冻<br>状态4 今天卖出股票</p>
<p>这样就有了四种状态 改一下顺序顺眼<br>状态1 持有股票<br>状态2 不持有股票而且不冷冻<br>状态3 今天卖出股票<br>状态4 冷冻期<br>0 1 2 3<br>递推公式<br>dp[i][0]持有股票可以通过之前持有股票 昨天不持有股票不冷冻今天买股票 昨天是冷冻期今天买股票<br>dp[i][0] &#x3D;max(dp[i-1][0],dp[i-1][1] - prices[i],dp[i-1][3]-prices[i]);</p>
<p>dp[i][1]不持有股票而且不冷冻 ：昨天是冷冻期  昨天是不持有股票不冷冻<br>dp[i][1] &#x3D;max(dp[i-1][1],dp[i-1][3]);</p>
<p>dp[i][2]今天卖出股票： 昨天持有股票才能今天卖出股票<br>dp[i][2] &#x3D; dp[i][0] + prices[i];</p>
<p>dp[i][3]今天冷冻期：只能是昨天卖出了股票才能今天冷冻期<br>dp[i][3] &#x3D;dp[i-1][2]</p>
<p>初始化<br>从第一天dp[0]开始分类状态<br>dp[0][0] &#x3D; -peices[0];<br>dp[0][1] &#x3D; 0;<br>dp[0][2] &#x3D; 0;<br>dp[0][3] &#x3D; 0;&#x2F;&#x2F;这个初始化没有明确的含义了 只能推导默认</p>
<p>遍历顺序<br>从前向后遍历 &#x2F;&#x2F;max语法{}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  <span class="comment">// 初始化持有股票状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 持有股票：三种情况，昨天持有股票，或者昨天不持有且不冷冻今天买入，或者昨天处于冷冻期今天买入</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不持有股票且不在冷冻期：昨天不持有且不冷冻，或者昨天是冷冻期</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 今天卖出股票：昨天必须持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 今天是冷冻期：昨天必须卖出股票</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终的最大收益取决于最后一天三种不持有股票的情况中的最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(&#123;dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>], dp[n - <span class="number">1</span>][<span class="number">3</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1:</p>
<p>输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2<br>输出: 8<br>解释: 能够达到的最大利润:</p>
<p>在此处买入 prices[0] &#x3D; 1<br>在此处卖出 prices[3] &#x3D; 8<br>在此处买入 prices[4] &#x3D; 4<br>在此处卖出 prices[5] &#x3D; 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.<br>注意:</p>
<p>0 &lt; prices.length &lt;&#x3D; 50000.<br>0 &lt; prices[i] &lt; 50000.<br>0 &lt;&#x3D; fee &lt; 50000</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>和无限次买入卖出一样 但是需要在卖出的时候考虑一下手续费用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2/" data-id="cm3sa35d300056svqesl44ybo" data-title="动态规划-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 12.5px;">图论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">算法，图论</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">语法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2024/12/13/xv6/">xv6</a>
          </li>
        
          <li>
            <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
          </li>
        
          <li>
            <a href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/">杂项语法</a>
          </li>
        
          <li>
            <a href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/">图论-2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>