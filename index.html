<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hot100" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/25/hot100/" class="article-date">
  <time class="dt-published" datetime="2024-12-24T16:16:48.000Z" itemprop="datePublished">2024-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/25/hot100/">hot100</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>双向链表 + 哈希表 构建使用<br>难点在于链表操作指针赋值</p>
<pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
struct DLinkedNode&#123;
    int  key;
    int value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode():key(0),value(0),prev(nullptr),next(nullptr)&#123;&#125;;
    DLinkedNode(int _key,int _value):key(_key),value(_value),prev(nullptr),next(nullptr)&#123;&#125;;
&#125;;

class LRUCache &#123;
 private:
    std::unordered_map&lt;int,DLinkedNode*&gt; cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;
    public:
    LRUCache(int _capacity):capacity(_capacity),size(0)&#123;
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    &#125;
    int get(int key)&#123;
        if(!cache.count(key))&#123;
            return -1;
        &#125;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node-&gt;value;
    &#125;
    void moveToHead(DLinkedNode* node)&#123;//移动到头部
        removeNode(node);//删除节点
        addToHead(node);//添加到头部
    &#125;
    void removeNode(DLinkedNode* node)&#123;
        node -&gt;prev-&gt;next = node-&gt;next;;
        node-&gt;next-&gt;prev = node-&gt;prev;
    &#125;
    void  addToHead(DLinkedNode* node)&#123;//添加到头部
        node-&gt;prev = head;
        node-&gt;next = head-&gt;next;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    &#125;
    DLinkedNode* removeTail()&#123;
        DLinkedNode* node = tail-&gt;prev;
        removeNode(node);
        return node;
    &#125;
    void put(int key,int value)&#123;
        if(!cache.count(key))&#123;
            DLinkedNode* node =new DLinkedNode(key,value);
            cache[key] =node;
            addToHead(node);
            size++;
            if(size &gt; capacity)&#123;
                DLinkedNode* removed = removeTail();
                cache.erase(removed-&gt;key);//删除哈希表中对应的项
                delete removed;//删除节点
                size--;
            &#125;
     
        &#125;
        else&#123;
            DLinkedNode* node = cache[key];//获取节点
            node-&gt;value = value;//更新值
            moveToHead(node);//移动到头部
        &#125;
    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/25/hot100/" data-id="cm7zw0a0q0000t4vqf423e5pi" data-title="hot100" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hot100/" rel="tag">hot100</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2024-12-17T08:52:20.000Z" itemprop="datePublished">2024-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="字典树结构"><a href="#字典树结构" class="headerlink" title="字典树结构"></a>字典树结构</h2><pre><code class="cpp">
#include &lt;cstdio&gt; // 引入C标准输入输出库
using namespace std; // 使用标准命名空间

constexpr int N = 500010; // 定义常量N，表示数组的最大大小

char s[N]; // 定义字符数组s，用于存储输入的字符串
int n, m; // 定义整数n和m，分别用于存储字符串数量和查询次数
int ch[N][26]; // 定义二维数组ch，用于表示Trie树的子节点，ch[u][c]表示节点u的字符c的子节点
int tag[N]; // 定义数组tag，用于标记字符串的状态（未访问、已访问、重复访问等）
int tot = 1; // 定义并初始化变量tot为1，表示当前Trie树中节点的总数，根节点编号为1

int main() &#123;
  scanf(&quot;%d&quot;, &amp;n); // 从输入中读取整数n，表示要插入的字符串数量

  for (int i = 1; i &lt;= n; ++i) &#123; // 循环n次，处理每一个要插入的字符串
    scanf(&quot;%s&quot;, s + 1); // 从输入中读取一个字符串，存储在数组s的索引1开始的位置
    int u = 1; // 初始化当前节点u为根节点（编号为1）
    
    for (int j = 1; s[j]; ++j) &#123; // 遍历字符串s中的每一个字符，直到遇到字符串结束符
      int c = s[j] - &#39;a&#39;; // 将字符转换为对应的索引（&#39;a&#39;-&gt;0, &#39;b&#39;-&gt;1, ..., &#39;z&#39;-&gt;25）
      
      // 如果当前节点u的子节点中没有字符c对应的节点，则创建一个新的节点
      if (!ch[u][c]) ch[u][c] = ++tot; // 将ch[u][c]设置为新的节点编号，并递增tot
      u = ch[u][c]; // 移动到子节点u的字符c对应的节点，继续向下搜索
    &#125;
    
    tag[u] = 1; // 标记节点u为一个完整字符串的结尾，表示该字符串已经被插入
  &#125;

  scanf(&quot;%d&quot;, &amp;m); // 从输入中读取整数m，表示查询的次数

  while (m--) &#123; // 循环m次，处理每一个查询
    scanf(&quot;%s&quot;, s + 1); // 从输入中读取一个查询字符串，存储在数组s的索引1开始的位置
    int u = 1; // 初始化当前节点u为根节点（编号为1）
    
    for (int j = 1; s[j]; ++j) &#123; // 遍历查询字符串s中的每一个字符，直到遇到字符串结束符
      int c = s[j] - &#39;a&#39;; // 将字符转换为对应的索引（&#39;a&#39;-&gt;0, &#39;b&#39;-&gt;1, ..., &#39;z&#39;-&gt;25）
      u = ch[u][c]; // 移动到子节点u的字符c对应的节点
      
      if (!u) break; // 如果节点u不存在，说明该字符串不在Trie中，提前退出循环
    &#125;
    
    if (tag[u] == 1) &#123; // 如果节点u被标记为1，表示该字符串存在且尚未被访问
      tag[u] = 2; // 将节点u的标记更新为2，表示该字符串已经被访问
      puts(&quot;OK&quot;); // 输出&quot;OK&quot;表示第一次成功访问该字符串
    &#125; 
    else if (tag[u] == 2) &#123; // 如果节点u被标记为2，表示该字符串已经被访问过
      puts(&quot;REPEAT&quot;); // 输出&quot;REPEAT&quot;表示重复访问该字符串
    &#125;
    else &#123; // 如果节点u未被标记，或者u为0，表示该字符串不存在于Trie中
      puts(&quot;WRONG&quot;); // 输出&quot;WRONG&quot;表示字符串不存在或查询无效
    &#125;
  &#125;

  return 0; // 返回0，表示程序正常结束
&#125;

//正常结构体
struct trie &#123;
  int nex[100000][26], cnt; //横坐标表示数组几号 纵坐标表示英文字符多少
  bool exist[100000];  // 该结点结尾的字符串是否存在

  void insert(char *s, int l) &#123;  // 插入字符串
    int p = 0;
    for (int i = 0; i &lt; l; i++) &#123;
      int c = s[i] - &#39;a&#39;;
      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点
      p = nex[p][c];
    &#125;
    exist[p] = true;
  &#125;

  bool find(char *s, int l) &#123;  // 查找字符串
    int p = 0;
    for (int i = 0; i &lt; l; i++) &#123;
      int c = s[i] - &#39;a&#39;;
      if (!nex[p][c]) return 0;
      p = nex[p][c];
    &#125;
    return exist[p];
  &#125;
&#125;;

//用链表形式实现更好一点 容易理解：
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// 定义字典树节点结构
class TrieNode &#123;
public:
    TrieNode* children[26];  // 存储26个字母的子节点指针
    bool isEndOfWord;         // 是否是单词的结束节点

    // 构造函数，初始化节点
    TrieNode() &#123;
        for (int i = 0; i &lt; 26; ++i) &#123;
            children[i] = nullptr;  // 初始化为 nullptr，表示没有子节点
        &#125;
        isEndOfWord = false;  // 默认不是单词结束节点
    &#125;
&#125;;

// 字典树类
class Trie &#123;
public:
    TrieNode* root;  // 根节点

    // 构造函数，初始化字典树
    Trie() &#123;
        root = new TrieNode();  // 初始化根节点
    &#125;

    // 插入一个单词到字典树
    void insert(const string&amp; word) &#123;
        TrieNode* node = root;  // 从根节点开始
        for (char c : word) &#123;
            int index = c - &#39;a&#39;;  // 将字符转换为索引，&#39;a&#39; -&gt; 0, ..., &#39;z&#39; -&gt; 25
            if (node-&gt;children[index] == nullptr) &#123;
                node-&gt;children[index] = new TrieNode();  // 如果没有该字符的子节点，创建新的节点
            &#125;
            node = node-&gt;children[index];  // 向下移动到对应子节点
        &#125;
        node-&gt;isEndOfWord = true;  // 在最后一个字符的节点标记为单词结束
    &#125;

    // 查找一个单词是否在字典树中
    bool search(const string&amp; word) &#123;
        TrieNode* node = root;  // 从根节点开始
        for (char c : word) &#123;
            int index = c - &#39;a&#39;;  // 将字符转换为索引
            if (node-&gt;children[index] == nullptr) &#123;
                return false;  // 如果某个字符没有对应的子节点，返回 false
            &#125;
            node = node-&gt;children[index];  // 向下移动到对应子节点
        &#125;
        return node-&gt;isEndOfWord;  // 如果找到并且是单词结束节点，则返回 true
    &#125;

    // 查找是否有以某个前缀开始的单词
    bool startsWith(const string&amp; prefix) &#123;
        TrieNode* node = root;  // 从根节点开始
        for (char c : prefix) &#123;
            int index = c - &#39;a&#39;;  // 将字符转换为索引
            if (node-&gt;children[index] == nullptr) &#123;
                return false;  // 如果某个字符没有对应的子节点，返回 false
            &#125;
            node = node-&gt;children[index];  // 向下移动到对应子节点
        &#125;
        return true;  // 如果前缀存在，返回 true
    &#125;
&#125;;

// 主函数用于测试
int main() &#123;
    Trie trie;

    // 插入单词
    trie.insert(&quot;apple&quot;);
    trie.insert(&quot;app&quot;);
    trie.insert(&quot;banana&quot;);

    // 查找单词
    cout &lt;&lt; &quot;Search &#39;apple&#39;: &quot; &lt;&lt; trie.search(&quot;apple&quot;) &lt;&lt; endl;  // 应该输出 1 (true)
    cout &lt;&lt; &quot;Search &#39;app&#39;: &quot; &lt;&lt; trie.search(&quot;app&quot;) &lt;&lt; endl;      // 应该输出 1 (true)
    cout &lt;&lt; &quot;Search &#39;banana&#39;: &quot; &lt;&lt; trie.search(&quot;banana&quot;) &lt;&lt; endl;  // 应该输出 1 (true)
    cout &lt;&lt; &quot;Search &#39;bat&#39;: &quot; &lt;&lt; trie.search(&quot;bat&quot;) &lt;&lt; endl;      // 应该输出 0 (false)

    // 查找前缀
    cout &lt;&lt; &quot;Starts with &#39;ban&#39;: &quot; &lt;&lt; trie.startsWith(&quot;ban&quot;) &lt;&lt; endl;  // 应该输出 1 (true)
    cout &lt;&lt; &quot;Starts with &#39;bat&#39;: &quot; &lt;&lt; trie.startsWith(&quot;bat&quot;) &lt;&lt; endl;  // 应该输出 0 (false)

    return 0;
&#125;






//博客理解KMP强大 next数组 这里f数组的含义是：该最长相同前缀后缀中的前缀的结束字符的数组位置（从０开始编号
for (int i=1;i&lt;m;i++)
&#123;
    int j=F[i-1];
    while ((B[j+1]!=B[i])&amp;&amp;(j&gt;=0))
        j=F[j];
    if (B[j+1]==B[i])
        F[i]=j+1;
    else
        F[i]=-1;
&#125;
//利用next数组取匹配：
while (i&lt;n)
&#123;
    if (A[i]==B[j])
    &#123;
        i++;
        j++;
        if (j==m)
        &#123;
            printf(&quot;%d\n&quot;,i-m+1);//注意,这里输出的位置是从1开始标号的,如果你要输出从0开始标号的位置,应该是是i-m.这份代码是我做一道题时写的,那道题要求输出的字符串位置从1开始标号.感谢@Draymonder指出了这个疏漏,更多内容请看评论区
            j=F[j-1]+1;
        &#125;
    &#125;
    else
    &#123;
        if (j==0)
            i++;
        else
            j=F[j-1]+1;//j前一个数可以匹配找到之后 去看B[匹配加1]能不能匹配
    &#125;
&#125;
//AC自动机

#include &lt;bits/stdc++.h&gt;

using namespace std;

#define DEBUG (1)

#define Len(x)              sizeof(x)/sizeof(x[0]) 

/**********************************************
    aho corasick
**********************************************/
#define ALPHABET   (26)

int cnt = 0;                // debug

typedef struct _NODE
&#123;
    int name;               // debug
    vector&lt;int&gt; exist;
    _NODE *fail;
    _NODE *child[ALPHABET];
    _NODE()
    &#123;
        name = 0;           // debug
        fail = NULL;
        memset(child, NULL, ALPHABET*sizeof(_NODE *));
    &#125;
&#125;NODE;

/**********************************************
    &quot;he&quot; &quot;she&quot; &quot;hers&quot; &quot;his&quot; 
    ahishers
     his
       she
        he
        hers
**********************************************/
void print_matching_result(const char *T, int start, int len)
&#123;
    for(int i = 0; i &lt; start; i++)
        printf(&quot; &quot;);
    for(int i = 0; i &lt; len; i++)
        printf(&quot;%c&quot;,T[start+i]);
    printf(&quot;\n&quot;);
&#125;

/**********************************************
    用于debug确认构造完成的状态机的[fail指针]和[exist信息]
    bfs遍历一遍trie,按顺序给节点命名,同时输出fail指向信息
**********************************************/
void print_automaton_info(NODE *tmp)
&#123;
    printf(&quot;---------------------info----------------------\n&quot;);
    queue&lt;NODE *&gt; q;
    q.push(tmp);
    while(!q.empty())
    &#123;
        NODE *tmp = q.front(); q.pop();
        tmp-&gt;name = cnt++;
        if(tmp-&gt;fail)
            printf(&quot;%d --fail--&gt; %d, has %d word\n&quot;, tmp-&gt;name, tmp-&gt;fail-&gt;name, tmp-&gt;exist.size());
        for(int i = 0; i &lt; ALPHABET; i++)
            if(tmp-&gt;child[i])
                q.push(tmp-&gt;child[i]);
    &#125;
    printf(&quot;---------------------end----------------------\n&quot;);
&#125;

void trie_insert(NODE *root, const char *word)
&#123;
    NODE *tmp = root;

    for(int i = 0; i &lt; strlen(word); i++)
    &#123;
        int c = word[i]-&#39;a&#39;;
        if(NULL == tmp-&gt;child[c])
            tmp-&gt;child[c] = new NODE();
        tmp = tmp-&gt;child[c];
    &#125;
    tmp-&gt;exist.push_back(strlen(word));
&#125;

void ac_build(NODE *root, const char *P[], int n)
&#123;
    for(int i = 0; i &lt; n; i++)
        trie_insert(root, P[i]);
    
    queue&lt;NODE *&gt; q;
    for(int i = 0; i &lt; ALPHABET; i++)
    &#123;
        if(root-&gt;child[i])
        &#123;
            root-&gt;child[i]-&gt;fail = root;
            q.push(root-&gt;child[i]);
        &#125;
    &#125;

    while(!q.empty())
    &#123;
        NODE *x = q.front(); q.pop();
        for(int i = 0; i &lt; ALPHABET; i++)
        &#123;
            if(x-&gt;child[i])
            &#123;
                NODE *y = x-&gt;child[i], *fafail = x-&gt;fail;
                /*
                    x--fail-→fafail         x--fail-→fafail
                      ↘ⁱ             ==&gt;     ↘ⁱ        ↘ⁱ      
                        y                      y--fail--→★
                */
                while(fafail &amp;&amp; NULL == fafail-&gt;child[i])
                    fafail = fafail-&gt;fail;
                if(NULL == fafail)
                    y-&gt;fail = root;
                else
                    y-&gt;fail = fafail-&gt;child[i];

                if(y-&gt;fail-&gt;exist.size())
                    for(int j = 0; j &lt; y-&gt;fail-&gt;exist.size(); j++)
                        y-&gt;exist.push_back(y-&gt;fail-&gt;exist[j]);
                q.push(y);
            &#125;
        &#125;
    &#125;
&#125;

void ac_query(NODE *root, const char *T)
&#123;
    NODE *tmp = root;
    for(int i = 0; i &lt; strlen(T); i++)
    &#123;
        int c = T[i]-&#39;a&#39;;
        while(NULL == tmp-&gt;child[c] &amp;&amp; tmp-&gt;fail)
            tmp = tmp-&gt;fail;
        if(tmp-&gt;child[c])
            tmp = tmp-&gt;child[c];
        else
            continue;
        if(tmp-&gt;exist.size())
        &#123;
            for(int j = 0; j &lt; tmp-&gt;exist.size(); j++)
            &#123;
                int len = tmp-&gt;exist[j];
                print_matching_result(T, i-len+1, len);
            &#125;
        &#125;
    &#125;
&#125;

void aho_corasick(const char *P[], int n, const char *T)
&#123;
    printf(&quot;**********************************************\n&quot;);
    for(int i = 0; i &lt; n; i++)
        printf(&quot;\&quot;%s\&quot; &quot;, P[i]);
    printf(&quot;\n%s\n&quot;, T);

    NODE *root = new NODE();
    ac_build(root, P, n);
    ac_query(root, T);

    print_automaton_info(root);         // debug
&#125;

int main()
&#123;
    const char *P[] = &#123;&quot;he&quot;, &quot;she&quot;, &quot;hers&quot;, &quot;his&quot;, &quot;is&quot;&#125;; 
    const char *T = &quot;ahishersheishiser&quot;;

    aho_corasick(P, Len(P), T);

    return 0;
&#125;
//
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cm4tmk3y80000d8vqh51x3gug" data-title="字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-xv6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/13/xv6/" class="article-date">
  <time class="dt-published" datetime="2024-12-13T08:17:31.000Z" itemprop="datePublished">2024-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/13/xv6/">xv6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一些操作系统上的东西"><a href="#一些操作系统上的东西" class="headerlink" title="一些操作系统上的东西"></a>一些操作系统上的东西</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>mknod(“&#x2F;console”, 1, 1);<br>这行是关键。mknod 系统调用用来创建特殊文件。它接受三个参数：</p>
<p>第一个参数 &#x2F;console 是你要创建的设备文件的路径。<br>第二个参数 1 是主设备号（major device number）。<br>第三个参数 1 是次设备号（minor device number）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span>    <span class="comment">// 引入基本数据类型定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span>     <span class="comment">// 引入文件状态结构体定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span>       <span class="comment">// 引入用户空间的系统调用和函数声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span>       <span class="comment">// 引入文件系统相关结构体和常量定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个递归查找函数，接受两个参数：起始路径和目标文件名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;          <span class="comment">// buf用于构建新的路径，p是指向buf中当前操作位置的指针</span></span><br><span class="line">    <span class="type">int</span> fd;                     <span class="comment">// 文件描述符，用于打开文件或目录</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;           <span class="comment">// 目录项结构体，用于存储读取的目录项信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;             <span class="comment">// 文件状态结构体，用于存储文件的元数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试以只读方式打开指定路径</span></span><br><span class="line">    <span class="keyword">if</span>((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);  <span class="comment">// 如果打开失败，向标准错误输出错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;                                       <span class="comment">// 返回，结束当前函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取打开文件的状态信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);  <span class="comment">// 如果获取失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">close</span>(fd);                                    <span class="comment">// 关闭文件描述符，释放资源</span></span><br><span class="line">        <span class="keyword">return</span>;                                       <span class="comment">// 返回，结束当前函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据文件类型进行不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="comment">// 如果当前路径是一个文件，检查文件名是否以目标名结尾</span></span><br><span class="line">        <span class="comment">// 通过比较路径字符串的最后部分是否与目标字符串相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path + <span class="built_in">strlen</span>(path) - <span class="built_in">strlen</span>(target), target) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);  <span class="comment">// 如果匹配，打印文件的完整路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 结束当前case</span></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="comment">// 如果当前路径是一个目录，首先检查构建新路径时是否会超出缓冲区大小</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);  <span class="comment">// 如果超出，输出错误信息</span></span><br><span class="line">            <span class="keyword">break</span>;                             <span class="comment">// 结束当前case</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);          <span class="comment">// 将当前路径复制到buf中</span></span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);     <span class="comment">// 设置指针p指向buf的末尾</span></span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;                 <span class="comment">// 在buf末尾添加一个斜杠，准备拼接子目录或文件名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环读取目录中的每一个目录项</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))&#123;</span><br><span class="line">            <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 如果目录项的inode号为0，表示无效，跳过</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memmove</span>(p, de.name, DIRSIZ);  <span class="comment">// 将目录项的名称复制到buf的当前指针位置</span></span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;                <span class="comment">// 在复制的名称后添加字符串终止符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取新路径的文件状态信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);  <span class="comment">// 如果获取失败，输出错误信息</span></span><br><span class="line">                <span class="keyword">continue</span>;                                 <span class="comment">// 跳过当前目录项，继续下一个</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过当前目录和父目录，避免无限递归</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf + <span class="built_in">strlen</span>(buf) - <span class="number">2</span>, <span class="string">&quot;/.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf + <span class="built_in">strlen</span>(buf) - <span class="number">3</span>, <span class="string">&quot;/..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">find</span>(buf, target);  <span class="comment">// 递归调用find函数，继续查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 结束当前case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);  <span class="comment">// 关闭文件描述符，释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数的数量是否少于3个</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 如果参数不足，程序退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> target[<span class="number">512</span>];        <span class="comment">// 定义一个字符数组用于存储目标文件名</span></span><br><span class="line">    target[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;         <span class="comment">// 在目标文件名前添加一个斜杠</span></span><br><span class="line">    <span class="built_in">strcpy</span>(target + <span class="number">1</span>, argv[<span class="number">2</span>]);  <span class="comment">// 将命令行的第三个参数（目标文件名）复制到target中，紧跟斜杠之后</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], target);   <span class="comment">// 调用find函数，传入起始路径和目标文件名</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                 <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户空间调用内核空间程序流程"><a href="#用户空间调用内核空间程序流程" class="headerlink" title="用户空间调用内核空间程序流程"></a>用户空间调用内核空间程序流程</h2><p>用户程序<br>   |<br>   | 设置寄存器 a0, a1, a7<br>   | 执行 ecall<br>   |<br>陷阱处理程序（uservec）<br>   |<br>   | 保存用户寄存器到 Trapframe<br>   | 调用 usertrap<br>   |<br>usertrap<br>   |<br>   | 识别陷阱类型为系统调用<br>   | 调用 syscall<br>   |<br>syscall<br>   |<br>   | 从 Trapframe 获取系统调用号（a7）<br>   | 查找 syscalls[num] 调用对应函数（如 sys_exec）<br>   | 将返回值存入 Trapframe 的 a0<br>   |<br>返回用户空间</p>
<h2 id="lab-4"><a href="#lab-4" class="headerlink" title="lab 4"></a>lab 4</h2><p>首先是小端序问题<br>正常来说数字是从左到右 左边是高位 右边是低位<br>小端序是把低位存储在低位 高位存储在高位<br>大端序时把高位存储在低位 低位存储在高位上</p>
<p>对于 i &#x3D; 0x00646c72 这个 32 位数，按位分解可以写成<br>低地址 ──&gt;  0x72 (‘r’)<br>            0x6c (‘l’)<br>            0x64 (‘d’)<br>            0x00 (‘\0’)<br>高地址</p>
<ol start="2">
<li>在RISC-V指令集中，jal（Jump and Link）和jalr（Jump and Link Register）是用于实现函数调用和返回的指令。</li>
</ol>
<p>jal（Jump and Link）指令用于无条件跳转到指定的相对地址，并将下一条指令的地址保存到指定的寄存器中（通常是ra，即返回地址寄存器）。这种方式常用于函数调用。例如，如果你想调用一个函数，可以用jal ra, function_label，这里function_label是函数的标签。</p>
<p>jalr（Jump and Link Register）指令则用于无条件跳转到由寄存器加上一个常数偏移得到的地址，并将下一条指令的地址保存到指定的寄存器中。这种方式通常用于函数返回，例如jalr x0, 0(ra)，这里ra存储了返回地址。</p>
<p>总的来说，这两条指令在函数的调用和返回上扮演着关键角色，使得程序可以跳转到函数执行，执行完毕后再返回到调用点继续执行。</p>
<ol start="3">
<li><p>在 main 中 printf 的 jalr 之后，寄存器 ra 中有什么值？<br>RISC-V 的 jal &#x2F; jalr 指令会把下一条指令（return address）的地址放到寄存器 ra 中。例如，如果 main 中有：</p>
<p> jalr ra, t0</p>
</li>
</ol>
<p>  调用了 printf<br>那么执行这条指令后，ra 会保存调用 jalr 指令的下一条指令的地址（即返回地址）。用更通俗的话说，ra 中是 “调用完 printf 函数后要回来继续执行的那条指令地址”。</p>
<ol start="4">
<li>在 RISC-V 的 32 个通用寄存器中，函数调用时约定将前 8 个函数参数放在 a0 ~ a7 中（超过 8 个的参数会放在栈中）。因此：</li>
</ol>
<p>第 1 个参数：存储在 a0<br>第 2 个参数：存储在 a1<br>第 3 个参数：存储在 a2<br>依此类推，直到 a7<br>如果在 main 中的调用形如：</p>
<p>c<br>复制代码<br>printf(“%d”, 13);<br>那么：</p>
<p>“%d” 这个字符串指针会放在 a0<br>13 会放在 a1<br>因此，13 最终存放在寄存器 a1。</p>
<h2 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h2><h2 id="第五章课本"><a href="#第五章课本" class="headerlink" title="第五章课本"></a>第五章课本</h2><p>驱动程序必须处理与硬件同时发生的事件<br>这里同时的含义并不是同时进行 同时表示的是它们的交互式同步的 当请求硬盘读写操作的时候 驱动先发命令 之后等待 硬件完成之后触发中断 驱动程序需要立刻做出反应</p>
<p>驱动程序运行分为两个部分<br>第一个部分运行在进程的内核线程中&#x2F;&#x2F; </p>
<p>驱动程序实际上是操作系统的一部分，输入操作系统的一部分<br>它需要与硬件设备交互，并执行特定的系统级任务。在这些任务中，涉及到访问硬件资源和处理中断等操作，这些操作需要更高的权限，因此 驱动程序必须运行在内核空间。因此，当系统调用或者中断发生时，驱动程序就进入了内核空间。</p>
<p>进程：是操作系统中资源分配的基本单位，每个进程都有独立的虚拟地址空间、文件描述符等。进程在用户空间和内核空间都有运行的时机。</p>
<p>线程：是进程内部的执行单位，多个线程可以在同一个进程中共享资源（例如内存、文件描述符等）。每个线程有自己的执行栈和程序计数器。</p>
<p>这部分为主要部分 上半个部分的代码会请求设备进行I&#x2F;O操作 读取和写入数据 这些操作命令提供给硬件运行 之后等待硬件完成这个命令</p>
<p>第二部分就是下半部分 当上面的命令运行之后就会实行中断处理 这个中断执行后 操作系统就会调用中断处理程序执行下半部分的代码。这部分代码主要会检查哪些操作已经完成了  更新一下设备状态。 特殊的情况会唤醒等待过程中的进程</p>
<h2 id="5-1-控制台的输入"><a href="#5-1-控制台的输入" class="headerlink" title="5.1 控制台的输入"></a>5.1 控制台的输入</h2><p>控制台驱动程序 连接到XV6中的uart串口接收用户通过串口输入的字符 uart::通用串行通信硬件接口。<br>接收用户的输入  处理输入行通过回车隔离<br>这个起始不属于控制台程序的本职工作了：通过read系统调用读取标准输入：：允许用户进程在程序中读取用户的键盘输入</p>
<p>uart 硬件的内存映射<br>这个内存映射是一种硬件访问方式 允许通过常规的内存操作：loarcd 和store 与硬件是设备进行交互<br>这个交互重点是 uart硬件通过内存映射的控制寄存器来与操作系统交互<br>具体解释1<br>内存映射控制的寄存器 uart硬件通过一组控制寄存器与操作系统进行交互。每个寄存器有着自己的作用，读入输入的字符 检查输入缓存区是否为空<br>LSR寄存器 这个寄存器包含了多个标志位 其中一个标志表示的是是否又需要读取的输入字符。如果有需要的，操作系统可以通过读取RHR寄存器获取这些字符</p>
<p>总的来讲就是这个硬件与操作系统的交互所有的操作都是使用了进程之中的寄存器来进行交互的</p>
<p>FIFO被使用 作为uart硬件缓存输入字符的程序 FIFO寄存器用于暂时存储从外部设备接收得到的数据 当操作系统读取输入的时候 操作系统救赎从FIFO寄存器中获取字符。</p>
<p>需要阐明的是： 当操作系统读取输入的字符的时候实际上是RHR寄存器读取的 但是RHR本质上就是一个FIFO队列的入口。FIFO这个队列属于先进先出：Receiver Holding Register</p>
<p>[UART 硬件]<br>  ↓  外部设备（键盘）输入字符<br>  ↓  数据进入 UART 内部的 FIFO（如果启用 FIFO）<br>  ↓  FIFO 里有数据时，UART 自动把 FIFO 头部字符放到 RHR<br>  ↓  操作系统从 RHR 读取数据<br>  ↓  FIFO 头部数据被删除，FIFO 向前移动</p>
<p>严格来说，0x10000000 是物理地址，不属于普通的内核虚拟地址，但：<br>✅ 在启用了 MMU 的 xv6 内核中，它会被映射到内核态的虚拟地址（通常 1:1 映射），使得内核可以通过这个虚拟地址访问它。<br>✅ 用户态进程无法访问 0x10000000，因为 MMU 的页表不会映射这个地址到用户空间。</p>
<p>UART在操作系统的整体流程：<br>1<br>main函数里面调用 consoleinit()初始化控制台<br>硬件行为变成了接收到一个字节生成一个接收中断<br>成功发送了一个字节生成一个发送完成中断<br>中断通知内核：：有新输入可以读取 需要把输入的字符处理并且存储起来<br>上一个字节发送完毕了 可以继续发送新的字节了</p>
<p>2<br>shell进程是init进程 通过open获取控制台输入的文件描述符 之后可以用read来获取读入<br>这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd =<span class="built_in">open</span>(<span class="string">&quot;/dev/console&quot;</span>,O_REWD);</span><br><span class="line">这里使用了fd读取键盘的输入</span><br><span class="line">问题是文件描述符在哪里 但是这个他把对应的文件修改了属性 变换成了 可以读写</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(fd,buf,size)<span class="comment">//这里使用了获取的文件描述符</span></span><br><span class="line">首先使用了系统调用机制read进入系统内核</span><br><span class="line">之后进入了console.<span class="function">c</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> 的实际实现会调用 <span class="title">consoleread</span><span class="params">()</span>，路径如下：</span></span><br><span class="line"><span class="function">用户进程 shell 调用 <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">→ 进入内核，调用 <span class="title">consoleread</span><span class="params">()</span>（kernel/console.c:<span class="number">82</span>）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这个函数两个作用 一个是等待完整的输入 如果这个输入没有完整的一行 那么进入SLEEP让进程挂起等待中断 读取完整的输入</span></span><br><span class="line"><span class="function">第二个作用是拷贝输入数据到用户空间 如果存储已经他有了完整的一行输入 那么把数据复制到用户进程的缓存区并且放回</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">3</span> 在用户输入字符的时候 比如按键“a”这个时候uart会触发一个接收中断信号 </span></span><br><span class="line"><span class="function">uart触发外部中断 检测到输入了 发送中断信号给cpu 要求cou处理</span></span><br><span class="line"><span class="function">之后触发trap机制 进入了系统内核中断处理程序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">devintr() 处理外部设备中断</span></span><br><span class="line"><span class="function">在 kernel/trap.c:<span class="number">177</span>，中断处理程序 devintr() 会检查 scause 寄存器，判断中断来源：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">devintr()  // kernel/trap.c:<span class="number">177</span></span></span><br><span class="line"><span class="function">它发现 中断来源是一个外部设备，于是调用 PLIC（Platform-Level Interrupt Controller），询问 哪个设备 触发了中断：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">plic_claim();</span>  <span class="comment">// kernel/trap.c:186</span></span><br><span class="line">如果 PLIC 告诉 xv6 是 UART 触发了中断，那么 <span class="built_in">devintr</span>() 会调用：</span><br><span class="line"><span class="built_in">uartintr</span>();  <span class="comment">// kernel/uart.c:180</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 最后的函数处理uart输入</span><br><span class="line">在这个函数中uart驱动程序会通过读取RHR获取等待的输入字符</span><br><span class="line">之后把这些输入字符交给<span class="built_in">consoleintr</span>() 处理：</span><br><span class="line"></span><br><span class="line">函数负责存储输入字符到CONS.BUF中 这个是一个输入缓存区 存储用户输入的字符 直到形成一个整行</span><br><span class="line">处理特殊按键</span><br><span class="line">处理enter换行  当这个被识别到了之后 开始唤醒<span class="built_in">consoleread</span>()（kernel/console.c:<span class="number">82</span>） 这个既可</span><br><span class="line">把完整的输入存储在用户进程中</span><br><span class="line"></span><br><span class="line">最后：：返回输入数据，Shell 进程的 <span class="built_in">read</span>() 调用成功返回。</span><br><span class="line"></span><br><span class="line">完整的流程 如下：</span><br><span class="line">(<span class="number">1</span>) Shell 进程等待用户输入</span><br><span class="line">Shell 调用 <span class="built_in">read</span>(fd, buf, size)</span><br><span class="line">→ 内核调用 <span class="built_in">consoleread</span>()</span><br><span class="line">→ 如果没有输入，进程 <span class="built_in">sleep</span>()</span><br><span class="line">(<span class="number">2</span>) 用户按下键盘</span><br><span class="line">用户按下 <span class="string">&#x27;a&#x27;</span></span><br><span class="line">→ UART 硬件检测到输入</span><br><span class="line">→ UART 触发 RISC-V 外部中断</span><br><span class="line">→ 进入 xv6 的陷阱处理程序 <span class="built_in">trap</span>()</span><br><span class="line">(<span class="number">3</span>) 内核处理中断</span><br><span class="line"><span class="built_in">trap</span>() 调用 <span class="built_in">devintr</span>()</span><br><span class="line">→ 发现 UART 设备触发了中断</span><br><span class="line">→ 调用 <span class="built_in">uartintr</span>()</span><br><span class="line">→ 读取 UART 硬件的 RHR 寄存器</span><br><span class="line">→ 调用 <span class="built_in">consoleintr</span>() 处理字符</span><br><span class="line">(<span class="number">4</span>) 内核存储输入</span><br><span class="line"><span class="built_in">consoleintr</span>() 将字符存入 cons.buf</span><br><span class="line">→ 如果按下了 Enter，调用 <span class="built_in">wakeup</span>() 唤醒 <span class="built_in">read</span>() 进程</span><br><span class="line">(<span class="number">5</span>) 进程读取数据</span><br><span class="line"><span class="built_in">consoleread</span>() 复制 cons.buf 中的数据到用户进程</span><br><span class="line">→ <span class="built_in">read</span>() 调用返回，Shell 获取输入</span><br></pre></td></tr></table></figure>
<h2 id="控制台的输出"><a href="#控制台的输出" class="headerlink" title="控制台的输出"></a>控制台的输出</h2><p>1 进程调用write把数据写入控制台 控制台是由UART硬件实现的<br> write(fd, “hello”, 5);&#x2F;&#x2F;这是想要给控制台也就是uart设备写入hello<br> write 在内核中的执行流程：<br> 用户进程 write()  &#x2F;&#x2F;因为是系统调用所以也就需要使用对应内核态里面的数据<br>→ 进入内核态<br>→ 调用 consolewrite()（kernel&#x2F;console.c）<br>→ 调用 uartputc()（kernel&#x2F;uart.c:87）<br>consolewrite() 是控制台的 write() 实现，负责处理控制台的输出。<br>consolewrite() 会逐个字符调用 uartputc()，把数据传输到 UART 设备。</p>
<p>2 uartputc()把数据写入uart设别<br>采用缓冲区 uart_tx_buf 避免进程阻塞<br>由于 UART 设备传输速度较慢（可能是 115200 bps，每秒大约 11.5 KB），如果进程每次都等待 UART 发送完成，CPU 资源会被浪费。因此，xv6 采用 缓冲区（uart_tx_buf） 来 缓存待发送数据。</p>
<p>具体逻辑 uartputc<br>1调用write，之后字符进入了人进入缓冲区 然后uartputc 立即返回 不需要等待uart传输完成<br>如果uart空闲呢 那么会调用uartstart开始传输 如果缓存区满了 uartputc进程会进入sleep（）等待缓冲区有空间</p>
<p>2<br>uartstart 仅在uart设备空闲的时候启动拆散农户<br>检测uart是否正在发送过程<br>如果设备空闲 从缓存区去除一个字节并送入到uart的THR(Transmit Holding Register)<br>让uart开始发送这字节 并且返回让进程继续运行下去</p>
<p>如果 write(“hello”) 发送 “hello”：</p>
<p>uartputc(‘h’) 先把 ‘h’ 放入 uart_tx_buf，然后 uartstart() 让 UART 设备开始发送。<br>uartputc(‘e’) 只是放入 uart_tx_buf，不需要立即发送（因为 UART 仍在发送 ‘h’）。<br>进程不会等待 UART 传输，而是继续运行。</p>
<p>3 设备完成发送后触发中断<br>uart硬件会调用 uartintr<br>这个的作用在于检查是否真的完成了字节发送<br>如果缓存区还有数据 会继续调用uartstart继续发送下一个字节数据</p>
<p>UART 发送完 ‘h’，触发中断：</p>
<p>uartintr() 读取 uart_tx_buf，发现 ‘e’ 还在缓冲区。<br>uartintr() 调用 uartstart() 发送 ‘e’。<br>UART 发送完 ‘e’，再次触发中断：</p>
<p>uartintr() 发现还有 ‘l’，继续调用 uartstart() 发送 ‘l’。<br>这个过程持续，直到 uart_tx_buf 为空：</p>
<p>uartintr() 不再调用 uartstart()，UART 传输完成。</p>
<p>最后  为什么采用缓存区加中断的机制</p>
<p>这个机制是一种典型的设备I&#x2F;O并发模型 通过缓存区和中断解耦进程和设备的执行 提高性能<br>1 系统调用了write 数据进入了 缓存区 之后立即返回了 不需要等待uart硬件全都发完再进入下一个操作<br>cpu同时进行了多种操作 提高了系统的并发能力<br>2 uart通过中断驱动发送 在每一个字节发完之后 自动把缓存区中的一个数据取出 让uart继续传输<br>进程和设备可以并发执行 提高吞吐量  这个中断触发了之后响应的是硬件 但是也会进入trap环节 同时这个环节会检测寄存器看到底是什么原因引发的中断 之后就正常进行了</p>
<p>慢速设备（如 UART，网络）——进程不需要等待设备完成，避免浪费 CPU 时间。<br>需要立即响应的场景（如终端输入回显 echo）——键入的字符可以立即显示，而不影响进程执行。</p>
<p>✅ 进程调用 write()，数据进入 uart_tx_buf，然后立即返回，不等待 UART 传输完成。<br>✅ UART 设备通过 uartstart() 发送第一个字节，后续字节由 UART 触发中断后继续发送。<br>✅ UART 每发送完 1 字节，触发中断，调用 uartintr() 继续发送下一个字节，直到 uart_tx_buf 为空。<br>✅ 这种机制提高了进程和设备的并行度，避免 CPU 在 I&#x2F;O 过程中的空转，提升系统性能。</p>
<p>这就是 xv6 控制台输出的完整流程 🚀。</p>
<h2 id="控制台驱动的并发问题"><a href="#控制台驱动的并发问题" class="headerlink" title="控制台驱动的并发问题"></a>控制台驱动的并发问题</h2><p>consoleread 作用纯纯就是把uart输入到缓存区的数据转换到用户进程缓存区中<br>consoleintr 这个是每一次发一个字符就一个中断之后的处理程序 把输入存储到缓存区里面</p>
<p>处理三种并发风险<br>第一种<br>两个不同的cpu同时调用 consoleread </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU1: <span class="built_in">read</span>(fd, buf, size)   <span class="comment">// 进程 A</span></span><br><span class="line">CPU2: <span class="built_in">read</span>(fd, buf, size)   <span class="comment">// 进程 B</span></span><br></pre></td></tr></table></figure>
<p>这样就出现了两个进程同时修改cons.buf缓存区 导致无法直到具体输入了什么数<br>一个没有问题 另一个读不全了<br>所以在consolread加了一条个acquair(&amp;cons.lock)加锁 确保只有一个cpu能修改这个buf缓存区</p>
<p>第二种情况<br>在正在把缓存区数据转换到用户进程缓存区里面的时候出发了uart中断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = cons.buf[pos];</span><br><span class="line"><span class="comment">//读取了缓存区的数据呢</span></span><br><span class="line"><span class="comment">//这个时候</span></span><br><span class="line"><span class="built_in">consoleintr</span>(c)；<span class="comment">//这回有新的数据从外部进来触发中断了</span></span><br></pre></td></tr></table></figure>
<p>可能还没有准阿姨呢 BUF里面的数据已经被修改完了<br>所以在中断输入处理函数CONSOLREINTR里面也使用acquair(&amp;cons.lock)加锁 确保只有一个能修改cons.buf</p>
<p>第三种<br>在xv6的多核系统只用 中断可能不会再正在普通输入转换函数运行的cpu上触发 而是在另一个cpu上触发处理了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU1: 进程 A 运行 <span class="built_in">consoleread</span>()</span><br><span class="line">CPU2: UART 触发中断 -&gt; 执行 <span class="built_in">consoleintr</span>()</span><br></pre></td></tr></table></figure>
<p>也是同一个问题 两个进程同时对缓存区进行了修改 或者一个cpu在另一个cpu还没有转换完就去修改缓存区 这样会数据丢失<br>解决方案也是在中断输入处理函数里面加入锁 这样确保所有cpu访问这个缓存区的时候是互斥的</p>
<p>这里有一个疑问 就是中断处理程序不能假设正在运行的进程仍然是被中断的进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程 A 运行中...</span></span><br><span class="line">UART 触发中断 → 进入 <span class="built_in">trap</span>() → <span class="built_in">devintr</span>() → <span class="built_in">uartintr</span>()</span><br></pre></td></tr></table></figure>
<p>在中断处理（uartintr()）执行时，进程 A 可能已经被调度器替换为进程 B。<br>这意味着：<br>uartintr() 并不属于任何进程，它运行在 独立的内核上下文，所以 不能依赖“当前进程”。</p>
<p>正因为这样就不能使用copyout这个函数了 这个函数的作用是吧当前的内核数据拷贝到当前进程的用户空间中去<br>因为中断发生处理的过程中 这个当前正在运行的进程可能已经变了</p>
<p>为了减少这种情况出现 解决方案就是中断处理程序只做最少的工作<br>只把数据存入到缓存区 不直接对数据进行处理 同时唤醒consolerread 这个是转换到用户进程的函数<br>让他在正确的进程上下文中执行copyout()；</p>
<p>总结一下<br>✅ acquire() 保护 cons.buf 免受多 CPU 和中断的并发访问，防止数据竞争。<br>✅ UART 中断处理程序不能假设它运行在特定进程的上下文，因此不能直接调用 copyout()，只能存数据并唤醒 consoleread()。<br>✅ 采用“上半部分（进程）+ 下半部分（中断）”模型，确保数据处理在正确的进程上下文中完成。</p>
<p>触发中断时，当前进程确实会“暂停”<br>进程 A 正在运行时，UART 发送完一个字节，触发 设备中断。<br>CPU 进入 trap()，执行 uartintr() 处理 UART 设备。<br>此时，进程 A 的状态会被保存，等待 CPU 处理完中断后恢复。<br>✅ 但中断处理结束后，CPU 不一定会继续执行原来的进程<br>如果 trap() 发现进程 A 仍然可以运行（没有触发调度），它会继续执行进程 A，用户进程不会察觉到这个短暂的中断。<br>如果 trap() 发现有更高优先级的任务（比如 sleep() 触发了进程切换），那么 CPU 可能会切换到进程 B。<br>✅ 什么时候会发生进程切换？<br>进程 A 进入 sleep()（例如 write() 等待 UART 发送完成）。<br>进程 A 的时间片耗尽，trap() 发现需要 yield() 进行调度。<br>另一个进程被 wakeup() 唤醒，并且优先级更高，调度器选择它执行。</p>
<h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>定时器中断是操作系统用来保持时钟更新并实现时间片轮转调度的一种机制。它使操作系统能够定期打断当前执行的进程<br>定时触发之后操作系统可以决定是否切换到另一个进程</p>
<p>进程切换：yield调用用于进程切换，它是xv6中协作式多任务的机制之一。当操作系统检测到定时器中断时，它会通过usertrap和kerneltrap来执行yield，从而让当前进程让出CPU，允许其他进程执行。</p>
<p>同时这个定时器中断只能处在机器模式而不是管理模式下运行定时器中断在机器模式下发生，而非管理模式下（即操作系统的正常运行模式）。机器模式下代码没有虚拟内存的保护，可以直接访问硬件资源，但它通常不适合运行应用程序或操作系统的核心代码。</p>
<p>由于机器模式下无法直接执行xv6的普通内核代码，xv6必须特别处理定时器中断。当定时器中断发生时，RISC-V硬件会进入机器模式，xv6需要通过特定的代码来处理这种中断。</p>
<h2 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h2><p>虚拟内存的两个好处<br>隔离性<br>提供映射抽象 处理器和所有指令都可以使用虚拟内存</p>
<p>所以缺页就从这个映射抽象出发提供了一个新的功能<br>除了下面两个就只用静态影射了<br>trampline 使得内核可以将一个物理内存page映射到多个用户地址空间中<br>guard page 在不同空间中保护栈</p>
<p>通过缺页 内核就能更新页表的映射关系</p>
<h2 id="6-竞态锁的条件"><a href="#6-竞态锁的条件" class="headerlink" title="6 竞态锁的条件"></a>6 竞态锁的条件</h2><p>进程的并发执行：：假设有两个进程在两个不同的 CPU 上同时运行，这两个进程调用 wait 函数来释放它们的子进程内存。当子进程终止时，内核会释放与之关联的内存。<br>在每个 CPU 上，内核会调用 kfree() 函数来释放子进程占用的内存页面。</p>
<p>内存分配：：使用一个空闲页面的链表来管理内存页面。这些页面通过 kalloc() 函数分配（从空闲页面列表中取出），而通过 kfree() 函数释放（将页面添加回空闲页面列表）。<br>kalloc() 和 kfree() 都需要操作空闲页面链表。</p>
<p>并发执行？：：<br>为了提高系统的性能，我们可能希望在不同的 CPU 上同时执行 kfree() 操作，而不需要相互等待。这样做的好处是可以提高系统的吞吐量，使得多个进程能够并行释放内存。<br>然而，并行执行kfree()可能会导致问题，因为两个进程可能会同时修改共享的空闲页面链表。如果没有适当的同步机制（如锁），这种并行执行会导致数据竞争和错误。例如，一个进程可能会删除链表中的页面，而另一个进程则可能会尝试操作已经被删除的页面，从而导致内存访问错误。</p>
<p>锁的必要性：<br>为了防止这种竞态条件，锁（例如互斥锁）是必要的。当一个进程执行 kfree() 时，它需要获取锁来保证空闲页面链表的操作是互斥的。这样，另一个进程就不能在同一时间修改链表，从而避免数据损坏。<br>锁保证了在同一时刻，只有一个进程可以操作空闲页面链表，其他进程必须等待，直到锁被释放。</p>
<p>竞争的结果取决于进程在处理器运行的确切时机以及内存系统如何排序它们的内存操作，这可能会使竞争引起的错误难以复现和调试。例如，在调试push时添加printf语句可能会改变执行的时间，从而使竞争消失。</p>
<p>避免竞争的通常方法是使用锁。锁确保互斥，这样一次只有一个CPU可以执行push中敏感的代码行；这使得上述情况不可能发生。上面代码的正确上锁版本只添加了几行（用黄色突出显示）：<br>更新锁的简单代码·</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个链表元素结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">element</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;                <span class="comment">// 存储数据的字段</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">element</span> *next;    <span class="comment">// 指向链表中下一个元素的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表头指针，初始化为 NULL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">element</span> *list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个锁，用于保护对链表的访问</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lock</span> listlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 函数：将新数据添加到链表的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">element</span> *l;  <span class="comment">// 声明一个指针 l，用于指向新创建的链表元素</span></span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);  <span class="comment">// 为新节点分配内存空间，大小为 struct element 的大小</span></span><br><span class="line">    l-&gt;data = data;         <span class="comment">// 将传入的数据存入新节点的 data 字段</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;listlock);     <span class="comment">// 获取锁，确保在修改链表时没有其他线程/进程同时访问链表</span></span><br><span class="line"></span><br><span class="line">    l-&gt;next = list;         <span class="comment">// 将新节点的 next 指针指向当前的头节点（即链表的第一个元素）</span></span><br><span class="line"></span><br><span class="line">    list = l;               <span class="comment">// 将链表的头指针 list 更新为新节点，新的节点现在是链表的头</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">release</span>(&amp;listlock);     <span class="comment">// 释放锁，允许其他线程/进程访问链表</span></span><br><span class="line">&#125;</span><br><span class="line">创建了一个新的节点指向头节点之后 把这个新的节点定义为头节点 就是头插法整这么复杂</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们说锁保护数据时，我们实际上是指锁保护适用于数据的某些不变量集合<br>您可以将锁视为串行化（serializing）并发的临界区域，以便同时只有一个进程在运行这部分代码，从而维护不变量（假设临界区域设定了正确的隔离性）。您还可以将由同一锁保护的临界区域视为彼此之间的原子，即彼此之间只能看到之前临界区域的完整更改集，而永远看不到部分完成的更新</p>
<p>讨论锁本身对性能的影响<br>例如，如果两个进程并发调用 kfree()，并且在同一个资源（如链表）上使用锁，那么即使这两个进程在不同的 CPU 上运行，锁将串行化这两个调用，也就是说它们不能同时进行。这是因为在获取锁时，必须等待另一个进程释放锁，这样就无法充分利用多核 CPU 的并行计算能力。</p>
<p>锁争用发生在多个进程或线程竞争同一个锁时。如果两个进程同时请求获取相同的锁，而此时锁已经被另一个进程持有，那么这两个进程就会进入等待状态，直到锁被释放。这种情况会导致性能下降，因为进程&#x2F;线程不得不等待，而不能并行执行</p>
<p>每个CPU可能维护一个独立的空闲页面链表。这意味着，每个CPU都有自己的内存资源列表，它们可以在自己的列表中分配内存页面，而无需去访问其他CPU的资源列表。只有在某个CPU的空闲列表为空时，它才会去访问其他CPU的列表。<br>这种策略叫做CPU本地化（locality），它的目标是减少不同CPU之间的内存访问，从而减少锁争用。每个CPU自己管理自己的资源，只有在必要时才发生跨CPU的资源共享。<br>更复杂的设计：对于一些更复杂的内核，可能需要更多的优化技术。例如，使用 读写锁（read-write lock）、自旋锁（spinlock）等机制来优化锁的争用情况。<br>读写锁允许多个线程同时读取资源，但在写操作时只允许一个线程进行，避免了不必要的等待</p>
<h2 id="6-2自旋锁和睡眠锁"><a href="#6-2自旋锁和睡眠锁" class="headerlink" title="6.2自旋锁和睡眠锁"></a>6.2自旋锁和睡眠锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">    lk-&gt;locked =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个 CPU 在检查 lk-&gt;locked 时看到它是 0，然后都认为自己可以获取锁。<br>因此，它们都设置了 lk-&gt;locked &#x3D; 1，这导致 两个不同的 CPU 同时持有锁，从而破坏了互斥锁的核心属性 —— 互斥性（即同一时刻只能有一个 CPU 持有锁）。</p>
<p>在 RISC-V 架构中，提供了一个名为 amoswap 的指令，这个指令可以实现原子交换（atomic swap）。它的作用是：</p>
<p>读取内存地址 a 处的值。<br>将寄存器 r 的内容写入该内存地址。<br>将该内存地址原来的值放入寄存器 r。<br>具体来说，amoswap r, a 指令会：</p>
<p>原子地交换内存地址 a 的值和寄存器 r 的值。<br>在执行交换的过程中，硬件会防止其他 CPU 在读取和写入之间进行干扰，从而保证这个操作的原子性。</p>
<p>所以在这个操作系统在中锁的获取函数 acquir 内部包装的是原子操作，<br>具体流程如下<br>1.<br>自选也就是循环 在使用了这个函数的时候吧 会返回锁之前的赋值同时把锁的值置为1<br>2.<br>判定这个返回的值是否为1 如果返回值为 1，则说明另一个 CPU 已经持有了锁，当前 CPU 需要继续尝试获取锁。Xv6 采用自旋锁的方式，即不断重试，直到成功获取锁。<br>如果返回值为 0，意味着在交换操作之前，锁的状态是 0（未被锁定），那么当前线程成功获得了锁。<br>3.<br>获得锁以后：acquire 还会记录下锁的持有者，即记录哪个 CPU 获取了锁。这是通过修改 lk-&gt;cpu 来实现的，该字段仅在持有锁的情况下才可以被更改</p>
<p>4 对应release函数<br>release 函数用于释放锁，它的操作和 acquire 函数相反：</p>
<p>清除 lk-&gt;cpu 字段，表示锁不再被任何 CPU 持有。<br>将 lk-&gt;locked 设置为 0，表示释放锁。</p>
<p>简介<br>原子操作：为了确保互斥锁的正确性，acquire 和 release 需要使用原子操作来防止锁的争用和竞态条件。<br>硬件支持：RISC-V 提供了 amoswap 指令，帮助实现原子交换操作，以保证多核处理器下的同步。<br>自旋锁机制：acquire 使用自旋（busy-waiting）机制，反复尝试获取锁，直到成功获得锁。<br>可移植性：通过 __sync_lock_test_and_set 和 __sync_lock_release 等 C 库函数，Xv6 在不同平台上也能保证原子操作的实现。</p>
<h3 id="睡眠锁本身"><a href="#睡眠锁本身" class="headerlink" title="睡眠锁本身"></a>睡眠锁本身</h3><p>自旋锁本身会浪费cpu资源：：当锁被长时间持有时，其他进程的 CPU 时间会被浪费，因为它们在自旋等待，而不能继续执行其他任务。</p>
<p>如果为了节省资源而进行cpu让步：当锁被长时间持有时，其他进程的 CPU 时间会被浪费，因为它们在自旋等待，而不能继续执行其他任务。会出现死锁<br>自旋锁的实现通常是一个不断检查的循环（自旋）。如果进程在持有自旋锁的过程中让出了 CPU 控制权（例如通过调用 yield()），并且另一个进程试图获取相同的锁，这将导致死锁。因为 acquire（获取锁的函数）不让出 CPU，如果第二个进程在自旋时也需要获取该锁，它会阻塞第一个进程的运行，进而导致死锁。</p>
<p>定义：睡眠锁：当一个进程尝试获取睡眠锁时，如果该锁已经被其他进程持有，它会让出 CPU 并进入睡眠状态，直到锁被释放。这种方式避免了自旋锁的 CPU 浪费问题，因为等待锁的进程不会占用 CPU 资源，而是进入一个阻塞状态，允许其他进程运行。</p>
<p>尽管 睡眠锁本身 允许进程在等待时让出 CPU，但它的 内部状态 需要通过 自旋锁 来保护。这是因为：</p>
<p>并发访问问题：在多核或多线程的系统中，如果多个进程或线程同时试图修改睡眠锁的状态（例如，锁是否被持有，哪个进程正在等待锁等），就会导致 竞态条件，可能会破坏睡眠锁的正确性和一致性。<br>保证原子性：自旋锁用于确保对睡眠锁的操作是原子的。也就是说，在修改睡眠锁的内部状态时，必须确保在同一时刻只有一个进程能够进行修改操作，这样就避免了并发访问可能引发的不一致问题。</p>
<h3 id="两种锁的限制范围"><a href="#两种锁的限制范围" class="headerlink" title="两种锁的限制范围"></a>两种锁的限制范围</h3><p>睡眠锁不能在中断处理中使用：因为睡眠锁 会让出 CPU（当进程等待锁时，它会进入阻塞状态，放弃对 CPU 的控制），这会与中断处理程序的要求冲突。在中断处理中，系统需要确保快速响应外部事件，而如果中断处理程序尝试获取睡眠锁并被阻塞，它将导致系统响应延迟或不可预测的行为。因此，睡眠锁不能在中断处理程序中使用。</p>
<p>睡眠锁不能在自旋锁临界区中使用：这是因为，acquiresleep 会导致当前进程让步 CPU，当进程尝试获取睡眠锁时，它会放弃 CPU 的控制权。如果睡眠锁在自旋锁的临界区内使用，那么当进程在 acquiresleep 中等待时，它会让步 CPU，但是由于 自旋锁的临界区内不允许让步 CPU，这会导致死锁或不可预期的行为。</p>
<h2 id="6-3锁使用·条件"><a href="#6-3锁使用·条件" class="headerlink" title="6.3锁使用·条件"></a>6.3锁使用·条件</h2><p>首先，任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠。其次，请记住锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</p>
<p>为了提高效率，不要在不必要的地方加锁是非常重要的。如果没有锁的保护，多线程程序可能会出现竞态条件，导致错误；但如果锁的使用过度，可能会导致性能下降，尤其是在多核系统中，过多的锁会阻碍多个 CPU 并行执行任务。</p>
<p>大内核锁：：它的做法是在进入内核时获取一个全局的锁，并在退出内核时释放这个锁。这意味着在进入内核的过程中，所有 CPU 必须排队等候同一个锁，这样就避免了对多个内核资源的锁竞争。<br>缺点：虽然这种方式能确保内核操作的互斥性，但它牺牲了并行性。因为只要有一个 CPU 获取了锁，其他 CPU 就无法进入内核执行任务。这就导致了一个瓶颈，如果内核需要执行较为繁重的计算，那么整个系统的性能会受到极大影响，无法充分利用多核处理器的计算能力。</p>
<p>作为粗粒度锁的一个例子，xv6的kalloc.c分配器有一个由单个锁保护的空闲列表。如果不同CPU上的多个进程试图同时分配页面，每个进程在获得锁之前将必须在acquire中自旋等待。自旋会降低性能，因为它只是无用的等待。如果对锁的争夺浪费了很大一部分CPU时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，以允许真正的并行分配。</p>
<p>作为细粒度锁定的一个例子，xv6对每个文件都有一个单独的锁，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行。文件锁的粒度可以进一步细化，以允许进程同时写入同一个文件的不同区域。最终的锁粒度决策需要由性能测试和复杂性考量来驱动</p>
<h2 id="6-4死锁和锁排序"><a href="#6-4死锁和锁排序" class="headerlink" title="6.4死锁和锁排序"></a>6.4死锁和锁排序</h2><p>死锁定义：假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。假设线程T1执行代码路径1并获取锁A，线程T2执行代码路径2并获取锁B。接下来T1将尝试获取锁B，T2将尝试获取锁A。两个获取都将无限期阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。为了避免这种死锁，所有代码路径必须以相同的顺序获取锁。全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p>
<p>锁顺序链：Xv6 中的多个锁通常有一个锁顺序链，即一组锁按照特定的顺序进行获取。一个典型的锁链包括进程锁（p-&gt;lock）和其他资源的锁（如控制台锁、文件系统锁等）。<br>例如，在处理控制台输入时，consoleintr 需要获取 cons.lock，然后才能调用 wakeup 函数来唤醒等待的进程。为了避免死锁，wakeup 在唤醒进程时需要获取进程的锁，因此 consoleintr 必须先获取 cons.lock，然后再获取进程的锁。</p>
<p>为了避免死锁，Xv6 文件系统代码规定了一种严格的锁获取顺序：<br>获取目录上的锁。<br>获取新文件 inode 的锁。<br>获取磁盘块缓冲区上的锁。<br>获取磁盘驱动程序的 vdisk_lock。<br>获取进程的锁（p-&gt;lock）。</p>
<h2 id="6-5-锁的中断处理函数"><a href="#6-5-锁的中断处理函数" class="headerlink" title="6.5 锁的中断处理函数"></a>6.5 锁的中断处理函数</h2><p>在 定时器中断处理程序 clockintr 中，每次定时器中断触发时，程序都会增加 ticks 的值。这是对 ticks 的写操作。<br>内核线程 在执行 sys_sleep 系统调用时，它会读取 ticks 的值来判断进程是否应该继续睡眠，或者是否需要唤醒。这是对 ticks 的读操作。<br>由于 ticks 是一个共享变量，clockintr 和 sys_sleep 可能会同时访问它，这就会导致 数据竞争，即一个进程正在修改 ticks 的值，而另一个进程正在读取它，这可能导致不一致的数据或错误的行为。</p>
<p>为了避免这种数据竞争和确保 ticks 的一致性，Xv6 使用了 tickslock 这个自旋锁。具体地：</p>
<p>tickslock 用于保护 ticks 变量的访问，确保在任意时刻，只有一个进程或中断处理程序可以访问 ticks。<br>当 clockintr 需要更新 ticks 时，它必须先获取 tickslock，确保没有其他进程或中断同时访问或修改 ticks。<br>同样，在 sys_sleep 中，内核线程也必须获取 tickslock 才能安全地读取 ticks 变量。</p>
<p>这产生了一个问题：<br>在 sys_sleep 系统调用中，内核线程获取了 tickslock 锁，准备读取或操作 ticks 变量。<br>然后，定时器中断发生了，打断了正在运行的 sys_sleep 进程。中断处理程序 clockintr 会试图获取 tickslock，以更新 ticks 的值。<br>由于 tickslock 已经被 sys_sleep 持有，clockintr 会等待锁的释放。然而，问题出现在这里：sys_sleep 不能释放 tickslock，因为它的执行被中断了，它必须等到 clockintr 处理完毕并返回后才能继续执行。<br>这样就形成了一个死锁：sys_sleep 等待 clockintr 返回，而 clockintr 又等待 sys_sleep 释放锁。由于没有任何进程可以继续执行，系统陷入死锁</p>
<p>这里有个前提条件：当系统运行中的一个进程（例如 sys_sleep）正在执行时，硬件定时器可能会发出一个定时器中断（如 clockintr）。中断机制允许系统中断当前正在执行的代码，并立刻去执行一个特定的中断处理程序（clockintr）。这是一个异步的事件，意味着进程的执行被打断，转而执行中断处理程序。</p>
<p>解决方案<br>避免自旋锁被中断处理程序所使用的一个关键原则是：如果一个自旋锁被中断处理程序所使用，那么 CPU 必须保证在启用中断的情况下，永远不能持有该锁。这意味着，防止进程持有锁时中断发生，可以通过禁用中断来确保。<br>虽然禁用了当前 CPU 上的中断，其他 CPU 上的中断仍然可以发生，导致其他 CPU 上的中断处理程序自旋等待，但不会导致死锁。</p>
<p>多个锁的嵌套<br>嵌套临界区：当一个进程在持有锁的情况下调用其他需要获取锁的操作时，就会进入一个嵌套的临界区。例如，如果在一个临界区内再次调用 acquire 来请求同一个锁，那么就进入了一个嵌套的锁获取过程。为了避免中断干扰，我们需要精确跟踪锁的嵌套级别。<br>push_off：在获取锁时，acquire 会调用 push_off 来禁用当前 CPU 上的中断。它还会记录中断禁用的层级，以便跟踪嵌套的临界区。<br>pop_off：在释放锁时，release 会调用 pop_off 来恢复最外层临界区开始时的中断使能状态。当嵌套的临界区完成时，它会检查是否可以恢复中断。</p>
<p>顺序<br>在 acquire 函数中，必须在设置锁状态之前调用 push_off，也就是在锁的获取之前禁用中断。这样做是为了确保在锁获取过程中，中断不会打断当前进程，否则会产生一个 短暂的窗口期，在这个窗口期内，系统可能会允许中断发生，进而引发 死锁。<br>release 和 pop_off 的顺序：在 release 函数中，必须在释放锁之后调用 pop_off。这也有助于恢复最外层临界区的中断状态，确保中断状态只在没有锁被持有时才恢复。</p>
<h2 id="6-6指令和内存访问顺序"><a href="#6-6指令和内存访问顺序" class="headerlink" title="6.6指令和内存访问顺序"></a>6.6指令和内存访问顺序</h2><p>编译器和中央处理器为了获得更高的性能而不按顺序执行代码<br>编译器和CPU在重新排序时需要遵循一定规则，以确保它们不会改变正确编写的串行代码的结果。然而，规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</p>
<p>为了告诉硬件和编译器不要执行这样的重新排序，xv6在acquire(kernel&#x2F;spinlock.c:22) 和release(kernel&#x2F;spinlock.c:47)中都使用了__sync_synchronize()。__sync_synchronize()是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序load或store指令。因为xv6在访问共享数据时使用了锁，xv6的acquire和release中的障碍在几乎所有重要的情况下都会强制顺序执行。</p>
<h2 id="锁本身的开销问题："><a href="#锁本身的开销问题：" class="headerlink" title="锁本身的开销问题："></a>锁本身的开销问题：</h2><p>锁竞争的开销：在多核处理器系统中，当多个 CPU 竞争同一锁时，缓存一致性和同步机制带来的开销可能非常昂贵。<br>无锁编程的优势与挑战：无锁编程通过避免锁来提高性能，但它的实现要比有锁编程更复杂，涉及到诸如内存重新排序等问题。<br>Xv6 的选择：Xv6 避免了无锁编程的复杂性，选择了使用有锁的数据结构来简化开发，并避免了无锁编程的额外挑战。</p>
<h2 id="页表项查找好的例子"><a href="#页表项查找好的例子" class="headerlink" title="页表项查找好的例子"></a>页表项查找好的例子</h2><p>假设我们有一个 64 位虚拟地址，并且系统采用 4KB 页面大小，以及 4级页表结构（如 x86-64 架构）。在这种系统中，虚拟地址被分解为多个部分，每一部分用于查找不同层级的页表。</p>
<p>假设系统参数<br>虚拟地址长度：64 位<br>页面大小：4KB（即 PGSIZE &#x3D; 4096）<br>页表项大小：8 字节（64 位系统下通常为 8 字节）<br>虚拟地址结构：根据 x86-64 架构，64 位虚拟地址分解为以下几个部分：<br>PML4 索引：9 位<br>PDPT 索引：9 位<br>PDT 索引：9 位<br>页内偏移：12 位<br>虚拟地址结构示意图<br>PML4 索引（9 位）<br>PDPT 索引（9 位）<br>PDT 索引（9 位）<br>页内偏移（12 位）<br>因此，一个 64 位虚拟地址可以分为：</p>
<p>复制<br>| PML4 索引 (9 位) | PDPT 索引 (9 位) | PDT 索引 (9 位) | 页内偏移 (12 位) |<br>例子<br>假设我们有一个虚拟地址 0x00007FFFBF3A5000。</p>
<p>将虚拟地址转为二进制：</p>
<p>text<br>复制<br>0x00007FFFBF3A5000 &#x3D; 0000 0000 0000 0111 1111 1111 1111 1011 1111 0011 1010 0101 0000 0000<br>分解虚拟地址： 我们将地址分解成 PML4 索引、PDPT 索引、PDT 索引和页内偏移。</p>
<p>PML4 索引（第 1-9 位）：000000111 → 7<br>PDPT 索引（第 10-18 位）：111111111 → 511<br>PDT 索引（第 19-27 位）：111110011 → 497<br>页内偏移（第 28-39 位）：101000000000 → 0xA00<br>查找过程<br>查找 PML4 页表：</p>
<p>从虚拟地址的 PML4 索引部分（7）开始，查找 PML4 页表。<br>PML4 页表是一个由 512 个条目（每个 8 字节）组成的数组，因此我们会查找索引 7 对应的条目。<br>这个条目存储的值是一个物理地址，指向 PDPT（Page Directory Pointer Table） 页表。<br>例如，假设 PML4 索引 7 对应的页表项是物理地址 0x00000000001F4000，那么我们知道，PDPT 页表就存储在物理地址 0x00000000001F4000 开始的位置。</p>
<p>查找 PDPT 页表：</p>
<p>使用虚拟地址中的 PDPT 索引部分（511），查找 PDPT 页表。<br>PDPT 页表也是一个包含 512 个条目的数组（每个条目 8 字节），所以我们查找索引 511 对应的条目。<br>假设 PDPT 页表项指向物理地址 0x00000000001F8000。<br>查找 PDT 页表：</p>
<p>使用虚拟地址中的 PDT 索引部分（497），查找 PDT 页表。<br>PDT 页表的结构与 PDPT 页表类似，也是一个包含 512 个条目的数组。<br>假设 PDT 页表项指向物理地址 0x0000000000200000。<br>查找物理页框：</p>
<p>最后，使用虚拟地址中的页内偏移部分（0xA00）来定位页内的具体位置。<br>PDT 页表项指向的物理地址（0x0000000000200000）表示物理页框的基址，结合页内偏移，得到最终的物理地址。<br>物理地址 &#x3D; 0x0000000000200000 + 0xA00 &#x3D; 0x000000000020A000。</p>
<h2 id="cow-的一个记忆点"><a href="#cow-的一个记忆点" class="headerlink" title="cow 的一个记忆点"></a>cow 的一个记忆点</h2><p>COW 页面 主要用于 用户空间，而 copyin 函数是从 用户空间 读取数据到 内核空间，没有涉及写操作，所以不需要考虑 COW 页面的状态。<br>COW 只在用户空间写操作时有效，因此 copyin 只需关心从用户空间正确读取数据即可，不需要判断是否是 COW 页面或处理 COW 机制。<br>内核空间 和 用户空间 是隔离的，内核读取用户空间数据时不需要担心是否是 COW 页面。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h2 id="7-1多路复用"><a href="#7-1多路复用" class="headerlink" title="7.1多路复用"></a>7.1多路复用</h2><p>避免并发争用（锁机制）： 在多核系统中，多个CPU核心可能同时尝试在进程之间切换，因此必须采取有效的同步机制来避免争用。xv6 使用了锁来防止多个处理器同时修改进程调度的状态，确保在进程切换时，只有一个核心能够执行相关的调度操作。否则，可能会导致不一致的内存状态或调度错误，影响系统的稳定性。</p>
<p>多核系统中的进程管理： 在多核机器上，每个核心都可能在不同的进程之间切换，因此必须确保每个核心都能够准确地知道自己正在执行哪个进程。xv6 通过在每个核心上维护一个当前执行进程的指针来管理这个问题。这可以确保系统调用能够正确地影响到正在执行的进程的内核状态。</p>
<p>如果一个进程结束后直接被重启，它将无法继承之前的内存数据，因为这些数据已经在进程退出时被回收。要在进程重启时继续使用之前的数据，必须采用持久化存储（如文件或数据库）来保存重要数据，或者在系统中实现检查点恢复机制。</p>
<h2 id="7-2-线程调度-上下文切换"><a href="#7-2-线程调度-上下文切换" class="headerlink" title="7.2 线程调度-上下文切换"></a>7.2 线程调度-上下文切换</h2><p>调度程序线程并不属于被暂停的进程，它是操作系统内核的一部分，负责在进程切换时决定下一个应该运行的进程。进程和线程之间的关系是，进程包含多个线程，但调度程序线程是内核的一部分，负责进程调度的工作，而不是用户进程的线程。</p>
<p>这段话描述了从一个用户进程切换到另一个用户进程时的详细步骤，特别是涉及到的上下文切换（context switch）和用户-内核转换的过程。我们可以将其分解并简要概述为：</p>
<p>用户-内核转换： 当一个用户进程需要执行系统调用或响应硬件中断时，它会从用户模式切换到内核模式。这个过程是通过触发系统调用或中断来完成的，使得当前的用户进程进入内核执行环境。</p>
<p>上下文切换： 进程切换时需要进行上下文切换。首先，操作系统需要保存旧进程的状态（如寄存器、程序计数器等），然后恢复新进程的状态，确保进程在恢复时能够从正确的位置继续执行。</p>
<p>从旧进程到当前CPU调度程序线程的上下文切换： 这个步骤是指操作系统从一个用户进程切换到调度程序线程。调度程序负责选择下一个要执行的进程，它运行在内核模式下，处理所有的调度决策。</p>
<p>从当前CPU调度程序线程到新进程的上下文切换： 调度程序确定了下一个要执行的进程后，会进行另一次上下文切换，这次是从调度程序线程切换到新进程的内核线程，恢复新进程的状态并准备好继续执行。</p>
<p>返回到用户级进程： 最后，内核将执行权交回给新进程的用户空间，这时进程进入用户模式，并开始执行用户代码。</p>
<p>注意这里的上下文说的就是进程本身的寄存器状态（如程序计数器 PC、栈指针 SP 等）</p>
<p>尽管内核空间本身是共享的，但每个进程在执行内核代码时都会有自己的内核栈。这个栈用于存储内核级的局部变量、函数调用等信息。因此，内核栈会随着进程切换而切换，即不同进程的内核栈在内核空间中是隔离的。<br>进程切换时，内核会保存当前进程的内核栈指针、程序计数器等信息，并恢复新进程的相关信息。因此，内核栈会随着进程切换而切换，但内核代码和内核空间的其他部分是共享的。</p>
<p>每个进程在内核中有自己的进程控制块（struct proc）和上下文（struct context），这些结构体用于保存进程的状态（如寄存器、程序计数器、栈指针等）。虽然这些结构体位于内核空间，但它们是独立于其他进程的，每个进程有自己对应的 struct proc 和 struct context。</p>
<p>truct context结构体：<br>这个结构体用来保存线程的寄存器集。它通常包含程序计数器、栈指针等信息，以便在切换时保存和恢复上下文。<br>struct context结构体可能会包含进程相关的状态信息。不同的操作系统或实现可能会对这个结构体有不同的定义，但它的核心目的是保存一个线程执行所需的状态信息</p>
<p>swtch函数有两个参数：</p>
<p>struct context *old：这是一个指向当前线程上下文的指针，swtch函数会将当前线程的寄存器值（如程序计数器、栈指针等）保存在old结构体中。<br>struct context *new：这是一个指向目标线程上下文的指针，swtch函数会将目标线程的寄存器值从new结构体中加载，恢复目标线程的执行状态。</p>
<h2 id="上下文切换的两个例子"><a href="#上下文切换的两个例子" class="headerlink" title="上下文切换的两个例子"></a>上下文切换的两个例子</h2><p>第一个<br>usertrap 调用 yield：</p>
<p>在 xv6 中，进程通常在执行系统调用时会触发一个陷阱（trap）。例如，当一个进程调用 yield 函数时，它表示该进程愿意放弃CPU的使用权，将CPU的控制权交给调度程序，以便调度其他进程。usertrap 是处理系统调用的函数之一，它会调用 yield。<br>yield 调用 sched：</p>
<p>yield 是一种主动放弃 CPU 使用权的机制，它通过调用 sched 来进行进程的调度。sched 负责将当前进程的上下文保存下来，并将调度程序的上下文恢复，继续执行调度程序。<br>sched 调用 swtch：</p>
<p>swtch 是上下文切换的核心函数。它负责保存当前进程的上下文，并将 CPU 控制权转移到调度程序。具体来说，swtch 将当前进程的上下文（保存了寄存器状态等）保存在 p-&gt;context 中，然后从 cpu-&gt;scheduler 中恢复调度程序的上下文。<br>swtch 函数：</p>
<p>swtch 的作用是切换进程或线程的执行状态（即上下文切换）。它的关键操作是保存当前执行的寄存器（callee-saved registers）并恢复新进程或线程的寄存器状态。<br>保存寄存器：swtch 只保存 被调用方保存的寄存器（callee-saved registers），而不保存调用方保存的寄存器（caller-saved registers）。在需要时，调用方会在栈上保存这些寄存器的值。<br>寄存器偏移量：swtch 知道 struct context 中每个寄存器字段的偏移量，从而可以正确地保存和恢复这些寄存器的值。<br>程序计数器（PC）：swtch 不会直接保存程序计数器的值，因为程序计数器实际上是通过 ra 寄存器来实现的。<br>ra 寄存器：ra 寄存器保存的是返回地址（即调用 swtch 时的返回地址），它指向当前进程调用 swtch 的返回指令。swtch 会在执行完上下文切换后，从 ra 寄存器恢复执行。<br>恢复新进程的上下文：</p>
<p>当 swtch 函数返回时，它从新进程的上下文中恢复寄存器值（这些寄存器是在之前调用 swtch 时保存的）。具体而言，swtch 会恢复 ra 寄存器，以确保新进程能够从正确的位置继续执行。<br>这也意味着，swtch 切换到的新进程的执行会从上次它调用 swtch 的位置开始，这保证了上下文切换后的无缝过渡。</p>
<p>返回新线程的栈：注意这里的存储的ra就是表示当这个进程被恢复的时候PC计数从哪个地方开始<br>swtch 在返回时还会在新线程的栈上返回，这意味着新线程的栈指针会被恢复，执行状态能够恢复到新线程的上下文。</p>
<p>保存的是ra寄存器而不是程序寄存器 用以区别</p>
<p>第二个例子<br>切换到 ls 程序的步骤：<br>保存当前进程（cc）的上下文：</p>
<p>当前正在运行的进程是 cc，在上下文切换发生时，操作系统会保存 cc 进程的当前执行状态（即上下文）。这包括 cc 的 内核寄存器（例如栈指针、程序计数器等）和 栈指针。cc 的内核线程的上下文保存在一个 context 对象中。<br>切换到 ls 程序：</p>
<p>由于 ls 程序之前运行过，所以它的状态是 RUNABLE，意味着 ls 程序处于可执行状态，并且它之前的执行上下文已经被保存。</p>
<p>用户空间状态：</p>
<p>在 ls 程序切换时，操作系统需要恢复 ls 的用户空间状态。ls 的用户空间状态（例如栈、局部变量、程序计数器等）被保存在一个 trapframe 中。这是因为当进程从内核空间返回用户空间时，trapframe 里保存了这些信息。<br>内核线程状态：</p>
<p>ls 程序的内核线程（也就是 ls 在内核模式下的执行状态）保存了其内核寄存器（程序计数器、栈指针等）。这些寄存器状态被保存在 context 对象中，类似于 cc 进程保存状态的方式。<br>恢复 ls 程序的内核线程的上下文：</p>
<p>接下来，操作系统恢复 ls 程序的内核线程状态。具体来说，操作系统会从 ls 的 context 对象中恢复其内核寄存器（包括程序计数器、栈指针等），将这些寄存器的值加载到 CPU 中，使得 ls 程序能够继续执行。<br>继续在 ls 的内核线程栈上执行：</p>
<p>恢复内核线程的上下文后，ls 程序会继续在其内核线程的栈上运行，完成中断处理程序或系统调用。<br>恢复 ls 程序的用户空间状态：</p>
<p>在进入用户空间之前，操作系统需要恢复 ls 程序的用户空间状态。ls 程序的用户空间状态（如栈、寄存器等）已经保存在 trapframe 中。操作系统会恢复这些寄存器的值，以确保 ls 能够从它上次停止的位置恢复执行。<br>返回到用户空间：</p>
<p>最后，swtch 函数会通过 trapframe 恢复 ls 程序的程序计数器（PC）和栈指针（SP），并切换到用户模式。这样，ls 程序就能够从之前中断的地方继续执行，恢复到用户空间的状态，继续运行用户代码。<br>关键点解析<br>trapframe 和 context：</p>
<p>trapframe：用于保存用户空间的状态（如栈、程序计数器等）。它在进程从内核空间返回用户空间时非常重要。<br>context：用于保存进程的内核空间状态，包括寄存器、栈指针等。当发生上下文切换时，内核会保存和恢复这些状态。<br>进程切换时的状态恢复：</p>
<p>在进程从内核切换到用户空间时，操作系统首先恢复内核状态，然后再恢复用户状态，确保程序能够从正确的地方恢复执行。<br>context 和 trapframe 提供了进程切换时所需要的所有状态信息。<br>无缝过渡：</p>
<p>通过在 swtch 中恢复新进程的上下文（包括内核和用户空间的状态），操作系统能够确保进程在上下文切换后继续执行。无论是切换到一个新进程还是恢复一个已暂停的进程，操作系统都能够保持进程的执行流不受影响。</p>
<h2 id="调度切换和进程切换的区别"><a href="#调度切换和进程切换的区别" class="headerlink" title="调度切换和进程切换的区别"></a>调度切换和进程切换的区别</h2><p>进程的上下文和调度程序的上下文<br>进程的上下文（context）：</p>
<p>每个进程都有一个与其相关的上下文，通常由操作系统在进程切换时保存和恢复。这个上下文包含了进程在内核模式下的所有重要状态，主要包括进程的寄存器状态（如程序计数器、栈指针、通用寄存器等）。<br>进程的上下文存储在一个 context 结构体中，这个结构体会在进程切换时被保存和恢复。<br>context 的典型内容：</p>
<p>程序计数器（PC）：保存当前执行的指令地址。<br>栈指针（SP）：指向当前进程的栈。<br>其他寄存器：保存进程执行时使用的寄存器值，如 eax, ebx, ecx 等。<br>调度程序的上下文（cpu-&gt;scheduler）：</p>
<p>调度程序（scheduler）是负责调度各个进程的内核部分，它运行时也有自己的上下文。调度程序的上下文通常存储在每个 CPU 的 struct cpu 对象中的 scheduler 字段。cpu-&gt;scheduler 存储了调度程序在执行时的寄存器状态。<br>调度程序上下文：调度程序本身也会使用 context 结构体来保存其执行时的状态，但它与进程的上下文不同。调度程序的上下文通常保存在 struct cpu 的 scheduler 字段中，这样操作系统能够恢复调度程序的状态，并让其继续执行。</p>
<h2 id="7-3-代码调度"><a href="#7-3-代码调度" class="headerlink" title="7.3 代码调度"></a>7.3 代码调度</h2><p>持有 p-&gt;lock 的重要性：在进行上下文切换时，xv6 强制要求在调用 swtch 前持有进程锁 p-&gt;lock，以防止在切换过程中进程的状态（如 p-&gt;state 和 p-&gt;context）被其他 CPU 修改。这样可以确保进程切换的安全性，避免栈上的竞争。<br>为什么打破惯例：通常，获取锁的线程负责释放锁，但在上下文切换中，swtch 必须打破这一惯例，因为如果没有锁保护，其他 CPU 可能会在 swtch 切换期间操作进程的栈，导致栈冲突和系统不一致。<br>避免栈冲突：通过确保 swtch 执行期间持有锁，xv6 保证了上下文切换的过程中栈和其他进程状态的一致性，防止出现两个 CPU 在同一个栈上运行的问题。</p>
<p>打破惯例就是说<br>在上下文切换时，必须释放 p-&gt;lock，以防止死锁并确保调度程序能够运行。通过释放锁，操作系统确保了上下文切换过程中多个 CPU 不会同时在同一进程的栈上执行，从而避免栈冲突等错误。</p>
<p>在上下文切换时，进程 A 获取了锁（p-&gt;lock），并通过调用 sched 或 yield 来放弃 CPU，准备切换到调度程序。<br>但是，这时 进程 A 并不会自己释放锁。而是，调度程序负责释放锁，并且调度程序会在它完成任务后继续调度其他进程。这就是打破惯例的地方</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>调度（sched）和产量（yield）通常指代在特定工作流或计划中的安排和预计结果。<br>sched 和 yield 的区别<br>sched：通常是操作系统中的底层函数，用于执行进程调度。它会处理当前进程的状态更新、上下文保存，并通过 swtch 切换到调度程序的上下文。</p>
<p>yield：是一个高层函数，通常由进程调用，表示当前进程自愿放弃 CPU。它的目的是让进程能够主动放弃 CPU，让调度程序选择其他进程运行。yield 通过调用 sched 来完成上下文切换和调度。</p>
<p>总结<br>sched 是 进程调度的底层实现，负责进行进程的上下文切换和选择下一个进程运行。<br>yield 是 进程主动放弃 CPU 的高层接口，通过调用 sched 实现进程的调度和切换。<br>swtch 是 xv6 操作系统中的上下文切换函数，用于保存当前进程的状态并恢复新进程的状态。它是实现进程调度和任务切换的核心部分，使得操作系统能够在多个进程之间切换执行。</p>
<p>truct proc 是每个进程的 进程控制块，它存储了进程的状态、上下文、栈指针、进程锁等信息。<br>struct proc 实例存储在 进程表（ptable） 中，这是一个全局的进程数组。进程表用于管理所有进程。<br>进程的内核栈 是由操作系统为每个进程单独分配的，用来存储进程在内核模式下的临时数据。<br>进程控制块和内核栈是 分开管理的，但是进程控制块中会包含对内核栈的引用。</p>
<h2 id="初始化调度"><a href="#初始化调度" class="headerlink" title="初始化调度"></a>初始化调度</h2><p>在大多数情况下，进程通过调用 sched 来放弃 CPU，并由调度程序（scheduler）选择一个新的进程运行。然而，新进程的第一次调度 有一个特别的处理方式：<br>forkret 是一个特殊的函数，专门用于 新进程 被调度时的初始处理。它会被调用来启动新进程，并释放 进程锁（p-&gt;lock）。<br>usertrapret 是另一个可能的入口点，用于当新进程已经准备好返回用户模式时开始执行。<br>forkret 的作用：forkret 的关键作用是释放新进程的锁（p-&gt;lock），使得调度程序能够继续执行并选择合适的进程。如果不释放锁，可能会阻止其他进程的调度</p>
<p>2 调度程序的工作流程<br>调度程序的循环：scheduler 在内核模式下运行，它会不断循环查找 RUNNABLE 状态的进程。RUNNABLE 状态表示该进程准备好被调度执行。<br>选择进程：scheduler 会扫描 进程表，寻找一个 状态为 RUNNABLE 的进程，表示它可以被调度执行。一旦找到这样的进程，调度程序就会标记该进程为 RUNNING 并开始执行。<br>“一旦找到一个进程，它将设置CPU当前进程变量c-&gt;proc，将该进程标记为RUNNING，然后调用swtch开始运行它</p>
<p>3进程不变量的维护<br>xv6 中，调度程序需要确保每个进程的状态在切换期间保持一致。这些规则被称为 不变量（invariants），在上下文切换过程中，必须确保这些不变量始终成立。<br>如果一个进程正在 运行（RUNNING），并且计时器中断（如 yield）要求从该进程切换出去，那么 swtch 必须保证：<br>当前进程的寄存器状态被保存（这些寄存器的值不会丢失）。<br>c-&gt;proc 必须指向当前正在运行的进程，这样操作系统才能正确恢复该进程的上下文。<br>上面是runnning的情况 下面是runnable的情况<br>如果进程是RUNNABLE状态，空闲CPU的调度程序必须安全地运行它；这意味着p-&gt;context必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的c-&gt;proc引用进程</p>
<p>这里是锁的情况<br>在上下文切换期间，p-&gt;lock 必须保持被持有状态，直到进程的上下文切换完成。否则，进程的状态可能会发生竞争性修改，导致不一致。<br>例如，如果进程正在运行，锁不能释放，否则可能导致 调度程序无法正确调度。同样，当一个进程从 RUNNABLE 状态切换到 RUNNING 状态时，p-&gt;lock 必须在进程开始运行之前保持被持有，确保在恢复进程上下文之前，进程的状态不被干扰</p>
<p>保持锁的原因<br>yield 调用期间，锁必须保持直到调度程序通过清除 c-&gt;proc 完成切换，并恢复不变量。<br>在 scheduler 中，将 RUNNABLE 进程切换为 RUNNING 时，锁必须在切换之前保持，直到上下文完全切换并且新的进程准备好执行</p>
<h2 id="7-4-mycpu-和myproc-cpu的单核与多核"><a href="#7-4-mycpu-和myproc-cpu的单核与多核" class="headerlink" title="7.4 mycpu 和myproc cpu的单核与多核"></a>7.4 mycpu 和myproc cpu的单核与多核</h2><p>在单核系统中，操作系统通常使用一个 全局变量 来指向 当前运行的进程 的 proc 结构体。由于系统只有一个 CPU，所以当前正在运行的进程是唯一的，因此全局指针足以跟踪当前进程。<br>在多核系统中，每个 CPU 核心可能同时运行不同的进程。由于每个核心的进程可能不同，单个全局变量 就无法正确地标识每个核心上正在运行的进程。</p>
<p>xv6 为每个 CPU 核心维护一个 struct cpu 结构体。每个 struct cpu 记录了与该 CPU 核心相关的信息：<br>当前在该核心上运行的进程（如果有的话）。<br>调度线程的寄存器，用于保存当前 CPU 调度线程的状态。<br>用于 管理中断禁用的嵌套自旋锁计数，确保在内核中安全地禁用中断。</p>
<p>在多核系统中，xv6 需要通过 每个 CPU 的唯一标识符 来查找相关的 struct cpu。具体的做法是：<br>每个 CPU 都有一个唯一的 hartid（硬件线程 ID）。在 RISC-V 架构中，hartid 是由硬件提供的，它是每个 CPU 核心的唯一标识符。<br>xv6 确保每个 CPU 的 hartid 存储在该 CPU 的 tp 寄存器中。tp 寄存器是 RISC-V 架构中的一个通用寄存器，用于存储该核心的唯一 ID。<br>通过 mycpu() 函数（位于 kernel&#x2F;proc.c 中），xv6 可以根据当前 CPU 的 hartid 找到对应的 struct cpu 实例。具体做法是：<br>mycpu() 使用 tp 寄存器中的 hartid 来 索引 cpus[] 数组，cpus[] 数组存储了每个 CPU 的 struct cpu。<br>通过 tp 获取 hartid，然后使用 hartid 来查找对应的 struct cpu，从而访问该核心的信息。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>tp 寄存器 是 RISC-V 架构中用于存储每个 CPU 核心的 hartid 的寄存器。每个 CPU 核心都有一个 唯一的硬件线程 ID（hartid），它用来区分不同的 CPU 核心。</p>
<p>在 xv6 中，mstart 函数在 CPU 启动的早期阶段设置 tp 寄存器，以便为每个 CPU 核心分配唯一的 hartid。<br>这发生在系统启动时，mstart 位于 kernel&#x2F;start.c 的第 46 行，在机器模式下进行。这时，CPU 还处于 机器模式（即最低级的特权模式），所以可以直接设置 tp 寄存器。</p>
<p>在用户进程运行时，tp 寄存器的值可能会被修改。这是因为用户程序可能会修改 tp 寄存器。然而，操作系统通过 usertrapret 来处理这个问题：<br>usertrapret 在用户空间的 蹦床页面（trampoline page） 中保存了 tp 寄存器的值。<br>对此：：当程序从用户空间进入内核空间时（如发生系统调用或异常），uservec 函数会恢复 tp 寄存器的值。这个过程确保了内核能够正确获取当前 CPU 核心的 hartid。<br>编译器保证 tp 寄存器永远不会被直接使用，确保它用于保存 CPU 核心的唯一标识符，并且不会被不小心覆盖。</p>
<p>如果 RISC-V 架构直接允许 xv6 读取当前的 hartid，操作会更加简单。但由于 RISC-V 的限制，xv6 只能在 机器模式下读取 hartid，而在管理模式（如内核模式）下无法直接读取 hartid。因此，操作系统必须通过寄存器来维护 hartid，并保证其在不同操作模式下的一致性。</p>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>cpuid 和 mycpu 函数返回当前 CPU 的信息，但这些返回值是 脆弱的，可能会因为 定时器中断（timer interrupt）而失效。具体来说，当一个进程在 CPU 上运行时，计时器中断可能会导致进程 让步（yield），并且这个进程可能会被调度到另一个 CPU 核心上。<br>如果定时器中断发生，并且该进程被移到另一个 CPU 核心，之前由 cpuid 或 mycpu 返回的 struct cpu 信息将变得无效。因为返回的 CPU 信息 是针对当前运行的 CPU 的，而一旦进程迁移到其他 CPU，这些信息将不再准确。</p>
<p>重点是错误在这里：是的，正如你所理解的，如果不禁用中断，错误通常出现在你获取的 进程信息（例如 c-&gt;proc）指向了 新的进程，而不是原来你获取时的进程。这是因为在获取进程信息的过程中，系统可能发生了 上下文切换。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>为了解决这个问题，xv6 要求 禁用中断，以避免中断在返回的 struct cpu 被访问时造成问题。操作系统禁用中断，确保 当前返回的 struct cpu 信息在该进程调度期间不会发生变化。</p>
<h2 id="调度程序副本-程序只有一个"><a href="#调度程序副本-程序只有一个" class="headerlink" title="调度程序副本 程序只有一个"></a>调度程序副本 程序只有一个</h2><p>在 单核系统 中，调度程序是 全局的，只有一个调度线程，负责调度所有进程。<br>在 多核系统 中，调度程序在每个 CPU 核心上都有 独立的执行实例。每个 CPU 核心都有自己的调度线程，这些调度线程独立工作，调度本地的进程</p>
<p>调度程序的代码本身是 共享的，即所有的 CPU 核心都执行相同的调度程序代码。它并不是在每个核心上都存储一个完全独立的调度程序实例。每个核心都执行相同的调度逻辑，但调度的对象和调度的行为是基于该核心的 进程状态 来进行的。</p>
<h2 id="sleep-wakeup-睡眠与唤醒"><a href="#sleep-wakeup-睡眠与唤醒" class="headerlink" title="sleep wakeup 睡眠与唤醒"></a>sleep wakeup 睡眠与唤醒</h2><p>sleep 和 wakeup 是 xv6 中用于 条件同步 的机制，允许一个进程在等待某个事件时休眠，而另一个进程在事件发生后唤醒它。这种机制有助于进程间的协调与通信。<br>信号量（Semaphore） 是一种经典的同步工具，广泛用于生产者-消费者问题，通过维护一个计数器并提供 P 和 V 操作，来控制进程间的同步。<br>在多核系统中，信号量操作的正确性依赖于合理的同步手段，如锁机制、禁用中断等，确保多核系统中不同 CPU 上的进程能够正确协调。<br>这种 条件同步机制 是操作系统设计中非常重要的一部分，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个信号量结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;  <span class="comment">// 用一个自旋锁来保护信号量的操作，确保对信号量的访问是同步的</span></span><br><span class="line">    <span class="type">int</span> count;             <span class="comment">// 信号量的计数器，表示可用资源的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V 操作（signal），用于增加信号量，唤醒等待的进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);    <span class="comment">// 获取自旋锁，保护对信号量的操作，确保线程安全</span></span><br><span class="line">    s-&gt;count += <span class="number">1</span>;        <span class="comment">// 增加信号量的计数，表示一个资源已经被释放（可用资源数量加一）</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);    <span class="comment">// 释放自旋锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P 操作（wait），用于等待信号量，表示线程请求一个资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果信号量的计数为 0，表示没有可用资源，进入空循环等待</span></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        ;   <span class="comment">// 自旋等待，直到信号量的计数不为 0（有可用资源）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);    <span class="comment">// 获取自旋锁，进入临界区，操作信号量的计数</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;        <span class="comment">// 减少信号量的计数，表示一个资源已经被分配（可用资源数量减一）</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);    <span class="comment">// 释放自旋锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了节省cpu资源</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">wakeup</span>(s);  <span class="comment">// !pay attention</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sleep</span>(s);  <span class="comment">// !pay attention</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出现问题 如果已经睡觉了 在改变就起不来了：</span></span><br><span class="line">丢失唤醒 问题发生的原因是：当 P 操作判断信号量为零后，它进入休眠状态，并在 <span class="built_in">wakeup</span>(s) 被调用后未能正确地 检测到信号量的变化。此时，P 进程被唤醒，但是它仍然没有及时执行后续逻辑，造成它 永远等待，即便信号量已经变为非零。</span><br><span class="line">这个问题的根本原因是 P 操作中的休眠机制与 V 操作的唤醒机制并未完全同步，</span><br><span class="line">这个锁和程序一起睡着了无法被修改了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决问题</span></span><br><span class="line">引入条件锁：修改后的 sleep 接口要求调用者将条件锁（condition lock）传递给 sleep。这意味着消费者在调用 sleep 进入休眠时，必须将信号量的锁传递给 sleep，确保信号量的操作在整个过程中保持同步。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);   <span class="comment">// 获取信号量的锁，保护信号量操作的原子性</span></span><br><span class="line">    s-&gt;count += <span class="number">1</span>;        <span class="comment">// 增加信号量的计数，表示释放了一个资源</span></span><br><span class="line">    <span class="built_in">wakeup</span>(s);            <span class="comment">// 唤醒在信号量 s 上休眠的进程（如果有）</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);    <span class="comment">// 释放信号量的锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);    <span class="comment">// 获取信号量的锁，保护信号量操作的原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)  <span class="comment">// 如果信号量计数为 0，表示没有资源可用</span></span><br><span class="line">        <span class="built_in">sleep</span>(s, &amp;s-&gt;lock); <span class="comment">// 进入休眠 释放信号量锁</span></span><br><span class="line"></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;         <span class="comment">// 资源可用，减少信号量的计数，表示消费了一个资源</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);     <span class="comment">// 释放信号量的锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个函数的内部实现"><a href="#两个函数的内部实现" class="headerlink" title="两个函数的内部实现"></a>两个函数的内部实现</h2><p>sleep：将当前进程标记为 SLEEPING 状态，然后调用 sched 函数释放 CPU，等待其他进程运行。当前进程将进入睡眠状态，直到被唤醒。<br>wakeup：查找在特定等待通道（chan）上休眠的进程，并将其标记为 RUNNABLE，使其可以重新加入就绪队列，等待调度执行。</p>
<p>sleep 和 wakeup 之间存在 竞争条件，如果没有正确的同步机制，可能会导致进程在等待唤醒时错过信号或者唤醒不及时。因此，xv6 通过 锁 和 条件变量 机制来确保这两个操作正确执行。</p>
<p>sleep获得p-&gt;lock（kernel&#x2F;proc.c:559）。要进入睡眠的进程现在同时持有p-&gt;lock和lk。在调用者（示例中为P）中持有lk是必要的：它确保没有其他进程（在示例中指一个运行的V）可以启动wakeup(chan)调用。既然sleep持有p-&gt;lock，那么释放lk是安全的：其他进程可能会启动对wakeup(chan)的调用，但是wakeup将等待获取p-&gt;lock，因此将等待sleep把进程置于睡眠状态的完成，以防止wakeup错过sleep。</p>
<p>锁的获取和释放：</p>
<p>在 sleep 中，进程获取了 p-&gt;lock 和 lk，这是为了确保当前进程的状态能够在休眠时得到正确更新。这样做的目的是，确保在进程状态变为 SLEEPING 之前，没有其他进程能调用 wakeup(chan)。</p>
<p>在 wakeup 中，wakeup 在获取 p-&gt;lock 后执行，它可以安全地修改休眠进程的状态。由于 wakeup 会在进程休眠之前等待获取 p-&gt;lock，它保证了 sleep 完成并将进程标记为 SLEEPING 之前，不会错误地唤醒进程。</p>
<p>确保同步：</p>
<p>sleep 持有 p-&gt;lock 时释放其他锁（例如信号量锁 lk），而 wakeup 则通过 等待 p-&gt;lock，确保它不会错过 sleep 的休眠状态更新。因此，wakeup 在执行时不会干扰正在休眠的进程，避免了竞争条件。</p>
<p>有种例外情况<br>：如果 lk 和 p-&gt;lock 是同一个锁，在 sleep 函数中会导致死锁。避免死锁的办法是确保在调用 sleep 时，进程已经持有了 p-&gt;lock，而不需要再次获取锁。<br>在 sleep 中，进程必须保持 p-&gt;lock 直到它将自己标记为 SLEEPING，以确保 wakeup 能够正确地唤醒它。<br>如果 sleep 提前释放了 p-&gt;lock，就可能错过唤醒操作，因为 wakeup 会遍历进程表并依赖于 p-&gt;lock 来修改进程状态。</p>
<h2 id="这两个函数的锁规则"><a href="#这两个函数的锁规则" class="headerlink" title="这两个函数的锁规则"></a>这两个函数的锁规则</h2><p>进程会在休眠之前 检查条件，并在条件满足时进入睡眠。通过获取和释放锁的机制，进程 在标记为 SLEEPING 之前保持锁的持有，确保唤醒器进程（例如生产者进程）不会错过唤醒。<br>通过确保唤醒器持有锁，进程在休眠时进入睡眠通道，并且确保 wakeup 正确执行。<br>如果多个进程在同一个通道上休眠（例如多个消费者线程在等待同一个管道数据），一个 wakeup 调用会将它们都唤醒。<br>唤醒后，其中一个进程会读取管道中的数据，继续执行并获取它的锁。而其他被唤醒的进程会发现管道中没有数据，因此它们会 虚假唤醒（它们没有得到任何数据），于是它们再次进入休眠。<br>这个行为是 正常的，并且由 sleep 和 wakeup 的 循环机制 自动处理。唤醒后的进程会重新检查条件，并在条件不满足时再次调用 sleep，进入休眠状态。</p>
<h2 id="设计优势"><a href="#设计优势" class="headerlink" title="设计优势"></a>设计优势</h2><p>如果多个进程在同一个通道上休眠（例如多个消费者线程在等待同一个管道数据），一个 wakeup 调用会将它们都唤醒。<br>唤醒后，其中一个进程会读取管道中的数据，继续执行并获取它的锁。而其他被唤醒的进程会发现管道中没有数据，因此它们会 虚假唤醒（它们没有得到任何数据），于是它们再次进入休眠。<br>这个行为是 正常的，并且由 sleep 和 wakeup 的 循环机制 自动处理。唤醒后的进程会重新检查条件，并在条件不满足时再次调用 sleep，进入休眠状态。</p>
<h2 id="睡眠唤醒的管道实现"><a href="#睡眠唤醒的管道实现" class="headerlink" title="睡眠唤醒的管道实现"></a>睡眠唤醒的管道实现</h2><p>管道通过 struct pipe 来表示，其中包含几个关键字段：</p>
<p>lock：用于保护管道的访问，防止多个进程同时访问管道时发生竞争条件。<br>data：缓冲区，用于存储管道的数据，实际上是一个环形缓冲区（circular buffer）。<br>nread 和 nwrite：分别表示从管道中读取和写入的字节数。它们用于管理数据的流动和同步。</p>
<p>管道的 缓冲区是环形的，即数据写入缓冲区时，当到达缓冲区的末尾时，会重新写入到缓冲区的开始位置。这样，管道缓冲区可以充分利用空间。<br>索引是通过 nread % PIPESIZE 和 nwrite % PIPESIZE 来计算的，而不是直接使用 nread 或 nwrite。这是因为 nread 和 nwrite 只是计数器，并不代表环形缓冲区的实际索引位置。</p>
<p>管道中的 缓冲区满 的条件是 nwrite &#x3D;&#x3D; nread + PIPESIZE，这意味着生产者不能再写入更多数据，直到消费者读取一些数据</p>
<p>缓冲区为空 的条件是 nwrite &#x3D;&#x3D; nread，这意味着消费者不能再读取更多数据，直到生产者写入数据</p>
<p>管道实现生产者 消费者同步机制<br>ipewrite（生产者）<br>pipewrite 函数首先 获取管道锁，以确保对管道数据的修改是同步的。<br>然后，pipewrite 循环将数据写入管道，直到缓冲区被填满（pi-&gt;nwrite &#x3D;&#x3D; pi-&gt;nread + PIPESIZE）。<br>当缓冲区满时，pipewrite 会 调用 wakeup，唤醒可能正在等待的数据的消费者进程（piperead）。然后，pipewrite 进入休眠，等待消费者从管道中读取一些数据，这样生产者才可以继续写入。<br>睡眠机制：</p>
<p>当缓冲区满时，pipewrite 调用 sleep 进入休眠，释放 pi-&gt;lock，使得其他进程（如 piperead）可以获得锁并继续执行。<br>2. piperead（消费者）<br>piperead 在 获取管道锁 后，检查是否有数据可以读取。若管道为空（pi-&gt;nread &#x3D;&#x3D; pi-&gt;nwrite），则 调用 sleep 进入休眠，直到有数据可用。<br>当管道不为空时，piperead 会进入 for 循环，从管道中读取数据，并更新 nread。读取的数据可以被生产者再次写入。<br>唤醒生产者：读取完数据后，piperead 会 调用 wakeup，唤醒生产者进程（pipewrite），通知它可以继续写入数据。<br>睡眠机制：</p>
<p>piperead 在等待数据时调用 sleep 进入休眠，释放 pi-&gt;lock，使得生产者可以继续写入数据。<br>3. 唤醒机制<br>wakeup(p)：当一个进程调用 wakeup 时，它会唤醒在特定条件上休眠的进程。在管道的实现中，pipewrite 和 piperead 使用不同的休眠通道来避免互相干扰。生产者和消费者通过 wakeup 和 sleep 机制协调：<br>当缓冲区满时，生产者通过 wakeup 唤醒消费者，消费者读取数据后，生产者可以继续写入数据。<br>当缓冲区为空时，消费者通过 wakeup 唤醒生产者，生产者写入数据后，消费者可以继续读取数据。</p>
<h2 id="设计优势-1"><a href="#设计优势-1" class="headerlink" title="设计优势"></a>设计优势</h2><p>通过 sleep 和 wakeup 实现同步：</p>
<p>管道利用 sleep 和 wakeup 实现了 生产者-消费者同步，避免了繁忙等待（busy-waiting）和死锁。进程会在条件不满足时进入休眠，并在条件满足时唤醒。<br>分离的通道：</p>
<p>管道使用 不同的睡眠通道 来区分生产者和消费者，避免了它们之间的干扰。在一个通道上休眠的进程只会在该通道的条件满足时被唤醒，这提高了效率并减少了不必要的唤醒。<br>虚假唤醒的容忍：</p>
<p>由于条件检查是在循环中进行的，虚假唤醒不会导致程序错误。每次被唤醒的进程都会重新检查条件，确保它们只有在条件真正满足时才继续执行。</p>
<h2 id="wait-exit-kill"><a href="#wait-exit-kill" class="headerlink" title="wait exit kill"></a>wait exit kill</h2><p>exit 和 wait 之间的竞争：</p>
<p>父子进程之间的 wait 和 exit 调用可能会导致竞争条件和死锁，尤其是在多核系统中。<br>xv6 通过在 wait 中使用进程锁和条件锁（sleep 和 wakeup）来确保父进程能够安全地等待子进程退出，并避免死锁。<br>wait 中的锁管理：</p>
<p>父进程在获取其自身的进程锁（p-&gt;lock）后，通过检查子进程状态来决定是否需要进入休眠。如果没有子进程退出，父进程会进入休眠，直到一个子进程退出。<br>无锁检查 np-&gt;parent：</p>
<p>np-&gt;parent 是父进程的指针，在 wait 中用于查找子进程。由于只有父进程可以修改这个字段，所以在特定情况下，wait 可以安全地 无锁检查 np-&gt;parent。</p>
<h3 id="无锁检查"><a href="#无锁检查" class="headerlink" title="无锁检查"></a>无锁检查</h3><p>wait 在扫描进程表时，需要查看每个进程的 parent 字段，以便找到其子进程。<br>通常来说，共享变量（如 np-&gt;parent）应该由锁保护。然而，np-&gt;parent 在 xv6 中是 由父进程更改的，因此只有父进程能够修改 parent 字段，其他进程不能更改它。因此，在某些情况下，wait 可以 无锁检查 np-&gt;parent。<br>无锁检查的安全性：如果 np-&gt;parent 指向当前进程（p），那么它的值就不会被其他进程修改，除非当前进程自己更改它。因此，在这种情况下，无锁访问是安全的。</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>exit 系统调用用于让进程退出时执行一些必要的清理工作，包括：<br>记录退出状态码。<br>释放进程占用的资源。<br>将进程的子进程交给 init 进程（如果父进程不再存在）。<br>如果父进程在 wait 状态中，它会被唤醒，以便它可以清理子进程（从僵尸进程转为 UNUSED 状态）。<br>将退出的进程标记为 僵尸进程（ZOMBIE），并永久地让出 CPU。<br>当进程调用 exit 时，它并不是立刻完全消失，而是进入 ZOMBIE 状态，保留一些信息（如退出状态码），直到父进程调用 wait 来清理它。<br>在 ZOMBIE 状态下，进程的资源没有完全释放，它会保持存在，直到父进程通过 wait 处理它。</p>
<p>wait 调用：父进程调用 wait 等待子进程退出。如果子进程已退出，它会清理资源并返回子进程的退出状态。如果没有子进程退出，父进程会进入休眠，直到子进程退出。<br>锁的管理：exit 和 wait 必须遵循 相同的锁获取顺序 来避免死锁。父进程的锁和子进程的锁需要按照正确的顺序获取。<br>唤醒机制：通过 wakeup1 函数，exit 在将进程标记为 ZOMBIE 之前唤醒父进程，确保父进程能够在子进程退出时被唤醒并进行清理。</p>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>exit：</p>
<p>允许一个进程自己终止。当进程调用 exit 时，它会释放所有资源，将自己标记为 ZOMBIE 状态，并最终由父进程通过 wait 进行清理。<br>kill：</p>
<p>允许一个进程请求 终止 另一个进程。与 exit 不同，kill 使得一个进程能够请求其他进程终止。直接销毁进程的实现是复杂且风险较大的，特别是当进程正在做敏感操作时，例如在更新内核数据结构的过程中。<br>因此，kill 只会设置受害进程的 p-&gt;killed 标志，并在受害进程正在休眠时唤醒它。</p>
<p>kill 设置 p-&gt;killed：</p>
<p>kill 调用通过设置目标进程（受害进程）结构体中的 p-&gt;killed 标志来标记该进程需要被终止。<br>如果受害进程正在 休眠，kill 会调用 wakeup 唤醒受害进程。受害进程会在进入或离开内核时检查是否设置了 p-&gt;killed，如果是，它会调用 exit 来终止自己。<br>受害进程的行为：</p>
<p>如果受害进程处于用户空间，它很可能会在 系统调用 或 中断（例如定时器中断）时进入内核。当它进入内核时，usertrap 会检查 p-&gt;killed 标志，如果设置了该标志，进程将调用 exit 终止自己。<br>kill 并不立即终止受害进程，而是等待受害进程在某个时刻进入内核并检查 p-&gt;killed 标志。只有当进程进入内核时（例如通过系统调用或中断），它才会检查 p-&gt;killed，并决定是否终止自己。</p>
<h3 id="例-子"><a href="#例-子" class="headerlink" title="例 子"></a>例 子</h3><p>例如，在 virtio 驱动程序 中，进程可能在进行磁盘 I&#x2F;O 操作时被杀死。在这种情况下，磁盘操作是一个 原子操作，它可能需要一组 写入操作 来确保文件系统的正确状态。因此，尽管进程可能被标记为 killed，它会在磁盘 I&#x2F;O 操作完成后再进行检查，只有在完成操作后，它才会真正退出。<br>这意味着，尽管进程可能已经设置了 p-&gt;killed，但是它不会立刻退出，而是等到当前的系统调用（例如磁盘 I&#x2F;O）完成后，再由 usertrap 检查 p-&gt;killed 并最终终止进程。</p>
<h2 id="真实应用"><a href="#真实应用" class="headerlink" title="真实应用"></a>真实应用</h2><p>xv6本身用到的是轮询 一次运行每个进程<br>先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
<p>在早期的实现中（如 Unix 和某些早期操作系统中），wakeup 函数需要扫描整个进程表，查找所有等待特定通道（chan）的进程。这个过程的时间复杂度较高，尤其是在进程数量增多时，扫描整个进程表会导致 性能瓶颈。<br>一个更好的解决方案是 使用数据结构 来替代 chan，该数据结构维护了在上面等待的所有进程列表。例如，现代操作系统（如 Linux）使用 等待队列（Wait Queue） 来高效地管理这些等待的进程。<br>Plan 9 操作系统使用 rendezvous point（集结点），它是一种同步机制，用来替代传统的 chan，并使得进程能高效地等待和唤醒。<br>在许多现代 线程库 中，类似的机制被称为 条件变量（Condition Variables），它们用于在多线程编程中协调线程的同步。<br>在这种机制下，sleep 被称为 wait，wakeup 被称为 signal 或 broadcast，</p>
<h3 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h3><p>在多进程或多线程环境中，当一个进程（或线程）在等待某个条件时被唤醒，wakeup 操作会唤醒所有在该条件下等待的进程或线程。如果条件已经满足，所有被唤醒的进程会 争先恐后 地执行，导致 大量进程 无效地检查条件，浪费 CPU 资源。<br>这种现象叫做 惊群效应（Thundering Herd Effect）。它的典型表现是多个进程或线程都竞争同一资源，但只有一个能获得资源，其他进程可能会再次进入 等待状态。<br>了避免惊群效应，现代的条件变量和进程同步机制通常提供两种唤醒操作：<br>signal：唤醒一个等待中的进程或线程。<br>broadcast：唤醒所有等待的进程或线程。<br>这里说一下定义<br> xv6 和大多数操作系统中，进程表通常是一个 数组 或 链表，每个 数组元素 或 链表节点 都表示一个 进程控制块（PCB，Process Control Block）。进程控制块包含了一个进程的关键状态信息，内核通过访问这个信息来管理和调度进程。</p>
<p>进程表的结构：<br>每个进程控制块（PCB）包含的内容：</p>
<p>进程的状态：如 RUNNING（运行中）、SLEEPING（睡眠中）、ZOMBIE（僵尸状态）等。<br>进程 ID（PID）：每个进程都有一个唯一的标识符。<br>父进程 ID：每个进程通常有一个父进程，记录父进程的 ID。<br>调度信息：如程序计数器（PC）、堆栈指针、寄存器的保存值等。<br>内存管理信息：如进程的页表、段表、堆栈和堆内存的基址等。<br>进程的资源信息：如文件描述符、打开的文件等。<br>同步信息：如与其他进程同步的条件变量、锁等。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量（Semaphore）通常用于 同步，它通过 计数 来控制进程之间的访问，确保不会发生竞争条件。信号量中的 count 通常表示某种资源的 数量，例如：</p>
<p>管道缓冲区中可用的字节数，或者<br>进程拥有的僵尸子进程数。<br>信号量的作用：<br>显式计数：使用显式的计数来表示等待的资源或条件，可以避免 “丢失唤醒” 问题。也就是说，计数会帮助追踪已经发生的 wakeup 次数，确保每个进程都被唤醒。<br>避免虚假唤醒和惊群效应：显式计数还可以有效避免虚假唤醒（即进程被唤醒后检查条件仍不满足）和 惊群效应（Thundering Herd Effect）（即大量进程被唤醒后竞相检查同一个条件的情况）。</p>
<h2 id="延迟死亡"><a href="#延迟死亡" class="headerlink" title="延迟死亡"></a>延迟死亡</h2><p>如果一个进程正在 sleep 循环中等待某个条件（例如等待磁盘 I&#x2F;O 或用户输入），而 kill 在这期间设置了 p-&gt;killed，则 sleep 循环 可能无法及时检查到这个标志。<br>kill 可能会在受害进程的 sleep 循环检查 p-&gt;killed 之后，但在调用 sleep 之前，试图 唤醒受害进程。在这种情况下，受害进程可能不会立刻注意到 p-&gt;killed 标志，直到它等待的条件（如磁盘块返回或控制台输入）发生。<br>如果在进程检查 p-&gt;killed 标志之后，kill 已经设置了 p-&gt;killed 标志并唤醒了它，那么接下来执行的 sleep 操作会使进程进入 阻塞状态，无法立即进入内核。<br>进程无法在 usertrap 中退出，因为 sleep 阻塞了它的执行，进程只有在所需的事件（如磁盘 I&#x2F;O 完成、用户输入等）再次发生时，才会被唤醒并检查 p-&gt;killed 标志，进而决定是否退出。<br>xv6 的设计避免了复杂的 信号机制，因此没有像 Unix 那样的 EINTR（中断错误） 错误。当进程在 sleep 中被 杀死（kill） 时，xv6 不会像 Unix 一样通过 signal 中断系统调用，而是简单地通过检查 p-&gt;killed 标志来决定是否退出。<br>由于 xv6 不支持信号，很多因信号导致的复杂性（例如在等待输入时受害进程被杀死）在 xv6 中并不会发生。</p>
<h2 id="XV6进程管理"><a href="#XV6进程管理" class="headerlink" title="XV6进程管理"></a>XV6进程管理</h2><p>在 xv6 中，proc 结构体（即进程控制块）的分配方式是 线性扫描，这意味着每次分配新的进程时，xv6 会遍历整个进程表来找到空闲的 proc 结构体。</p>
<p>线性扫描：xv6 使用简单的线性扫描来查找空闲的进程结构体（proc），这种实现方式虽然简单，但在处理大量进程时效率较低。<br>实际操作系统的优化：在实际的操作系统中，通常会使用 空闲列表（Free List） 或其他数据结构来高效地管理和分配进程控制块。这样，操作系统能够在 常数时间 内找到空闲的 proc 结构体，而不是每次都进行线性搜索</p>
<h2 id="第7个lab"><a href="#第7个lab" class="headerlink" title="第7个lab"></a>第7个lab</h2><h2 id="8文件"><a href="#8文件" class="headerlink" title="8文件"></a>8文件</h2><h2 id="8-1文件概述"><a href="#8-1文件概述" class="headerlink" title="8.1文件概述"></a>8.1文件概述</h2><p>文件描述符（File descriptor）<br>路径名（Pathname）<br>目录（Directory）<br>索引结点（Inode）<br>日志（Logging）<br>缓冲区高速缓存（Buffer cache）<br>磁盘（Disk）</p>
<p>磁盘层读取和写入virtio硬盘上的块。缓冲区高速缓存层缓存磁盘块并同步对它们的访问，确保每次只有一个内核进程可以修改存储在任何特定块中的数据。日志记录层允许更高层在一次事务（transaction）中将更新包装到多个块，并确保在遇到崩溃时自动更新这些块（即，所有块都已更新或无更新）。索引结点层提供单独的文件，每个文件表示为一个索引结点，其中包含唯一的索引号（i-number）和一些保存文件数据的块。目录层将每个目录实现为一种特殊的索引结点，其内容是一系列目录项，每个目录项包含一个文件名和索引号。路径名层提供了分层路径名，如&#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c，并通过递归查找来解析它们。文件描述符层使用文件系统接口抽象了许多Unix资源（例如，管道、设备、文件等）</p>
<h2 id="8-2-Buffer-cache层"><a href="#8-2-Buffer-cache层" class="headerlink" title="8.2 Buffer cache层"></a>8.2 Buffer cache层</h2><p>确保每个磁盘块在内存中只有一个副本，并且 一次只有一个内核线程使用该副本。这就意味着对于同一个磁盘块，缓存中只有一个副本，并且每次只有一个线程可以访问该副本，从而避免了并发访问时的数据冲突问题。<br>缓存常用块：<br>为了提高磁盘访问的效率，缓存常用的磁盘块，避免每次需要从较慢的磁盘重新读取相同的数据。磁盘的访问速度远低于内存，所以通过缓存一些常用的磁盘块，可以显著减少磁盘的读写次数，提高整体性能。</p>
<p>bread：用于从缓存中获取一个缓冲区，其中包含磁盘块的副本，供线程进行读取或修改。这会锁住该缓冲区，确保没有其他线程同时访问同一个缓冲区。<br>bread 调用 bget 来查找和返回缓冲区。如果缓冲区尚未加载，bread 会触发 磁盘读取，即调用 virtio_disk_rw（kernel&#x2F;bio.c）来从磁盘中读取数据。<br>bget：<br>bget 函数（kernel&#x2F;bio.c:59）负责从缓存中查找是否已有一个缓冲区对应某个特定的设备和扇区号（通过设备和扇区号来定位）。具体的操作步骤如下：</p>
<p>扫描缓冲区链表：<br>bget 扫描当前的缓冲区链表，检查是否存在与目标设备和扇区号匹配的缓冲区（通过 b-&gt;device 和 b-&gt;sector 字段）。</p>
<p>已有缓冲区：<br>如果发现已有相同设备和扇区号的缓冲区，bget 会获取该缓冲区的睡眠锁（确保线程安全），然后返回这个缓冲区。</p>
<p>没有匹配的缓冲区：<br>如果找不到对应的缓冲区，bget 需要创建一个新的缓冲区：</p>
<p>bget 会扫描链表，查找 未在使用中的缓冲区，即那些 b-&gt;refcnt &#x3D; 0 的缓冲区。这些缓冲区没有被引用，可以被重新利用。<br>一旦找到可用的缓冲区，bget 会修改缓冲区的元数据，记录新的设备和扇区号。<br>最后，bget 获取该缓冲区的睡眠锁，并将 valid 字段设置为 0，这样可以确保下次调用 bread 时会从磁盘读取数据，而不是使用该缓冲区之前的内容。<br>如果 bget 创建了一个新的缓冲区，并且该缓冲区没有有效的数据（即 valid &#x3D; 0），bread 会在返回该缓冲区之前，从磁盘读取数据并填充缓冲区。这是通过调用 virtio_disk_rw 来完成的。</p>
<p>bwrite：将修改后的缓冲区内容写回磁盘上的相应块。<br>每个缓冲区都使用了 睡眠锁，即每个缓冲区在访问时都会被上锁，确保同一时刻只有一个线程可以访问该缓冲区。</p>
<h3 id="缓存回收机制"><a href="#缓存回收机制" class="headerlink" title="缓存回收机制"></a>缓存回收机制</h3><p>Buffer Cache的回收机制：</p>
<p>缓存中的缓冲区数量是固定的，因此当文件系统需要一个未存放在缓存中的块时，必须回收现有的某些缓冲区来为新块腾出空间。为了高效利用缓存，Buffer Cache使用了一种 LRU（Least Recently Used） 策略，即 回收最近最少使用的缓冲区，因为这些缓冲区在近期再次使用的可能性较低。</p>
<p>这种回收机制保证了 缓存区的空间使用最优化，尽量避免频繁地从磁盘读取相同的数据，提高了磁盘和内存之间的数据流通效率</p>
<h3 id="对应代码实现"><a href="#对应代码实现" class="headerlink" title="对应代码实现"></a>对应代码实现</h3><p>双链表： Buffer Cache 使用 双链表 来表示缓冲区（buffer）。在初始化时，main（kernel&#x2F;main.c）调用 binit，并使用静态数组 buf（位于 kernel&#x2F;bio.c）中的 NBUF 个缓冲区初始化双链表。这些缓冲区的链表头通过 bcache.head 来访问，因此对缓存的所有其他访问都是通过这个链表而不是直接操作 buf 数组。<br>缓冲区的状态字段：<br>+————+    +————+    +————+    +————+<br>| Buffer 1   |&lt;–&gt;| Buffer 2   |&lt;–&gt;| Buffer 3   |&lt;–&gt;| Buffer N   |<br>+————+    +————+    +————+    +————+<br>   ^  |                ^  |               ^  |               ^  |<br>   |  |—————-|  |—————|  |—————|  |<br>   |                  |                    |                   |<br>   |                  +——————–+——————-+<br>   |<br>   v<br> bcache.head</p>
<p>每个缓冲区（buffer）有两个关键的状态字段：</p>
<p>valid：</p>
<p>这个字段表示缓冲区是否包含有效的块副本。如果 valid 为 0，则说明缓冲区没有有效的数据，可能需要从磁盘读取数据。<br>disk：</p>
<p>这个字段表示缓冲区中的数据是否已经写回磁盘。如果缓冲区内容已写回磁盘，disk 的状态会被设置为相应的标志，表示数据已经完成了磁盘写入。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/13/xv6/" data-id="cm4pqjdw6000004vqgfe1gzrn" data-title="xv6" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图论-总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2024-12-12T15:25:11.000Z" itemprop="datePublished">2024-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最短路径-起始我推荐去看代码原版-这是是我自己回归经验"><a href="#最短路径-起始我推荐去看代码原版-这是是我自己回归经验" class="headerlink" title="最短路径 起始我推荐去看代码原版 这是是我自己回归经验"></a>最短路径 起始我推荐去看代码原版 这是是我自己回归经验</h2><p>这里说的是最短路径 那么就是说不包含所有的点 有起点和终点就可以了</p>
<p>那么就有这些方法：<br>dijkstra朴素版<br>dijkstra堆优化版<br>Bellman_ford<br>Bellman_ford 队列优化算法（又名SPFA）<br>bellman_ford 算法判断负权回路<br>bellman_ford之单源有限最短路<br>Floyd 算法精讲<br>启发式搜索：A * 算法</p>
<p>dijkstra和bellman都是松弛操作 只不过前者是对没有采用的节点进行更新 后者对所有的节点都进行更新 所以一个是局部最优 一个是全局最优</p>
<p>dijkstra 不算动态规划只是贪心操作 每次更新 新的minDist里面的节点都是起始节点到当前节点的距离 （源点开始到选点的更新点）<br>第一个 dijkstra:<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）<br>复杂度O(N^2)</p>
<p>第二个 dijkstra堆优化：<br>换成了按照边进行排序<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）<br>原始的存储方式换成了邻接表的形式 同时因为是使用边来进行排序<br>所有使用了优先队列小顶堆  优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt;<br>复杂度O(ElogE)</p>
<p>第三个Bellman-Ford:和上面不同的点在于为动态规划方式 每次松弛操作都是<br>因为有了新要求：权值可以有负数 需要检测负权回路 加上有走过节点数量的限制<br>步骤是对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路<br>复杂度O(N*E)<br>可以判断负权回路：松弛超过n-1次就可以了 看数值是否还有变化<br>可以在节点数量限制下使用 注意既然要求严格控制边的数量限制 那么每次循环更新的minDist都要用上次的计算结果不要用一个数组进行控制</p>
<p>第四个SPFA 是Bellman-Ford:队列优化版<br>只需要对上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了<br>while(!que.empty()){&#x2F;&#x2F;代替for循环}<br>同时对这之后的做出松弛能得到相同的结果 但是动态规划这个就不能很好体现出现了 但是本质上松弛的节点和原始是一样的<br>复杂度O(N*K)</p>
<p>第五个Floyd 提出的需求是多个起点：也是动态规划<br>但是具体步骤在于：<br>grid[i][j][k] &#x3D; min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])<br>优化成这个：<br>grid[i][j] &#x3D; min(grid[i][j], grid[i][k] + grid[k][j]);<br>但是还是三层遍历顺序解决问题<br>复杂度O(N^3)</p>
<p>使用单源且为正数权值 还没有负权回路直接使用dijkstra<br>使用单源且可以为负数 直接使用Bellman-Ford<br>多个源 可以使用Floyd</p>
<p>A*不一定得出最后准确结果 但是快</p>
<h2 id="图论总结篇"><a href="#图论总结篇" class="headerlink" title="图论总结篇"></a>图论总结篇</h2><p>首先是两种存储方式 邻接表和邻接矩阵</p>
<p>之后是基本的搜索方法 深搜和广搜</p>
<h2 id="深搜的两种写法"><a href="#深搜的两种写法" class="headerlink" title="深搜的两种写法"></a>深搜的两种写法</h2><p>dfs有两种一种是处理当前节点 一种是处理以下各节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是处理下一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这种处理方法必须要在主函数的时候使用第一个节点先处理了</span></span><br><span class="line"><span class="comment">// 写法一：处理当前访问的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> key, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[key] = <span class="literal">true</span>;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys) &#123;</span><br><span class="line">        <span class="comment">// 深度优先搜索遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, key, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：处理下一个要访问的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> key, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[key] == <span class="literal">false</span>) &#123; <span class="comment">// 确认下一个是没访问过的节点</span></span><br><span class="line">            visited[key] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(graph, key, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿问题系列-也就是染色系列不需要回溯-我得去看看"><a href="#岛屿问题系列-也就是染色系列不需要回溯-我得去看看" class="headerlink" title="岛屿问题系列 也就是染色系列不需要回溯 &#x2F;&#x2F;我得去看看"></a>岛屿问题系列 也就是染色系列不需要回溯 &#x2F;&#x2F;我得去看看</h2><p>路线问题必须回溯去掉头<br>完全可达只看能不能达到 不需要回溯</p>
<h2 id="广搜超时问题"><a href="#广搜超时问题" class="headerlink" title="广搜超时问题"></a>广搜超时问题</h2><p>要加入队列就代表走过，就需要标记，而不是从队列拿出来的时候再去标记走过。<br>是的 如果已经加入队列之后 其他的点也可能去加入这个已经加入队列的点导致重复问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);</span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串接龙自做无向图-这个需要注意一下"><a href="#字符串接龙自做无向图-这个需要注意一下" class="headerlink" title="字符串接龙自做无向图 这个需要注意一下"></a>字符串接龙自做无向图 这个需要注意一下</h2><p> unordered_map&lt;string, int&gt; visitMap; &#x2F;&#x2F; &lt;记录的字符串，路径长度&gt;<br>  visitMap.insert(pair&lt;string, int&gt;(beginStr, 1));</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集主要有两个功能：</p>
<p>将两个元素添加到一个集合中。<br>判断两个元素在不在同一个集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个<br>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上<br>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</p>
<h2 id="最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起"><a href="#最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起" class="headerlink" title="最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起"></a>最小生成树：以最小的成本（边的权值）将图中所有节点链接到一起</h2><p>注意是所有边<br>prim 和 kruskal<br>在 稀疏图中，用Kruskal更优。 在稠密图中，用prim算法更优。<br>Prim 算法 时间复杂度为 O(n^2)其中 n 为节点数量<br>Kruskal算法 时间复杂度 为 O(nlogn)，其中n 为边的数量</p>
<h2 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h2><p>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</p>
<h2 id="kruscal"><a href="#kruscal" class="headerlink" title="kruscal"></a>kruscal</h2><p>边的权值排序，因为要优先选最小的边加入到生成树里<br>遍历排序后的边<br>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环<br>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (e--) &#123;</span><br><span class="line">      cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;</span><br><span class="line">      edges.<span class="built_in">push_back</span>(&#123;v1, v2, val&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行Kruskal算法</span></span><br><span class="line">  <span class="comment">// 按边的权值对边进行从小到大排序</span></span><br><span class="line">  <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">          <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line">      <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">          result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">          <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; result_val &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。<br>步骤：<br>找到入度为0 的节点，加入结果集<br>将该节点从图中移除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i] ==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始从队列里遍历入度为0 的节点，将其放入结果集。</span></span><br><span class="line"><span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> cur =que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="comment">//将该节点从图中移除</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取cur指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果cur有指向的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历cur指向的节点</span></span><br><span class="line">            inDegree[files[i]] --; <span class="comment">// cur指向的节点入度都做减一操作</span></span><br><span class="line">            <span class="comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/" data-id="cm4pqjdwh000304vq9q0k3n4g" data-title="图论-总结" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-杂项语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-12-10T12:24:17.000Z" itemprop="datePublished">2024-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/">杂项语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>优先队列实现小顶堆</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为优先队列本身是大的在顶部被排序排出的 所以小顶堆就得重写CMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myconparison</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hls,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt;rhs.second<span class="comment">//优先队列这么做是为了反过来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparsion&gt;pq;</span><br><span class="line"><span class="comment">//第一个参数是存储什么 第二个参数是用什么存储</span></span><br></pre></td></tr></table></figure>

<p>构造函数参数形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rdge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t,<span class="type">int</span> w):<span class="built_in">to</span>(t),<span class="built_in">val</span>(w)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;;<span class="comment">//;</span></span><br></pre></td></tr></table></figure>

<p>填充</p>
<p>memset(moves, 0, sizeof(moves));<br>moves ：目标内存区域的起始地址（通常是数组或指针）。<br>0填充的<br>sizeof(moves)：指定填充的内存字节数，这里是 moves 数组的总大小。</p>
<p>重载运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span>运算符 (参数列表) &#123;</span><br><span class="line">    <span class="comment">// 运算逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回迭代器最小的值并且解引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getFinalState</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = <span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            *iter *= multiplier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还学会一个快速幂<br>x是原始数值 n是次方也是 要转换的二进制数<br>首先判定n这个此项是否大于0小于0等于0 把他们改成大于0 等于0直接等于1的结果了<br>如果这个时候数值的二进制最小值是1 那么就把结果和当前的x 相乘<br>之后进入和数组二进制最小值不是1的一个分支 x变为x平方 之后把二进制数右移动一位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = N;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; <span class="comment">// x^-n = (1/x)^n</span></span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123; <span class="comment">// 从低到高枚举 n 的每个比特位</span></span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123; <span class="comment">// 这个比特位是 1</span></span><br><span class="line">                ans *= x; <span class="comment">// 把 x 乘到 ans 中</span></span><br><span class="line">            &#125;</span><br><span class="line">            x *= x; <span class="comment">// x 自身平方</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 继续枚举下一个比特位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">填充</span><br><span class="line">unordered_set&lt;string&gt; strSet;</span><br><span class="line">strSet.<span class="built_in">insert</span>(str);</span><br><span class="line"></span><br><span class="line">结构绑定化声明</span><br><span class="line"><span class="keyword">auto</span> [u, v] 是 C+<span class="number">+17</span> 引入的 结构化绑定声明，它允许你从一个包含多个元素的对象（比如元组、pair 或数组）中提取多个值并将它们分别绑定到变量中。</span><br><span class="line"></span><br><span class="line">例如，考虑如下 pair 类型的元素：</span><br><span class="line"></span><br><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">你可以通过结构化绑定将 pair 的两个元素分别绑定到 u 和 v：</span><br><span class="line"></span><br><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">auto</span> [u, v] = p;  <span class="comment">// 结构化绑定</span></span><br><span class="line">这等价于：</span><br><span class="line"></span><br><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">auto</span> u = p.first;</span><br><span class="line"><span class="keyword">auto</span> v = p.second;</span><br></pre></td></tr></table></figure>
<h3 id="我好像做过质数筛法-找一下"><a href="#我好像做过质数筛法-找一下" class="headerlink" title="我好像做过质数筛法 找一下"></a>我好像做过质数筛法 找一下</h3><p>c++20<br> ranges::sort(cnt, greater());<br>默认升序 这是降序</p>
<h2 id="set用法"><a href="#set用法" class="headerlink" title="set用法"></a>set用法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window; <span class="comment">// 维护从下标 left 到下标 right 的字符</span></span><br><span class="line">        <span class="type">int</span> right =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="comment">// 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素</span></span><br><span class="line">            <span class="comment">// 所以要在加入 c 之前，先移出窗口内的 c</span></span><br><span class="line">            <span class="keyword">while</span> (window.<span class="built_in">contains</span>(c)) &#123; <span class="comment">// 窗口内有 c</span></span><br><span class="line">                window.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++; <span class="comment">// 缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">insert</span>(c); <span class="comment">// 加入 c</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); <span class="comment">// 更新窗口长度最大值</span></span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="ranges-reverse-nums-反转次数"><a href="#ranges-reverse-nums-反转次数" class="headerlink" title="ranges::reverse(nums); 反转次数"></a>ranges::reverse(nums); 反转次数</h2><h2 id="前缀和模板"><a href="#前缀和模板" class="headerlink" title="前缀和模板"></a>前缀和模板</h2><h2 id="字典树-和前缀树这两个问题解决"><a href="#字典树-和前缀树这两个问题解决" class="headerlink" title="字典树 和前缀树这两个问题解决"></a>字典树 和前缀树这两个问题解决</h2><p>前缀树本来就属于字典树</p>
<h2 id="range-位数与计算"><a href="#range-位数与计算" class="headerlink" title="range 位数与计算"></a>range 位数与计算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="built_in">bit_width</span>((<span class="type">unsigned</span>) ranges::<span class="built_in">max</span>(candidates));  </span><br><span class="line"><span class="comment">// m = 最大数字的位宽，表示需要检查的比特位数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bit_width</span>();<span class="comment">//必须是无符号数 所以需用unsigned 进行强制转换</span></span><br><span class="line">rangws::<span class="built_in">max</span>();</span><br><span class="line"><span class="built_in">bit_width</span>()<span class="comment">//)支持无符号整型数- bit_width  unsigned</span></span><br><span class="line">std :: ranges:: <span class="built_in">max</span>(?)<span class="comment">//直接选举出它的最大值</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="堆排序模板"><a href="#堆排序模板" class="headerlink" title="堆排序模板"></a>堆排序模板</h2><pre><code class="cpp">class Solution&#123;
    public:
    void maxHeapify(vector&lt;int&gt;&amp; a,int i,int heapSize)&#123;
        int leftChild = 2*i+1;
        int rightChild =2*i+2;
        int largest =i;

        if(leftChild &lt;heapSize &amp;&amp; a[leftChild] &gt; a[largest])&#123;
            largest = leftChild;//存储左右节点中代表着最大的值
        &#125;
        if(rightChild &lt;heapSize &amp;&amp; a[rightChild]&gt; a[largest])&#123;
            largest =rightChild;
        &#125;
        if(largest != i )&#123;
            swap(a[i],a[largest]);
            maxHeapify(a,largest,heapSize);
        &#125;
    &#125; 
    void buildMcHeap(vector&lt;int&gt;&amp;a)&#123;
        int heapSize =a.size();
        for(int i= heapSize /2 -1;i&gt;=0;--i)&#123;
            maxHeapify(a,i,heapSize);
        &#125;
    &#125;
    void heapSort(vector&lt;int&gt;&amp;nums)&#123;
        int heapSize =nums.size();
        buildMaxHeap(nums);

        for(int i = nums.size()-1;i&gt;0;--i)&#123;
            swap(num[0],num[i]);
            --heapSize;
            maxHeapify(nums,0,heapSize);
        &#125;
    &#125;
    //这里的k是从1打头的 说明第一大就是什么也不做 不进入循环 第二大就是滤掉第一个 进入循环一次 那么第k大就是循环k-1次
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        int heapSize = nums.size();
        buildMaxHeap(nums, heapSize);
        for (int i = 0; i &lt; k-1 ; ++i) &#123;
            swap(nums[0], nums[heapSize-1]);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        &#125;
        return nums[0];
    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/" data-id="cm4iipakm0001b0vqc7b5ez7b" data-title="杂项语法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图论-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/" class="article-date">
  <time class="dt-published" datetime="2024-12-07T07:46:36.000Z" itemprop="datePublished">2024-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/">图论-2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>输入描述：</p>
<p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p>
<p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p>
<p>输出描述：</p>
<p>输出联通所有岛屿的最小路径总距离</p>
<p>输入示例：</p>
<p>7 11<br>1 2 1<br>1 3 1<br>1 5 2<br>2 6 1<br>2 4 2<br>2 3 2<br>3 4 1<br>4 5 1<br>5 6 2<br>5 7 1<br>6 7 1<br>输出示例：</p>
<p>6</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>官方解法在于三个步骤<br>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</p>
<p>minDist数组 是记录了 所有非生成树节点距离生成树的最小距离。</p>
<p>最后，minDist数组 也就是记录的是最小生成树所有边的权值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> x, y, k;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="comment">// 填一个默认最大值，题目描述val最大为10000</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">10001</span>));</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        <span class="comment">// 因为是双向图，所以两个方向都要填上</span></span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有节点到最小生成树的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(v + <span class="number">1</span>, <span class="number">10001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点是否在树里</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isInTree</span><span class="params">(v + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、prim三部曲，第一步：选距离生成树最近节点</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">-1</span>; <span class="comment">// 选中哪个节点 加入最小生成树</span></span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123; <span class="comment">// 1 - v，顶点编号，这里下标从1开始</span></span><br><span class="line">            <span class="comment">//  选取最小生成树节点的条件：</span></span><br><span class="line">            <span class="comment">//  （1）不在最小生成树里</span></span><br><span class="line">            <span class="comment">//  （2）距离最小生成树最近的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp;  minDist[j] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;<span class="comment">//   默认逻辑就是第一个节点就是加入的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span></span><br><span class="line">        isInTree[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="comment">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下</span></span><br><span class="line">        <span class="comment">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">            <span class="comment">// 更新的条件：</span></span><br><span class="line">            <span class="comment">// （1）节点是 非生成树里的节点</span></span><br><span class="line">            <span class="comment">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span></span><br><span class="line">            <span class="comment">// 其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">                minDist[j] = grid[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= v; i++) &#123; <span class="comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span></span><br><span class="line">        result += minDist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展同时打印出最小生成树的每一条边</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(v + <span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">//用来记录边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既然 minDist数组 记录了 最小生成树的边，是不是就是在更新 minDist数组 的时候，去更新parent数组来记录一下对应的边呢。所以 在 prim三部曲中的第三步，更新 parent数组，代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">        parent[j] = cur; <span class="comment">// 记录最小生成树的边 （注意数组指向的顺序很重要）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果写成 parent[cur] = j，在 for 循环中，有多个 j 满足要求， 那么 parent[cur] 就会被反复覆盖，因为 cur 是一个固定值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举个例子，cur = 1， 在 for循环中，可能 就 j = 2， j = 3，j =4 都符合条件，那么本来应该记录 节点1 与 节点 2、节点3、节点4相连的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 parent[cur] = j 这么写，最后更新的逻辑是 parent[1] = 2, parent[1] = 3， parent[1] = 4， 最后只能记录 节点1 与节点 4 相连，其他相连情况都被覆盖了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这么写 parent[j] = cur， 那就是 parent[2] = 1, parent[3] = 1， parent[4] = 1 ，这样 才能完整表示出 节点1 与 其他节点都是链接的，才没有被覆盖。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 最小生成树边的链接情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; parent[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>输入描述：</p>
<p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p>
<p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p>
<p>输出描述：</p>
<p>输出联通所有岛屿的最小路径总距离</p>
<p>输入示例：</p>
<p>7 11<br>1 2 1<br>1 3 1<br>1 5 2<br>2 6 1<br>2 4 2<br>2 3 2<br>3 4 1<br>4 5 1<br>5 6 2<br>5 7 1<br>6 7 1<br>输出示例：</p>
<p>6</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>题目一摸一样 换了个做法<br>和prim的区别在于<br>prim维护节点 这个维护边</p>
<p>kruscal的思路：</p>
<p>边的权值排序，因为要优先选最小的边加入到生成树里</p>
<p>遍历排序后的边:<br>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环<br>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</p>
<p>是否在一个集合使用并查集来判断问题 同时使用并查集添加节点<br>&#x2F;&#x2F;快排+并查集nlogn （快排） + logn （并查集）  -&gt;最后是nlogn</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l,r为 边两边的节点，val为边的数值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点数量</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10001</span>;</span><br><span class="line"><span class="comment">// 并查集标记节点关系的数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">// 节点编号是从1开始的，n要大一些</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的查找操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的加入集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> v1, v2, val;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    <span class="type">int</span> result_val = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;v1, v2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法</span></span><br><span class="line">    <span class="comment">// 按边的权值对边进行从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头开始遍历边</span></span><br><span class="line">    <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 并查集，搜出两个节点的祖先</span></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(edge.l);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">find</span>(edge.r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">            <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result_val &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这也加一个输出最小生成树的边</span></span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; result; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line"><span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(edge); <span class="comment">// 记录最小生成树的边</span></span><br><span class="line">    result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">    <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (Edge edge : result) &#123;</span><br><span class="line">        cout &lt;&lt; edge.l &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.r &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法比较"><a href="#方法比较" class="headerlink" title="方法比较"></a>方法比较</h2><p>Kruskal 与 prim 的关键区别在于，prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 如果 一个图中，节点多，但边相对较少，那么使用Kruskal 更优。</p>
<p>Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。</p>
<p>Kruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>题目描述：</p>
<p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;&#x3D; A, B &lt;&#x3D; N - 1）。请编写一个算法，用于确定文件处理的顺序。</p>
<p>输入描述：</p>
<p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p>
<p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p>
<p>输出描述：</p>
<p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p>
<p>如果不能成功处理（相互依赖），则输出 -1。</p>
<p>输入示例：</p>
<p>5 4<br>0 1<br>0 2<br>1 3<br>2 4<br>输出示例：</p>
<p>0 1 2 3 4</p>
<p>提示信息：</p>
<p>文件依赖关系如下：<br>0-&gt;1-&gt;3<br>0-&gt;2-&gt;4<br>所以，文件处理的顺序除了示例中的顺序，还存在</p>
<p>0 2 4 1 3</p>
<p>0 2 1 3 4</p>
<p>等等合法的顺序。</p>
<p>数据范围：</p>
<p>0 &lt;&#x3D; N &lt;&#x3D; 10 ^ 5<br>1 &lt;&#x3D; M &lt;&#x3D; 10 ^ 9</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。<br>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p>
<p>重点：所以拓扑排序也是图论中判断有向无环图的常用方法</p>
<p>其实只要能在把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序。</p>
<p>实现拓扑排序的算法有两种：卡恩算法（BFS）和DFS</p>
<p>你看节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p>
<p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。</p>
<p>所以当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点</p>
<p>具体步骤：</p>
<p>找到入度为0 的节点，加入结果集<br>将该节点从图中移除</p>
<p>循环以上两步，直到 所有节点都在图中被移除了。</p>
<p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">inDegree</span>(n,<span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    cin &gt;&gt;s&gt;&gt;t;</span><br><span class="line">    inDegree[t] ++;</span><br><span class="line">    umap[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i] ==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始从队列里遍历入度为0 的节点，将其放入结果集。</span></span><br><span class="line"><span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> cur =que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="comment">//将该节点从图中移除</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取cur指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果cur有指向的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历cur指向的节点</span></span><br><span class="line">            inDegree[files[i]] --; <span class="comment">// cur指向的节点入度都做减一操作</span></span><br><span class="line">            <span class="comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以，我们在代码实现的过程中，本质是要将 该节点作为出发点所连接的节点的 入度 减一 就可以了，这样好能根据入度找下一个节点，不用真在图里把这个节点删掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整体代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 记录每个文件的入度</span></span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; umap;<span class="comment">// 记录文件依赖关系</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 记录结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="comment">// s-&gt;t，先有s才能有t</span></span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        inDegree[t]++; <span class="comment">// t的入度加一</span></span><br><span class="line">        umap[s].<span class="built_in">push_back</span>(t); <span class="comment">// 记录s指向哪些文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 入度为0的文件，可以作为开头，先加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int count = 0;</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span>  cur = que.<span class="built_in">front</span>(); <span class="comment">// 当前选中的文件</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取该文件指向的文件</span></span><br><span class="line">        <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// cur有后续文件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                inDegree[files[i]] --; <span class="comment">// cur的指向的文件入度-1</span></span><br><span class="line">                <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; result[n - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断有无环</span></span><br><span class="line">如果我们发现结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p>
<p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>
<p>【输出描述】</p>
<p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p>
<p>输入示例</p>
<p>7 9<br>1 2 1<br>1 3 4<br>2 3 2<br>2 4 5<br>3 4 2<br>4 5 3<br>2 6 4<br>5 7 4<br>6 7 9<br>输出示例：12</p>
<p>【提示信息】</p>
<p>能够到达的情况：</p>
<p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p>
<h3 id="解法-dijkstra算法-和prim算法-原理相似-贪心原理"><a href="#解法-dijkstra算法-和prim算法-原理相似-贪心原理" class="headerlink" title="解法  dijkstra算法 (和prim算法)原理相似&#x2F; 贪心原理"></a>解法  dijkstra算法 (和prim算法)原理相似&#x2F; 贪心原理</h3><p>和上面不同的在于不是每一个点都要参与进去 同时属于有向图问题</p>
<p>本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。</p>
<p>接下来，我们来详细讲解最短路算法中的 dijkstra 算法。</p>
<p>dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</p>
<p>需要注意两点：</p>
<p>dijkstra 算法可以同时求 起点到所有节点的最短路径<br>权值不能为负数</p>
<p>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
<p>不同的点在于路径规划的时候填充表格的值是从源点开始到目标的距离值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;climits&gt;</span><span class="comment">//前缀作用</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,INT_MAX));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1][p2] =val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n<span class="number">+1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//遍历所有节点</span></span><br><span class="line">    <span class="type">int</span> minVal =INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur =<span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 1、选距离源点最近且未访问过的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; minDist[v] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[v];</span><br><span class="line">                cur = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         visited[cur] = <span class="literal">true</span>;  <span class="comment">// 2、标记该节点已被访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 被利用的节点加上这个节点到新的节点的距离 等于总的距离  被利用的节点之前就是最近节点的选择 就是这一点和prime不同的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应求路径</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">                parent[v] = cur; <span class="comment">// 记录边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意 不能出现负数<br>但是prime可以由负数权值 因为一个是双向一个是单向没有路径依赖 虽然都有visit</p>
<p>prim和dijkstra的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prim</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//因为 minDist表示 节点到最小生成树的最小距离，所以 新节点cur的加入，只需要 使用 grid[cur][j] ，grid[cur][j] 就表示 cur 加入生成树后，生成树到 节点j 的距离。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dijkstra</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">        minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//因为 minDist表示 节点到源点的最小距离，所以 新节点 cur 的加入，需要使用 源点到cur的距离 （minDist[cur]） + cur 到 节点 v 的距离 （grid[cur][v]），才是 源点到节点v的距离。</span></span><br></pre></td></tr></table></figure>
<h2 id="dijkstra（堆优化版）精讲"><a href="#dijkstra（堆优化版）精讲" class="headerlink" title="dijkstra（堆优化版）精讲"></a>dijkstra（堆优化版）精讲</h2><p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p>
<p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>
<p>【输出描述】</p>
<p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p>
<p>输入示例</p>
<p>7 9<br>1 2 1<br>1 3 4<br>2 3 2<br>2 4 5<br>3 4 2<br>4 5 3<br>2 6 4<br>5 7 4<br>6 7 9<br>输出示例：12</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>题目还是那个题目<br>优化方式用在了把数组改成邻接表的情况</p>
<p>三部分<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
<p>三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历 minDist 来寻找最近的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 遍历所有节点，第一层for循环 </span></span><br><span class="line">    <span class="type">int</span> minVal =INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;++v)&#123;<span class="comment">// 1、选距离源点最近且未访问过的节点 ， 第二层for循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!visited[v] &amp;&amp; minDist[v]&lt;minVal)&#123;</span><br><span class="line">            minVal =minDist[v];</span><br><span class="line">            cur =v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur] =<span class="literal">true</span>;<span class="comment">//这个点被标记访问过了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)&#123;<span class="comment">//更新没有访问过的节点到源点的最小距离</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v]&amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur]+grid[cur][v] &lt;minDist[v])&#123;</span><br><span class="line">            minDist[v] =minDist[cur] +grid[cur][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。</p>
<p>而且 直接把 边（带权值）加入到 小顶堆（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。</p>
<p>这样我们就不需要两层for循环来寻找最近的节点了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);<span class="comment">//邻接表图结构</span></span><br><span class="line"></span><br><span class="line">vector&lt;list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//第一个是节点 第二个是权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用类取代pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数 初始列表型构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 链接的节点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用边取代点从而使用堆优化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为优先队列本身是大的在顶部被排序排出的 所以小顶堆就得重写CMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myconparison</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hls,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt;rhs.second<span class="comment">//优先队列这么做是为了反过来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparsion&gt;pq;</span><br><span class="line"><span class="comment">//第一个参数是存储什么 第二个参数是用什么存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部曲中的第一步，我们不用 for循环去遍历，直接取堆顶元素：有了小顶堆自动对边的权值排序，那我们只需要直接从 堆里取堆顶元素（小顶堆中，最小的权值在上面），就可以取到离源点最近的节点了 （未访问过的节点，不会加到堆里进行排序）</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//第二步（该最近节点被标记访问过） 这个就是将 节点做访问标记，和 朴素dijkstra 一样 ，代码如下</span></span><br><span class="line"></span><br><span class="line">visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cur.first 就是cur节点编号， 参考上面pair的定义： pair&lt;节点编号，源点到该节点的权值&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来就是更新 非访问节点到源点的距离，代码实现和 朴素dijkstra 是一样的，代码如下：</span></span><br><span class="line"><span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line"><span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">    <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">    <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">        minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//整体代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个结构体来表示带权重的边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; </span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2, val));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> end = n;    <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储从源点到每个节点的最短距离</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录顶点是否被访问过</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(start, <span class="number">0</span>)); </span><br><span class="line">    </span><br><span class="line">    minDist[start] = <span class="number">0</span>;  <span class="comment">// 起始点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span></span><br><span class="line">        <span class="comment">// &lt;节点， 源点到该节点的距离&gt;</span></span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); </span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[cur.first]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 第二步，该最近节点被标记访问过</span></span><br><span class="line">        visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">            <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">                minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得讨论的复杂度O(ElogE) E 为边的数量</p>
<h2 id="Bellman-ford-算法"><a href="#Bellman-ford-算法" class="headerlink" title="Bellman_ford 算法"></a>Bellman_ford 算法</h2><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。</p>
<p>如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</p>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p>
<p>输入描述</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v（单向图）。</p>
<p>输出描述</p>
<p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p>
<p>输入示例：</p>
<p>6 7<br>5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>引入这个是因为 一个是最短路径 可以有没走过的 一个是有权值同时还有负数</p>
<p>这回题目唯一的区别在于权值有负数了 这下上个算法就有了局限性 所以引入新的算法<br>Bellman_ford算法的核心思想是 对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路。</p>
<p>学会了松弛操作<br>明白了松弛操作之后得到的是什么<br>松弛操作之后得到的就是<br>松弛具体操作：<br>minDist[B] 表示 到达B节点 最小权值，minDist[B] 有哪些状态可以推出来？</p>
<p>状态一： minDist[A] + value 可以推出 minDist[B] 状态二： minDist[B]本身就有权值 （可能是其他边链接的节点B 例如节点C，以至于 minDist[B]记录了其他边到minDist[B]的权值）</p>
<p>minDist[B] 应为如何取舍。</p>
<p>本题我们要求最小权值，那么 这两个状态我们就取最小的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minDist[B] &gt; minDist[A] + value) minDist[B] = minDist[A] + value</span><br></pre></td></tr></table></figure>
<p>松弛一次是一条边 一共n个点 所以松弛n-1次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;grid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt;val;</span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1,p2,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT+MAX)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;&amp;side :grid)&#123;</span><br><span class="line">            <span class="type">int</span> from =side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to =side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> prime =side[<span class="number">2</span>];<span class="comment">//这里的最大值判定也和VISTIS差不多 需要更新的是已经经过计算的节点往后的节点</span></span><br><span class="line">            <span class="keyword">if</span>(minDist[from] != INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] + price)&#123;</span><br><span class="line">                minDist[to] =minDist[from] +price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minDist[end] ==INT_MAX) cout &lt;&lt; <span class="string">&quot;unconnected&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt;minDist[end] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bellman-ford-队列优化算法（又名SPFA）"><a href="#Bellman-ford-队列优化算法（又名SPFA）" class="headerlink" title="Bellman_ford 队列优化算法（又名SPFA）"></a>Bellman_ford 队列优化算法（又名SPFA）</h2><p>题还是拿到题</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p> Bellman_ford 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。</p>
<p>只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了。</p>
<p>因为： if(minDist[from] !&#x3D; INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] + price){<br>                minDist[to] &#x3D;minDist[from] +price;<br>这个是只有计算过的点之后的边才能进行松弛 之前做的循环浪费效率<br>之前用的是数组形式，现在修改为临接表形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">a b c</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rdge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t,<span class="type">int</span> w):<span class="built_in">to</span>(t),<span class="built_in">val</span>(w)&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>);</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">isInQueen</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">//保存输入边</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt;val;</span><br><span class="line"></span><br><span class="line">        grid[p1].push+<span class="built_in">back</span>(<span class="built_in">Edge</span>(p2,val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">minDist</span>(n<span class="number">+1</span>,INT_MAX);</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;<span class="comment">//代替for循环</span></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        isInQueue[node] =<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(Edge edge:grid[node])&#123;</span><br><span class="line">            <span class="type">int</span> from =node;</span><br><span class="line">            <span class="type">int</span> to = edge.to;</span><br><span class="line">            <span class="type">int</span> value =edge.val;</span><br><span class="line">            <span class="keyword">if</span>(minDist[to] &gt;minDist[from] + value)&#123;<span class="comment">//这里开始不同 只看已经安排好的节点</span></span><br><span class="line">            minDist[to] =minDist[from] +value;</span><br><span class="line">            <span class="keyword">if</span>(isInQueue[to] == <span class="literal">false</span>)&#123;<span class="comment">//把更新的节点加入进来同时确保整个更新的节点不是已经在队列里面了</span></span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">                isInQueue[to] =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(minDist[end] ==INT_MAX)cout &gt;&gt;<span class="string">&quot;unconnected&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt;minDist[end] &lt;&lt;endl;<span class="comment">//到达终点最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我突然发现使用邻接表形式的都是需要用队列去取代大循环呢 因为是存储方式的不同吗？</p>
<p>效率分析O(KN) K是个数 N是边 用来取出放入的</p>
<p>说说这个while的问题 不会出现死循环 首先没有负权回路 就是走了一圈总的值变小的1环<br>那么对于一个有整数的环 会因为所有的边都松之后 不能更新新的节点进入对列而退出循环</p>
<h2 id="bellman-ford之判断负权回路"><a href="#bellman-ford之判断负权回路" class="headerlink" title="bellman_ford之判断负权回路"></a>bellman_ford之判断负权回路</h2><p>【题目描述】</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；</p>
<p>权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：图中可能出现负权回路。</p>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p>
<p>为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p>
<p>【输出描述】</p>
<p>如果没有发现负权回路，则输出一个整数，表示从城市 1 到城市 n 的最低运输成本（包括政府补贴）。</p>
<p>如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 “circle”。如果从城市 1 无法到达城市 n，则输出 “unconnected”。</p>
<p>输入示例</p>
<p>4 4<br>1 2 -1<br>2 3 1<br>3 1 -1<br>3 4 1<br>输出示例</p>
<p>circle</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>详细看了看题目发现就是允许负数的环存在了 可以无限跑下去 这里题目要求当这种情况直接输出一个值就可以了</p>
<p>解决方法就是用松弛法的性质 松弛法在n-1次之后在松弛已经没有变化了 可以通过是否有变化来判断有没有负权回路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;grid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1 &gt;&gt;p2 &gt;&gt;val;</span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1,p2,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag =<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; &amp;side :grid)&#123;</span><br><span class="line">            <span class="type">int</span> from =side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> price = side[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(minDist[from] !=INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] +price) minDist[to] =minDist[from] +price;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(minDist[from] !=INT_MAX &amp;&amp; minDist[to] &gt;minDist[from] +price)flag =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag) cout &lt;&lt;<span class="string">&quot;cirile&quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(minDist[end] ==INT_MAX)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;unconnected&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;minDIst[end]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度： O(N * E) , N为节点数量，E为图中边的数量</span></span><br></pre></td></tr></table></figure>
<p>拓展<br>SPFA的情况就是用队列去判断了 队列每个点最后能被进入n-1次 因为它顶多把所有的边都连接上 同时如果又进入了说明又更新了一回 那么就是有负权回路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t,<span class="type">int</span> w):<span class="built_in">to</span>(t),<span class="built_in">val</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2,val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">minDist</span>(n<span class="number">+1</span>,INT_MAX);</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">count</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    count[start]++;<span class="comment">//第一个节点本身已经计入了？是的本身就是按照计入来计算的</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[node]) &#123;</span><br><span class="line">            <span class="type">int</span> from = node;</span><br><span class="line">            <span class="type">int</span> to = edge.to;</span><br><span class="line">            <span class="type">int</span> value = edge.val;</span><br><span class="line">            <span class="keyword">if</span> (minDist[to] &gt; minDist[from] + value) &#123; <span class="comment">// 开始松弛</span></span><br><span class="line">                minDist[to] = minDist[from] + value;</span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">                count[to]++; </span><br><span class="line">                <span class="keyword">if</span> (count[to] == n) &#123;<span class="comment">// 如果加入队列次数超过 n-1次 就说明该图与负权回路</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minDist[end] == INT_MAX) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unconnected&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; minDist[end] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bellman-ford之单源有限最短路"><a href="#bellman-ford之单源有限最短路" class="headerlink" title="bellman_ford之单源有限最短路"></a>bellman_ford之单源有限最短路</h2><p>【题目描述】</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；</p>
<p>权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p>
<p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。</p>
<p>【输出描述】</p>
<p>输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 “unreachable”，表示不存在符合条件的运输方案。</p>
<p>输入示例：</p>
<p>6 7<br>1 2 1<br>2 4 -3<br>2 5 2<br>1 3 5<br>3 5 1<br>4 6 4<br>5 6 -2<br>2 6 1<br>输出示例：</p>
<p>0</p>
<h3 id="解法-因为数量限制不能用贪心解决问题"><a href="#解法-因为数量限制不能用贪心解决问题" class="headerlink" title="解法 因为数量限制不能用贪心解决问题"></a>解法 因为数量限制不能用贪心解决问题</h3><p>看题目已经了解了区别：<br>最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径。<br>单源有限最短路问题的特定在于有了特定的起始点有了起始点中间数量的限制</p>
<p>所以本题就是求：起点最多经过k + 1 条边到达终点的最短距离。</p>
<p>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离，那么对所有边松弛 k + 1次，就是求 起点到达 与起点k + 1条边相连的节点的 最短距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> src, dst,k ,p1, p2, val ,m , n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1, p2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span> , INT_MAX)</span></span>;</span><br><span class="line">    minDist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) &#123; <span class="comment">// 对所有边松弛 k + 1次</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;side : grid) &#123;</span><br><span class="line">            <span class="type">int</span> from = side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> price = side[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (minDist[from] != INT_MAX &amp;&amp; minDist[to] &gt; minDist[from] + price) minDist[to] = minDist[from] + price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="string">&quot;unreachable&quot;</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[dst] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是错误的 k这个限制在这里并没用上 在：<br>for (vector<int> &amp;side : grid) {<br>            int from &#x3D; side[0];<br>            int to &#x3D; side[1];<br>            int price &#x3D; side[2];<br>            if (minDist[from] !&#x3D; INT_MAX &amp;&amp; minDist[to] &gt; minDist[from] + price) minDist[to] &#x3D; minDist[from] + price;<br>        }<br>这个代码中松弛回在已经更新的节点上进行更新 这就不符合松弛定义了 多了一个边<br>所以在每次计算 minDist 时候，要基于 对所有边上一次松弛的 minDist 数值才行，所以我们要记录上一次松弛的minDist。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> src, dst,k ,p1, p2, val ,m , n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid.<span class="built_in">push_back</span>(&#123;p1, p2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span> , INT_MAX)</span></span>;</span><br><span class="line">    minDist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist_copy</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// 用来记录上一次遍历的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minDist_copy = minDist; <span class="comment">// 获取上一次计算的结果  用上一次结果进行比较和更新</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;side : grid) &#123;</span><br><span class="line">            <span class="type">int</span> from = side[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> to = side[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> price = side[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 注意使用 minDist_copy 来计算 minDist </span></span><br><span class="line">            <span class="keyword">if</span> (minDist_copy[from] != INT_MAX &amp;&amp; minDist[to] &gt; minDist_copy[from] + price) &#123;  </span><br><span class="line">                minDist[to] = minDist_copy[from] + price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="string">&quot;unreachable&quot;</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[dst] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新来看为什么：那么前面讲解过的 94.城市间货物运输I 和 95.城市间货物运输II 也是bellman_ford经典算法，也没使用 minDist_copy，怎么就没问题呢？<br>94.城市间货物运输I， 是没有 负权回路的，那么 多松弛多少次，对结果都没有影响。</p>
<p>求 节点1 到 节点n 的最短路径，松弛n-1 次就够了，松弛 大于 n-1次，结果也不会变。</p>
<p>那么在对所有边进行第一次松弛的时候，如果基于 本次计算的 minDist 来计算 minDist （相当于多做松弛了），也是对最终结果没影响。</p>
<p>95.城市间货物运输II 是判断是否有 负权回路，一旦有负权回路， 对所有边松弛 n-1 次以后，在做松弛 minDist 数值一定会变，根据这一点来判断是否有负权回路。</p>
<p>所以，95.城市间货物运输II 只需要判断minDist数值变化了就行，而 minDist 的数值对不对，并不是我们关心的。</p>
<p>其关键在于本题的两个因素：</p>
<p>本题可以有负权回路，说明只要多做松弛，结果是会变的。<br>本题要求最多经过k个节点，对松弛次数是有限制的。<br>如果本题中 没有负权回路的测试用例， 那版本一的代码就可以过了，</p>
<p>松弛做多了会变<br>松弛还有必须的数量限制</p>
<p>使用SPFA进行：<br>SPFA是针对已经更新的节点进行新的节点计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">to</span>(a),<span class="built_in">val</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1].<span class="built_in">push_bcak</span>(<span class="built_in">Edge</span>(p2,val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start,end;k;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; end &gt;&gt;k;</span><br><span class="line">    k++;<span class="comment">//k+1次边</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist_copy</span><span class="params">(n<span class="number">+1</span>)</span></span>;<span class="comment">//为了防止出现用遍历新的更新新的结果 存储老的更新新的</span></span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="type">int</span> que_size;</span><br><span class="line">    <span class="keyword">while</span>(k-- &amp;&amp;!que.<span class="built_in">empty</span>())<span class="comment">//表示k+1次松弛每次松弛同时保证que有节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        minDist_copy =minDist;</span><br><span class="line">        que_size =que.<span class="built_in">size</span>();<span class="comment">// 记录上次入队列的节点个数</span></span><br><span class="line">        <span class="keyword">while</span>(que_size--)&#123;</span><br><span class="line"><span class="comment">// 上一轮松弛入队列的节点，这次对应的边都要做松弛</span></span><br><span class="line">        <span class="type">int</span> node = que.<span class="built_in">front</span>(); </span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(Edge edge :grid[node])<span class="comment">//对更新后的节点为起始点做松弛</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> from =node;</span><br><span class="line">            <span class="type">int</span> to =edge.to;</span><br><span class="line">            <span class="type">int</span> price =edge.val;</span><br><span class="line">            <span class="keyword">if</span>(minDist[to] &gt;minDist_copy[from] + price)&#123;</span><br><span class="line">                minDist[to] =minDist_copy[from] +price;</span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="string">&quot;unreachable&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"> <span class="keyword">while</span> (k-- &amp;&amp; !que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 每一轮松弛中，控制节点不用重复入队列</span></span><br><span class="line">        minDist_copy = minDist; </span><br><span class="line">        que_size = que.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">while</span> (que_size--) &#123; </span><br><span class="line">            <span class="type">int</span> node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : grid[node]) &#123;</span><br><span class="line">                <span class="type">int</span> from = node;</span><br><span class="line">                <span class="type">int</span> to = edge.to;</span><br><span class="line">                <span class="type">int</span> price = edge.val;</span><br><span class="line">                <span class="keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) &#123;</span><br><span class="line">                    minDist[to] = minDist_copy[from] + price;</span><br><span class="line">                    <span class="keyword">if</span>(visited[to]) <span class="keyword">continue</span>; <span class="comment">// 不用重复放入队列，但需要重复松弛，所以放在这里位置</span></span><br><span class="line">                    visited[to] = <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里的含义是允许了到时候新的节点是由最小的节点计算的 但是对于放入一次之后的节点就不用再放入了 无用功 队列还会重复计算</span></span><br></pre></td></tr></table></figure>

<h2 id="Floyd-算法精"><a href="#Floyd-算法精" class="headerlink" title="Floyd 算法精"></a>Floyd 算法精</h2><p>【题目描述】</p>
<p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。</p>
<p>给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p>
<p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p>
<p>【输入描述】</p>
<p>第一行包含两个整数 N, M, 分别表示景点的数量和道路的数量。</p>
<p>接下来的 M 行，每行包含三个整数 u, v, w，表示景点 u 和景点 v 之间有一条长度为 w 的双向道路。</p>
<p>接下里的一行包含一个整数 Q，表示观景计划的数量。</p>
<p>接下来的 Q 行，每行包含两个整数 start, end，表示一个观景计划的起点和终点。</p>
<p>【输出描述】</p>
<p>对于每个观景计划，输出一行表示从起点到终点的最短路径长度。如果两个景点之间不存在路径，则输出 -1。</p>
<p>【输入示例】</p>
<p>7 3 1 2 4 2 5 6 3 6 8 2 1 2 2 3</p>
<p>【输出示例】</p>
<p>4 -1</p>
<p>【提示信息】</p>
<p>从 1 到 2 的路径长度为 4，2 到 3 之间并没有道路。</p>
<p>1 &lt;&#x3D; N, M, Q &lt;&#x3D; 1000.</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>按照这个含义就是<br>73<br>124<br>256<br>368<br>2<br>12<br>23<br>输出<br>4<br>-1</p>
<p>和前面不同在于 求得是多个起点到多个终点的最短路径  双向问题倒是没谈</p>
<p>Floyd 算法对边的权值正负没有要求，都可以处理。</p>
<p>Floyd算法核心思想是动态规划。</p>
<p>节点1 到 节点9 的最短距离 可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成， 也可以有 节点1 到节点7的最短距离 + 节点7 到节点9的最短距离的距离组成。</p>
<p>那么这个dp就是很多选择啊</p>
<p>一dp数组  这个DP数组真的很难想啊<br>grid[i][j][k] &#x3D; m，表示 节点i 到哪个集合来求和<br>通过将大问题分解为小问题来逐步求解<br>通过限制路径的中间节点集合 [1, 2, …, k]，我们可以从小的集合开始递推，逐步扩大集合范围直到 [1, 2, …, n]<br>具体含义就是表示允许走这些节点以到达的最小距离   记住是中间节点</p>
<p>二<br>递推关系<br>在上面的分析中我们已经初步感受到了递推的关系。</p>
<p>我们分两种情况：</p>
<p>节点i 到 节点j 的最短路径经过节点k<br>节点i 到 节点j 的最短路径不经过节点k<br>对于第一种情况，grid[i][j][k] &#x3D; grid[i][k][k - 1] + grid[k][j][k - 1]</p>
<p>节点i 到 节点k 的最短距离 是不经过节点k，中间节点集合为[1…k-1]，所以 表示为grid[i][k][k - 1]</p>
<p>节点k 到 节点j 的最短距离 也是不经过节点k，中间节点集合为[1…k-1]，所以表示为 grid[k][j][k - 1]</p>
<p>第二种情况，grid[i][j][k] &#x3D; grid[i][j][k - 1]</p>
<p>如果节点i 到 节点j的最短距离 不经过节点k，那么 中间节点集合[1…k-1]，表示为 grid[i][j][k - 1]</p>
<p>因为我们是求最短路，对于这两种情况自然是取最小值。</p>
<p>即： grid[i][j][k] &#x3D; min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</p>
<p>三初始化<br>k等于其他的时候也不知道所以只能让k等于0 没有这个节点的时候开始才行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>)));  <span class="comment">// C++定义了一个三位数组，10005是因为边的最大距离是10^4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">    grid[p1][p2][<span class="number">0</span>] = val;</span><br><span class="line">    grid[p2][p1][<span class="number">0</span>] = val; <span class="comment">// 注意这里是双向图</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>本题求的是最小值，所以输入数据没有涉及到的节点的情况都应该初始为一个最大数。</p>
<p>四 遍历顺序<br>grid[i][j][k] &#x3D; min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])<br>ij k 三个变量<br>而 k 依赖于 k - 1， i 和j 的到 并不依赖与 i - 1 或者 j - 1 等等。<br>最外层遍历k 把k-1的所有情况都计算好了再遍历k</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            grid[i][j][k] = <span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>], grid[i][k][k<span class="number">-1</span>] + grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化k是0开始的 无法用上一层的结果进行计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt;<span class="built_in">grid</span>(n<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">10005</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1 &gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1][p2][<span class="number">0</span>] =val;</span><br><span class="line">        grid[p1][p2][<span class="number">0</span>] =val;<span class="comment">//双向图所以这么填入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                grid[i][j][k] =<span class="built_in">min</span>(grid[i][j][k<span class="number">-1</span>],grid[i][k][k<span class="number">-1</span>]+grid[k][j][k<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z,start,end;</span><br><span class="line">    cin &gt;&gt;z;</span><br><span class="line">    <span class="keyword">while</span>(z--)&#123;</span><br><span class="line">        cin &gt;&gt;start &gt;&gt;end;</span><br><span class="line">        <span class="keyword">if</span>(grid[start][end][n] ==<span class="number">10005</span>) cout &gt;&gt;<span class="number">-1</span>&gt;&gt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt;grid[start][end][n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化空间</span></span><br><span class="line">k 只依赖k<span class="number">-1</span> 那么我们只需要记录 grid[i][j][<span class="number">1</span>] 和 grid[i][j][<span class="number">0</span>] 就好，之后就是 grid[i][j][<span class="number">1</span>] 和 grid[i][j][<span class="number">0</span>] 交替滚动。</span><br><span class="line">所以三维数组维度不变 但是数量变成了<span class="number">2</span></span><br><span class="line">这里有难度了</span><br><span class="line"><span class="comment">//这是通过三维变换二维理解的二维</span></span><br><span class="line">这个k<span class="number">-1</span>这个对应的层级可以直接拿来就用 条件在下面说了</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是直接去理解的二维</span></span><br><span class="line">直接用k去替换j和i的位置</span><br><span class="line">本身的定义改变了变成了和k无关的东西 表示从i到j 经过k 的最小路径了 这样的话理解起来就是i到j的距离通过遍历</span><br><span class="line">经过期间的节点(特定节点) 之后最后结果就是没有节点了</span><br><span class="line">grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">这里就会想到是否会用到本层计算好的数据呢</span><br><span class="line">如果 本层刚计算好的 grid[i][k] 比上一层 （即k<span class="number">-1</span>层）计算的 grid[i][k] 小，说明确实有 i 到 k 的更短路径，那么基于 更小的 grid[i][k] 去计算 gird[i][j] 没有问题。</span><br><span class="line"></span><br><span class="line">如果 本层刚计算好的 grid[i][k] 比上一层 （即k<span class="number">-1</span>层）计算的 grid[i][k] 大， 这不可能，因为这样也不会做更新 grid[i][k]的操作</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">10005</span>));  <span class="comment">// 因为边的最大距离是10^4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;</span><br><span class="line">        grid[p1][p2] = val;</span><br><span class="line">        grid[p2][p1] = val; <span class="comment">// 注意这里是双向图</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始 floyd</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="type">int</span> z, start, end;</span><br><span class="line">    cin &gt;&gt; z;</span><br><span class="line">    <span class="keyword">while</span> (z--) &#123;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">        <span class="keyword">if</span> (grid[start][end] == <span class="number">10005</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; grid[start][end] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(n^3)<br>再说一遍适用范围：源点多 点还多 因为是数组存储 发现双向图直接反向定义就可以了 不是什么方法的使用限制</p>
<h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>题目描述</p>
<p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p>
<p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p>
<p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）</p>
<p>输入描述</p>
<p>第一行包含一个整数 n，表示测试用例的数量。</p>
<p>接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p>
<p>输出描述</p>
<p>输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p>
<p>输入示例</p>
<p>6<br>5 2 5 4<br>1 1 2 2<br>1 1 8 8<br>1 1 8 7<br>2 1 3 3<br>4 6 4 6<br>输出示例</p>
<p>2<br>4<br>6<br>5<br>1<br>0</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>广搜是个方法 可以看出最多的是什么 在新的数组位置上更新步数就行<br>就是超时了<br>A*为广搜变体</p>
<p>其实只是场景不同而已 我们在搜索最短路的时候， 如果是无权图（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）</p>
<p>如果是有权图（边有不同的权值），优先考虑 dijkstra。</p>
<p>A*使用启发式算法<br>原理上来说呢 就是在下一次队列计算的取出的时候先把存入的哪些数据进行排序 之后先计算权重高的<br>使用欧拉式启发算法：</p>
<p>新的理解还有一个补充 就是我新加入的会在一些旧的前面 所有旧的不一定能排上了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> moves[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b1, b2;</span><br><span class="line"><span class="comment">// F = G + H</span></span><br><span class="line"><span class="comment">// G = 从起点到该节点路径消耗</span></span><br><span class="line"><span class="comment">// H = 该节点到终点的预估消耗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Knight</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> g,h,f;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Kinght &amp;k) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k.f &lt;f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Knight&gt;que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Heuristic</span><span class="params">(<span class="type">const</span> Knight&amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (k.x-b1)*(k.x-b1) + (k.y-b2) *(k.y-b2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">astar</span><span class="params">(<span class="type">const</span> Kinght&amp; k)</span></span>&#123;</span><br><span class="line">    Kinght cur,next;</span><br><span class="line">    que.<span class="built_in">push</span>(k);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cur =que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur.x ==b1 &amp;&amp;cur.y ==b2)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        next.x =cur.x +dir[i][<span class="number">0</span>];</span><br><span class="line">        next.y =cur.y +dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(next.x &lt;<span class="number">1</span> || next.x &gt;<span class="number">1000</span> ||next.y &lt;<span class="number">1</span>||next.y &gt;<span class="number">1000</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!movex[next.x][next.y])&#123;</span><br><span class="line">            moves[next.x][next.y] =moves[cur.x][cur.y] <span class="number">+1</span>;</span><br><span class="line">            next.g = cur.g + <span class="number">5</span>;<span class="comment">// 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5         ext.h = Heuristic(next);</span></span><br><span class="line">                next.f = next.g + next.h;</span><br><span class="line">                que.<span class="built_in">push</span>(next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a1,a2;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin &gt;&gt;a1 &gt;&gt;a2 &gt;&gt;b1&gt;&gt;b2;<span class="comment">//b1b2没定义</span></span><br><span class="line">        <span class="built_in">memset</span>(moves,<span class="number">0</span>,<span class="built_in">sizeof</span>(moves));</span><br><span class="line">        Knight start;</span><br><span class="line">        start.x =a1;</span><br><span class="line">        start.y =a2;</span><br><span class="line">        start.g =<span class="number">0</span>;</span><br><span class="line">        start.h =<span class="built_in">Heuristic</span>(start);</span><br><span class="line">        start.f = start.g + start.h;</span><br><span class="line">        <span class="built_in">astar</span>(start);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>(); <span class="comment">// 队列清空</span></span><br><span class="line">        cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>缺点在于<br>不一定得到准确的结果 这是最大的问题<br>如果题目中，给出 多个可能的目标，然后在这多个目标中 选择最近的目标，这种 A * 就不擅长了， A 只擅长给出明确的目标 然后找到最短路径。 这是第二个问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/07/%E5%9B%BE%E8%AE%BA-2/" data-id="cm4iipakk0000b0vq3nm2a1xp" data-title="图论-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-每日一题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-12-04T10:05:36.000Z" itemprop="datePublished">2024-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2056"><a href="#2056" class="headerlink" title="2056"></a>2056</h2><p>有一个 8 x 8 的棋盘，它包含 n 个棋子（棋子包括车，后和象三种）。给你一个长度为 n 的字符串数组 pieces ，其中 pieces[i] 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 n 的二维整数数组 positions ，其中 positions[i] &#x3D; [ri, ci] 表示第 i 个棋子现在在棋盘上的位置为 (ri, ci) ，棋盘下标从 1 开始。</p>
<p>棋盘上每个棋子都可以移动 至多一次 。每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p>
<p>车可以 水平或者竖直 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1) 或者 (r, c-1) 移动。<br>后可以 水平竖直或者斜对角 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。<br>象可以 斜对角 从 (r, c) 沿着方向 (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。<br>移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 0 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。</p>
<p>请你返回 有效 移动组合的数目。</p>
<p>注意：</p>
<p>初始时，不会有两个棋子 在 同一个位置 。<br>有可能在一个移动组合中，有棋子不移动。<br>如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Move</span> &#123;</span><br><span class="line">    <span class="type">int</span> x0, y0; <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> dx, dy; <span class="comment">// 移动方向</span></span><br><span class="line">    <span class="type">int</span> step;   <span class="comment">// 移动次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; DIRS = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;; <span class="comment">// 上下左右 + 斜向</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; PIECE_DIRS = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;r&#x27;</span>, &#123;DIRS.<span class="built_in">begin</span>(), DIRS.<span class="built_in">begin</span>() + <span class="number">4</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;b&#x27;</span>, &#123;DIRS.<span class="built_in">begin</span>() + <span class="number">4</span>, DIRS.<span class="built_in">end</span>()&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;q&#x27;</span>, DIRS&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算位于 (x0,y0) 的棋子在 dirs 这些方向上的所有合法移动</span></span><br><span class="line">    <span class="function">vector&lt;Move&gt; <span class="title">generate_moves</span><span class="params">(<span class="type">int</span> x0, <span class="type">int</span> y0, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; dirs)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">8</span>;</span><br><span class="line">        vector&lt;Move&gt; moves = &#123;&#123;x0, y0, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 原地不动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [dx, dy] : dirs) &#123;</span><br><span class="line">            <span class="comment">// 往 d 方向走 1,2,3,... 步</span></span><br><span class="line">            <span class="type">int</span> x = x0 + dx, y = y0 + dy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">1</span>; <span class="number">0</span> &lt; x &amp;&amp; x &lt;= SIZE &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt;= SIZE; step++) &#123;</span><br><span class="line">                moves.<span class="built_in">emplace_back</span>(x0, y0, dx, dy, step);</span><br><span class="line">                x += dx;</span><br><span class="line">                y += dy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> moves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个移动是否合法，即不存在同一时刻两个棋子重叠的情况</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_valid</span><span class="params">(Move&amp; m1, Move&amp; m2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x1 = m<span class="number">1.</span>x0, y1 = m<span class="number">1.</span>y0;</span><br><span class="line">        <span class="type">int</span> x2 = m<span class="number">2.</span>x0, y2 = m<span class="number">2.</span>y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>(m<span class="number">1.</span>step, m<span class="number">2.</span>step); i++) &#123;</span><br><span class="line">            <span class="comment">// 每一秒走一步</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m<span class="number">1.</span>step) &#123;</span><br><span class="line">                x1 += m<span class="number">1.</span>dx;</span><br><span class="line">                y1 += m<span class="number">1.</span>dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m<span class="number">2.</span>step) &#123;</span><br><span class="line">                x2 += m<span class="number">2.</span>dx;</span><br><span class="line">                y2 += m<span class="number">2.</span>dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) &#123; <span class="comment">// 重叠</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countCombinations</span><span class="params">(vector&lt;string&gt;&amp; pieces, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pieces.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 预处理所有合法移动</span></span><br><span class="line">        vector&lt;vector&lt;Move&gt;&gt; <span class="built_in">all_moves</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            all_moves[i] = <span class="built_in">generate_moves</span>(positions[i][<span class="number">0</span>], positions[i][<span class="number">1</span>], PIECE_DIRS[pieces[i][<span class="number">0</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;Move&gt; <span class="title">path</span><span class="params">(n)</span></span>; <span class="comment">// 注意 path 的长度是固定的</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 枚举当前棋子的所有合法移动</span></span><br><span class="line">            <span class="keyword">for</span> (Move&amp; move1 : all_moves[i]) &#123;</span><br><span class="line">                <span class="comment">// 判断合法移动 move1 是否有效</span></span><br><span class="line">                <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">is_valid</span>(move1, path[j])) &#123;</span><br><span class="line">                        ok = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                    path[i] = move1; <span class="comment">// 直接覆盖，无需恢复现场</span></span><br><span class="line">                    <span class="built_in">dfs</span>(dfs, i + <span class="number">1</span>); <span class="comment">// 枚举后续棋子的所有合法移动组合</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//大循环套着小循环 无敌的存在</span></span><br></pre></td></tr></table></figure>

<h2 id="3001-捕捉黑皇后需要的最少移动次数"><a href="#3001-捕捉黑皇后需要的最少移动次数" class="headerlink" title="3001 捕捉黑皇后需要的最少移动次数"></a>3001 捕捉黑皇后需要的最少移动次数</h2><p>现有一个下标从 1 开始的 8 x 8 棋盘，上面有 3 枚棋子。</p>
<p>给你 6 个整数 a 、b 、c 、d 、e 和 f ，其中：</p>
<p>(a, b) 表示白色车的位置。<br>(c, d) 表示白色象的位置。<br>(e, f) 表示黑皇后的位置。<br>假定你只能移动白色棋子，返回捕获黑皇后所需的最少移动次数。</p>
<p>请注意：</p>
<p>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。<br>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。<br>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。<br>皇后不能移动。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>黑皇后无法移动 那么建立只需要判断移动路径上是否有黑皇后就可以了<br>这种迅速捕捉返回的问题属于回溯问题 当捕捉到有的时候count+1或者true<br>&#x2F;&#x2F; 但是有了可以挡住的问题 所以需要放弃回溯加入分类讨论算法<br>本身走的步数就很少所以直接把情况都列举出来<br>首先就是1步解决问题：<br>像和皇后在一条斜线上 中间没有车<br>车和皇后在一条行或者列上 中间没有象<br>这都是一步<br>剩下都是两步解决<br>象和皇后不在一条斜线上 ：车去解决问题 因为也不在一行上 所以两步<br>象和皇后在一条写线上：车把它挡住了 那么车移开 两步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// m 在 l 和 r 之间（写不写等号都可以）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">in_between</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(l, r) &lt; m &amp;&amp; m &lt; <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minMovesToCaptureTheQueen</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == e &amp;&amp; (c != e || !<span class="built_in">in_between</span>(b, d, f)) || <span class="comment">// 车直接攻击到皇后（同一行）</span></span><br><span class="line">            b == f &amp;&amp; (d != f || !<span class="built_in">in_between</span>(a, c, e)) || <span class="comment">// 车直接攻击到皇后（同一列）</span></span><br><span class="line">            c + d == e + f &amp;&amp; (a + b != e + f || !<span class="built_in">in_between</span>(c, a, e)) || <span class="comment">// 象直接攻击到皇后</span></span><br><span class="line">            c - d == e - f &amp;&amp; (a - b != e - f || !<span class="built_in">in_between</span>(c, a, e)))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="可以被一步捕获的棋子数"><a href="#可以被一步捕获的棋子数" class="headerlink" title="可以被一步捕获的棋子数"></a>可以被一步捕获的棋子数</h2><p>给定一个 8 x 8 的棋盘，只有一个 白色的车，用字符 ‘R’ 表示。棋盘上还可能存在白色的象 ‘B’ 以及黑色的卒 ‘p’。空方块用字符 ‘.’ 表示。</p>
<p>车可以按水平或竖直方向（上，下，左，右）移动任意个方格直到它遇到另一个棋子或棋盘的边界。如果它能够在一次移动中移动到棋子的方格，则能够 吃掉 棋子。</p>
<p>注意：车不能穿过其它棋子，比如象和卒。这意味着如果有其它棋子挡住了路径，车就不能够吃掉棋子。</p>
<p>返回白车将能 吃掉 的 卒的数量。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRookCaptures</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, st = <span class="number">0</span>, ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    st = i;</span><br><span class="line">                    ed = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">0</span>;; step++) &#123;</span><br><span class="line">                <span class="type">int</span> tx = st + step * dx[i];</span><br><span class="line">                <span class="type">int</span> ty = ed + step * dy[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">8</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">8</span> || board[tx][ty] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[tx][ty] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="骑士在棋盘上的概率"><a href="#骑士在棋盘上的概率" class="headerlink" title="骑士在棋盘上的概率"></a>骑士在棋盘上的概率</h2><p>在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。</p>
<p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格</p>
<p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p>
<p>骑士继续移动，直到它走了 k 步或离开了棋盘。</p>
<p>返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。</p>
<p>示例 1：</p>
<p>输入: n &#x3D; 3, k &#x3D; 2, row &#x3D; 0, column &#x3D; 0<br>输出: 0.0625<br>解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。<br>在每一个位置上，也有两种移动可以让骑士留在棋盘上。<br>骑士留在棋盘上的总概率是0.0625。<br>示例 2：</p>
<p>输入: n &#x3D; 1, k &#x3D; 0, row &#x3D; 0, column &#x3D; 0<br>输出: 1.00000</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这道题拿出来先分类 这种排列组合最后算概率的问题需要先把所有步数都拍出来 之后把在或者不在棋牌上的个数排出来进行除法<br>那么这是一个组合问题 一个暴力搜索组合 所以可以算作回溯问题的一种 把所有的步数列举出来 走路次数作为一个计数器 到了最后的次数之后判断是否在棋盘上<br>把不在棋盘山的个数统计出来 最后除法<br>试过了 记忆化搜索回溯没有问题能运行 那么记忆化搜索可以更换成递推</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义方向数组，骑士的8种可能移动方式</span></span><br><span class="line">    <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions = &#123;</span><br><span class="line">        &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义递归函数，带记忆化</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> r, <span class="type">int</span> c, vector&lt;vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果越界，概率为0</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= n || c &lt; <span class="number">0</span> || c &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果步数耗尽，概率为1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经计算过，直接返回缓存值</span></span><br><span class="line">        <span class="keyword">if</span> (memo[r][c][k] != <span class="number">-1.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[r][c][k];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 累加概率</span></span><br><span class="line">        <span class="type">double</span> prob = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> newRow = r + dir.first;</span><br><span class="line">            <span class="type">int</span> newCol = c + dir.second;</span><br><span class="line">            prob += <span class="built_in">dfs</span>(n, k - <span class="number">1</span>, newRow, newCol, memo) / <span class="number">8.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存结果</span></span><br><span class="line">        memo[r][c][k] = prob;</span><br><span class="line">        <span class="keyword">return</span> prob;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化三维记忆化数组，全部填充为 -1.0</span></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&gt; <span class="built_in">memo</span>(n, vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(k + <span class="number">1</span>, <span class="number">-1.0</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用递归函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n, k, row, column, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">这是反过来的dp 加了虚拟边界和概率计算 突然发现即使不反过来直接dp计算也能跑通</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> DIRS[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&gt; <span class="built_in">f</span>(k + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;(n + <span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n + <span class="number">4</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fill</span>(f[<span class="number">0</span>][i].<span class="built_in">begin</span>() + <span class="number">2</span>, f[<span class="number">0</span>][i].<span class="built_in">begin</span>() + n + <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">1</span>; step &lt;= k; step++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [dx, dy] : DIRS) &#123;</span><br><span class="line">                        f[step][i][j] += f[step - <span class="number">1</span>][i + dx][j + dy];</span><br><span class="line">                    &#125;</span><br><span class="line">                    f[step][i][j] /= <span class="number">8</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[k][row + <span class="number">2</span>][column + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="782-变为棋盘"><a href="#782-变为棋盘" class="headerlink" title="782 变为棋盘"></a>782 变为棋盘</h2><p>一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能交换任意两列或是两行的位置。</p>
<p>返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。</p>
<p>“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>
<p>示例 1:</p>
<p>输入: board &#x3D; [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]<br>输出: 2<br>解释:一种可行的变换方式如下，从左到右：<br>第一次移动交换了第一列和第二列。<br>第二次移动交换了第二行和第三行。<br>示例 2:</p>
<p>输入: board &#x3D; [[0, 1], [1, 0]]<br>输出: 0<br>解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.<br>示例 3:</p>
<p>输入: board &#x3D; [[1, 0], [1, 0]]<br>输出: -1<br>解释: 任意的变换都不能使这个输入变为合法的棋盘。</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movesToChessboard</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; first_row = board[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">first_col</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> row_cnt[<span class="number">2</span>]&#123;&#125;, col_cnt[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            row_cnt[first_row[i]]++; <span class="comment">// 统计 0 和 1 的个数</span></span><br><span class="line">            first_col[i] = board[i][<span class="number">0</span>];</span><br><span class="line">            col_cnt[first_col[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行，0 和 1 的个数之差不能超过 1</span></span><br><span class="line">        <span class="comment">// 第一列，0 和 1 的个数之差不能超过 1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(row_cnt[<span class="number">0</span>] - row_cnt[<span class="number">1</span>]) &gt; <span class="number">1</span> || <span class="built_in">abs</span>(col_cnt[<span class="number">0</span>] - col_cnt[<span class="number">1</span>]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一行和第一行比较，要么完全相同，要么完全不同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : board) &#123;</span><br><span class="line">            <span class="type">bool</span> same = row[<span class="number">0</span>] == first_row[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row[i] == first_row[i]) != same) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最小交换次数</span></span><br><span class="line">        <span class="keyword">auto</span> min_swap = [&amp;](vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> cnt[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> x0 = cnt[<span class="number">1</span>] &gt; cnt[<span class="number">0</span>]; <span class="comment">// 如果 n 是偶数，x0 是 0</span></span><br><span class="line">            <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                diff += i % <span class="number">2</span> ^ arr[i] ^ x0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n % <span class="number">2</span> ? diff / <span class="number">2</span> : <span class="built_in">min</span>(diff, n - diff) / <span class="number">2</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min_swap</span>(first_row, row_cnt) + <span class="built_in">min_swap</span>(first_col, col_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1812-判断国际象棋的颜色"><a href="#1812-判断国际象棋的颜色" class="headerlink" title="1812 判断国际象棋的颜色"></a>1812 判断国际象棋的颜色</h2><p>给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。</p>
<p>如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。</p>
<p>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>碰运气</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">squareIsWhite</span><span class="params">(string coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((coordinates[<span class="number">0</span>] ) + (coordinates[<span class="number">1</span>])) %<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="935骑士拨号器"><a href="#935骑士拨号器" class="headerlink" title="935骑士拨号器"></a>935骑士拨号器</h2><p>象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。</p>
<p>象棋骑士可能的移动方式如下图所示:</p>
<p>我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。</p>
<p>给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。</p>
<p>你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。</p>
<p>因为答案可能很大，所以输出答案模 109 + 7.</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>传统的记忆化回溯</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; NEXT[<span class="number">10</span>] = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> memo[<span class="number">5000</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : NEXT[j]) &#123;</span><br><span class="line">        res = (res + <span class="built_in">dfs</span>(i - <span class="number">1</span>, k)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(n - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态机记忆法</span></span><br><span class="line">把不同的数分成不同的状态 最后计算不同状态能得到的步数 再合起来</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; NEXT[<span class="number">10</span>] = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> memo[<span class="number">5000</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>&amp; res = memo[i][j]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : NEXT[j]) &#123;</span><br><span class="line">        res = (res + <span class="built_in">dfs</span>(i - <span class="number">1</span>, k)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(n - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改成dp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MX = <span class="number">5000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MX][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数，初始化 f 数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">2</span>] = f[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MX; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = (f[i - <span class="number">1</span>][<span class="number">1</span>] + f[i - <span class="number">1</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">2</span> % MOD;</span><br><span class="line">        f[i][<span class="number">2</span>] = (f[i - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">2</span> + f[i - <span class="number">1</span>][<span class="number">3</span>]) % MOD;</span><br><span class="line">        f[i][<span class="number">3</span>] = f[i - <span class="number">1</span>][<span class="number">2</span>] * <span class="number">2</span> % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">knightDialer</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里调用 init 函数进行初始化</span></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (f[n - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">4</span> + f[n - <span class="number">1</span>][<span class="number">1</span>] * <span class="number">2</span> +</span><br><span class="line">                f[n - <span class="number">1</span>][<span class="number">2</span>] * <span class="number">2</span> + f[n - <span class="number">1</span>][<span class="number">3</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2931-购买物品的最大开销"><a href="#2931-购买物品的最大开销" class="headerlink" title="2931. 购买物品的最大开销"></a>2931. 购买物品的最大开销</h2><p>给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 &lt;&#x3D; j &lt; n - 1 都有 values[i][j] &gt;&#x3D; values[i][j + 1] 。</p>
<p>每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：</p>
<p>选择商店 i 。<br>购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。<br>注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。</p>
<p>请你返回购买所有 m * n 件物品需要的 最大开销 。</p>
<p>示例 1：</p>
<p>输入：values &#x3D; [[8,5,2],[6,4,1],[9,7,3]]<br>输出：285<br>解释：第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 &#x3D; 1 。<br>第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 &#x3D; 4 。<br>第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 &#x3D; 9 。<br>第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 &#x3D; 16 。<br>第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 &#x3D; 25 。<br>第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 &#x3D; 36 。<br>第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 &#x3D; 49 。<br>第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 &#x3D; 64 。<br>第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 &#x3D; 81 。<br>所以总开销为 285 。<br>285 是购买所有 m * n 件物品的最大总开销。<br>示例 2：</p>
<p>输入：values &#x3D; [[10,8,6,4,2],[9,7,5,3,2]]<br>输出：386<br>解释：第一天，从商店 0 购买物品 4 ，开销为 values[0][4] * 1 &#x3D; 2 。<br>第二天，从商店 1 购买物品 4 ，开销为 values[1][4] * 2 &#x3D; 4 。<br>第三天，从商店 1 购买物品 3 ，开销为 values[1][3] * 3 &#x3D; 9 。<br>第四天，从商店 0 购买物品 3 ，开销为 values[0][3] * 4 &#x3D; 16 。<br>第五天，从商店 1 购买物品 2 ，开销为 values[1][2] * 5 &#x3D; 25 。<br>第六天，从商店 0 购买物品 2 ，开销为 values[0][2] * 6 &#x3D; 36 。<br>第七天，从商店 1 购买物品 1 ，开销为 values[1][1] * 7 &#x3D; 49 。<br>第八天，从商店 0 购买物品 1 ，开销为 values[0][1] * 8 &#x3D; 64 。<br>第九天，从商店 1 购买物品 0 ，开销为 values[1][0] * 9 &#x3D; 81 。<br>第十天，从商店 0 购买物品 0 ，开销为 values[0][0] * 10 &#x3D; 100 。<br>所以总开销为 386 。<br>386 是购买所有 m * n 件物品的最大总开销。</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>首先拿过来发现这是一个选择问题啊 选择之前没选过的才行 那么就是贪心 直接选择这里面价值最小的完了之后开始求和就可以了<br>怎么进行排序呢 合并数组进行快排吗 不对 本身就是从大到小了 但是之间的界限没定下来啊<br>定义一个数组表示每一行没有使用的最小值 这不就是优先队列吗 把最小的直接拿出来的同时把<br>最小的这一行的剩余一个加入进去 如果没了就跳过 直到所有的数都计算过来 用计数器进行计数 或者直接没了就行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//优先队列灭有问题 用的确实是pair 把最后一行数先掉进去</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSpending</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = values.<span class="built_in">size</span>(), n = values[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">          pq.<span class="built_in">push</span>(&#123;values[i].<span class="built_in">back</span>(), i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= m * n; d++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [v, i] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans += (<span class="type">long</span> <span class="type">long</span>) v * d;</span><br><span class="line">            values[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (!values[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(values[i].<span class="built_in">back</span>(), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3264-K次乘运算后的最终数组"><a href="#3264-K次乘运算后的最终数组" class="headerlink" title="3264.K次乘运算后的最终数组"></a>3264.K次乘运算后的最终数组</h2><p>给你一个整数数组 nums ，一个整数 k  和一个整数 multiplier 。</p>
<p>你需要对 nums 执行 k 次操作，每次操作中：</p>
<p>找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个。<br>将 x 替换为 x * multiplier 。<br>请你返回执行完 k 次乘运算之后，最终的 nums 数组。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,1,3,5,6], k &#x3D; 5, multiplier &#x3D; 2</p>
<p>输出：[8,4,6,5,6]</p>
<p>解释：</p>
<p>操作	结果<br>1 次操作后	[2, 2, 3, 5, 6]<br>2 次操作后	[4, 2, 3, 5, 6]<br>3 次操作后	[4, 4, 3, 5, 6]<br>4 次操作后	[4, 4, 6, 5, 6]<br>5 次操作后	[8, 4, 6, 5, 6]<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2], k &#x3D; 3, multiplier &#x3D; 4</p>
<p>输出：[16,8]</p>
<p>解释：</p>
<p>操作	结果<br>1 次操作后	[4, 2]<br>2 次操作后	[4, 8]<br>3 次操作后	[16, 8]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; k &lt;&#x3D; 10<br>1 &lt;&#x3D; multiplier &lt;&#x3D; 5</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>直接每次找到最小的赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_min</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> result =INT_MAX;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a =<span class="number">0</span>;a&lt;nums.<span class="built_in">size</span>();a++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[a] &lt; result)&#123;</span><br><span class="line">                result =nums[a];</span><br><span class="line">                i =a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getFinalState</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> multiplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find_min</span>(nums);</span><br><span class="line">            nums[a] = multiplier * nums[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1338-数组大小减半"><a href="#1338-数组大小减半" class="headerlink" title="1338 数组大小减半"></a>1338 数组大小减半</h2><p>给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。</p>
<p>返回 至少 能删除数组中的一半整数的整数集合的最小大小。</p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [3,3,3,3,5,5,5,2,2,7]<br>输出：2<br>解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。<br>大小为 2 的可行集合有 {3,5},{3,2},{5,2}。<br>选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。<br>示例 2：</p>
<p>输入：arr &#x3D; [7,7,7,7,7,7]<br>输出：1<br>解释：我们只能选择集合 {7}，结果数组为空。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>arr.length 为偶数<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 105</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>贪心  找最大的先删去在进行比较<br>这种字符在字符串出现次数的排序可以用map<br>之后把map后面的数据都相加做 while循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSetSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;  <span class="comment">// 用于存储每个元素的出现次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计 arr 中每个元素出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">            freq[x]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将频率信息提取到一个新的 vector 中</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, c] : freq) &#123;</span><br><span class="line">            cnt.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ranges::sort 排序，按频率从大到小排序</span></span><br><span class="line">        ranges::<span class="built_in">sort</span>(cnt, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;  <span class="comment">// 用来记录当前已删除元素的总数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            s += cnt[i];  <span class="comment">// 增加当前最大频率的元素数</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= arr.<span class="built_in">size</span>() / <span class="number">2</span>) &#123;  <span class="comment">// 当已删除的元素数大于等于原数组的一半时</span></span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回最小集合的大小，即删除的元素个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最近的房间"><a href="#最近的房间" class="headerlink" title="最近的房间"></a>最近的房间</h2><p>一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] &#x3D; [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。</p>
<p>同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] &#x3D; [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：</p>
<p>房间的面积 至少 为 minSizej ，且<br>abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。<br>如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。</p>
<p>请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。</p>
<p>示例 1：</p>
<p>输入：rooms &#x3D; [[2,2],[1,2],[3,2]], queries &#x3D; [[3,1],[3,3],[5,2]]<br>输出：[3,-1,3]<br>解释：查询的答案如下：<br>查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) &#x3D; 0 ，所以答案为 3 。<br>查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。<br>查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) &#x3D; 2 ，所以答案为 3 。<br>示例 2：</p>
<p>输入：rooms &#x3D; [[1,4],[2,3],[3,5],[4,1],[5,2]], queries &#x3D; [[2,3],[2,4],[2,5]]<br>输出：[2,1,3]<br>解释：查询的答案如下：<br>查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) &#x3D; 0 ，所以答案为 2 。<br>查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。<br>查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。</p>
<p>提示：</p>
<p>n &#x3D;&#x3D; rooms.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>k &#x3D;&#x3D; queries.length<br>1 &lt;&#x3D; k &lt;&#x3D; 104<br>1 &lt;&#x3D; roomIdi, preferredj &lt;&#x3D; 107<br>1 &lt;&#x3D; sizei, minSizej &lt;&#x3D; 107</p>
<h2 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h2><h2 id="3291-形成目标字符串的最少字符串数-1"><a href="#3291-形成目标字符串的最少字符串数-1" class="headerlink" title="3291 形成目标字符串的最少字符串数 1"></a>3291 形成目标字符串的最少字符串数 1</h2><p>给你一个字符串数组 words 和一个字符串 target。</p>
<p>如果字符串 x 是 words 中 任意 字符串的<br>前缀<br>，则认为 x 是一个 有效 字符串。</p>
<p>现计划通过 连接 有效字符串形成 target ，请你计算并返回需要连接的 最少 字符串数量。如果无法通过这种方式形成 target，则返回 -1。</p>
<p>示例 1：</p>
<p>输入： words &#x3D; [“abc”,”aaaaa”,”bcdef”], target &#x3D; “aabcdabc”</p>
<p>输出： 3</p>
<p>解释：</p>
<p>target 字符串可以通过连接以下有效字符串形成：</p>
<p>words[1] 的长度为 2 的前缀，即 “aa”。<br>words[2] 的长度为 3 的前缀，即 “bcd”。<br>words[0] 的长度为 3 的前缀，即 “abc”。<br>示例 2：</p>
<p>输入： words &#x3D; [“abababab”,”ab”], target &#x3D; “ababaababa”</p>
<p>输出： 2</p>
<p>解释：</p>
<p>target 字符串可以通过连接以下有效字符串形成：</p>
<p>words[0] 的长度为 5 的前缀，即 “ababa”。<br>words[0] 的长度为 5 的前缀，即 “ababa”。<br>示例 3：</p>
<p>输入： words &#x3D; [“abcdef”], target &#x3D; “xyz”</p>
<p>输出： -1</p>
<p>提示：</p>
<p>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 5 * 103<br>输入确保 sum(words[i].length) &lt;&#x3D; 105。<br>words[i] 只包含小写英文字母。<br>1 &lt;&#x3D; target.length &lt;&#x3D; 5 * 103<br>target 只包含小写英文字母。</p>
<h2 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h2><p>这种题目按道理来说就是对于一个固定大小的字符串 多种字符串是否在其中进行匹配的问题<br>首先就是因为只有前缀就可以 那么字典树的结构依然能发挥作用实现匹配 同时因为是多个字符串 所以可以使用ac状态机进行匹配</p>
<p>有个注意的问题就是 即使我们进行了匹配 这个时候要求的仅仅是前缀 那么字典树的构建本身不需要再有一个flag表示是否存在这个最终节点了 </p>
<p>要求的问题是最少的字符串数量 那么如果我知道每个字符对应的前缀最长是哪个 加上之后的</p>
<p>其实这里对于dp的状态我并没有搞明白 为什么就是最长的就可以  我的初步理解就是<br>对于一个非递减序列 那么他和前面的一样的越多越好 所以用最长的就能解让前缀尽量很长 这样对于从零开始累计加的这个数就会很小<br>我的疑问就是这个是全局规划问题吗 看着很像贪心 但是从头到尾都是是使用一个状态转移方程推导处理的所以叫做dp也没毛病</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node* son[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    Node* fail; </span><br><span class="line">    <span class="type">int</span> len; </span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> len) : <span class="built_in">len</span>(len) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AhoCorasick</span> &#123;</span><br><span class="line">    Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> b : s) &#123;</span><br><span class="line">            b -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;son[b] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur-&gt;son[b] = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;len + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;son[b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root-&gt;fail = root;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; son : root-&gt;son) &#123;</span><br><span class="line">            <span class="keyword">if</span> (son == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                son = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                son-&gt;fail = root; <span class="comment">// 第一层的失配指针，都指向根节点 ∅</span></span><br><span class="line">                q.<span class="built_in">push</span>(son);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; son = cur-&gt;son[i];</span><br><span class="line">                <span class="keyword">if</span> (son == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 虚拟子节点 cur.son[i]，和 cur.fail.son[i] 是同一个</span></span><br><span class="line">                    <span class="comment">// 方便失配时直接跳到下一个可能匹配的位置（但不一定是某个 words[k] 的最后一个字母）</span></span><br><span class="line">                    son = cur-&gt;fail-&gt;son[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                son-&gt;fail = cur-&gt;fail-&gt;son[i]; <span class="comment">// 计算失配位置</span></span><br><span class="line">                q.<span class="built_in">push</span>(son);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minValidStrings</span><span class="params">(vector&lt;string&gt;&amp; words, string target)</span> </span>&#123;</span><br><span class="line">        AhoCorasick ac;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; w : words) &#123;</span><br><span class="line">            ac.<span class="built_in">put</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">        ac.<span class="built_in">build_fail</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = target.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = ac.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果没有匹配相当于移动到 fail 的 son[target[i]-&#x27;a&#x27;]</span></span><br><span class="line">            cur = cur-&gt;son[target[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="comment">// 没有任何字符串的前缀与 target[..i] 的后缀匹配</span></span><br><span class="line">            <span class="keyword">if</span> (cur == ac.root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i + <span class="number">1</span>] = f[i + <span class="number">1</span> - cur-&gt;len] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2545-排序-通过固定投影进行排序"><a href="#2545-排序-通过固定投影进行排序" class="headerlink" title="2545 排序 通过固定投影进行排序"></a>2545 排序 通过固定投影进行排序</h2><p>ranges：sort</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ranges :: <span class="built_in">sort</span>(score,&#123;这里默认为空从小到达&#125;,[&amp;](<span class="keyword">auto</span>&amp; row)&#123;<span class="keyword">return</span> -row[k]&#125;);</span><br><span class="line"><span class="comment">//或者不默认 按升序走</span></span><br><span class="line">std::ranges::<span class="built_in">sort</span>(score, std::greater&lt;&gt;(), [k](<span class="type">const</span> <span class="keyword">auto</span>&amp; row) &#123; <span class="keyword">return</span> row[k]; &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="合并k个升序列表"><a href="#合并k个升序列表" class="headerlink" title="合并k个升序列表"></a>合并k个升序列表</h2><p>这个主要问题在这里<br>使用匿名函数更改排序需要关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> ListNode* a, <span class="type">const</span> ListNode* b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">// 最小堆</span></span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> head: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="组织一个最小栈"><a href="#组织一个最小栈" class="headerlink" title="组织一个最小栈"></a>组织一个最小栈</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p>
<h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><p>通过</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" data-id="cm4ckzpei00014gvq4siw57l7" data-title="每日一题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-图论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/01/%E5%9B%BE%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2024-12-01T13:28:34.000Z" itemprop="datePublished">2024-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/01/%E5%9B%BE%E8%AE%BA/">图论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="两种存储写法"><a href="#两种存储写法" class="headerlink" title="两种存储写法"></a>两种存储写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="comment">// 使用邻接矩阵 ，1 表示 节点s 指向 节点t</span></span><br><span class="line">    graph[s][t] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">    graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度搜索模板"><a href="#深度搜索模板" class="headerlink" title="深度搜索模板"></a>深度搜索模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="所有可达路径"><a href="#所有可达路径" class="headerlink" title="所有可达路径"></a>所有可达路径</h2><p>【题目描述】</p>
<p>给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。</p>
<p>【输入描述】</p>
<p>第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边</p>
<p>后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径</p>
<p>【输出描述】</p>
<p>输出所有的可达路径，路径中所有节点的后面跟一个空格，每条路径独占一行，存在多条路径，路径输出的顺序可任意。</p>
<p>如果不存在任何一条路径，则输出 -1。</p>
<p>注意输出的序列中，最后一个节点后面没有空格！ 例如正确的答案是 1 3 5,而不是 1 3 5， 5后面没有空格！</p>
<p>【输入示例】</p>
<p>5 5<br>1 3<br>3 5<br>1 2<br>2 4<br>4 5<br>【输出示例】</p>
<p>1 3 5<br>1 2 4 5  </p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>每到一个新的节点就遍历所有节点进入下一个节点 当节点够了就放变量里存储起来<br>同时在每次进入新的节点之后回来要回溯</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 1节点到终点的路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前遍历的节点x 到达节点n </span></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历节点x链接的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> (graph[x][i] == <span class="number">1</span>) &#123; <span class="comment">// 找到 x链接的节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, i, n); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span></span><br><span class="line">        graph[s][t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 无论什么路径已经是从0节点出发</span></span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, n); <span class="comment">// 开始遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pa.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pa[pa.<span class="built_in">size</span>() - <span class="number">1</span>]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph,<span class="type">int</span> x,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:graph[x])&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(graph,i,n);</span><br><span class="line">        path.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">graph</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grapt,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">size</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;pa:result)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cout&lt;&lt;pa[i]&lt;&lt;<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;pa[pa.<span class="built_in">size</span>()<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>使用队列<br>注意坐标越界的条件grid.size()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">nt dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p>
<p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p>
<p>输出描述：</p>
<p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p>
<p>输入示例：</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>看了题解之后发现和上一个题目一样 如果用深度搜索就是把搜索的每个位置都记录下来 所以新的陆地一定没有被记录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nextx&lt;<span class="number">0</span> || nexty &gt;= grid.<span class="built_in">size</span>() || nexty&lt;<span class="number">0</span> || nexty&gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] ==<span class="number">1</span>)&#123;</span><br><span class="line">            visited[nextx][nexty] =<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid,visited,nextx,nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                visited[i][j] =<span class="literal">true</span>;</span><br><span class="line">                result++;</span><br><span class="line">                <span class="built_in">dfs</span>(grid,visited,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;result &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广搜版解法 加了个队列同时标记边上的点<br>如果从队列拿出节点，再去标记这个节点走过，就会发生高复杂度的结果，会导致很多节点重复加入队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x,y&#125;);<span class="comment">//这里没写对</span></span><br><span class="line">    visited[x][y] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cur =que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nextx&gt;=grid.<span class="built_in">size</span>() || nexty &lt;<span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>())&#123;<span class="comment">//这也没写对</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx,nexty&#125;);</span><br><span class="line">                visited[nextx][nexty] =<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;<span class="built_in">visited</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++&gt;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                result ++;</span><br><span class="line">                <span class="built_in">bfs</span>(grid,visited,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;result&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h2><p>题目描述</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述</p>
<p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p>
<p>输入示例</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1<br>输出示例</p>
<p>4</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>和上面一摸一样 区别就是加了个每次进行函数使用的时候都要比较当前处理的和以前处理的的大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp;visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x+ dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty =y +dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> ||nexty &gt;= grid.<span class="built_in">size</span>() || nexty&lt;<span class="number">0</span> || nexty &gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>())<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//忘了这个了</span></span><br><span class="line">            visited[next][nexty] =<span class="literal">true</span>;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="built_in">dfs</span>(grid,visited,nextx,nexty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt;grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] ==<span class="number">1</span>)&#123;</span><br><span class="line">                count =<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid,visited,i,j);</span><br><span class="line">                result =<span class="built_in">max</span>(result,count)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs 这个广搜的队列改成Int格式了</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> dirp[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;visited,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(x);</span><br><span class="line">    que.<span class="built_in">push</span>(y);</span><br><span class="line">    visited[x][y] =<span class="literal">true</span>;</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> xx = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> yy =que.<span class="built_in">front</span>()；</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = xx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = yy + die[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nexty &gt;=grid.<span class="built_in">size</span>() || nexty &lt;<span class="number">0</span> ||nexty &gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] ==<span class="number">1</span>)&#123;</span><br><span class="line">                    visited[nextx][nexty] =<span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(nextx);</span><br><span class="line">                    que.<span class="built_in">push</span>(nexty);</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, visited, i, j); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                    result = <span class="built_in">max</span>(result, count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="孤岛的总面积"><a href="#孤岛的总面积" class="headerlink" title="孤岛的总面积"></a>孤岛的总面积</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>
<p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p>
<p>输出描述</p>
<p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p>
<p>输入示例</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>把每次计算最大的改成个加法计数 同时题目要去不能靠着边<br>所以在深度优先搜多里面的时候进行边缘遍历同时把1都变成0<br>之后再把已经去掉边缘的部分都遍历一遍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    grid[x][y] =<span class="number">0</span>;<span class="comment">//处理</span></span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() ||nexty &lt;<span class="number">0</span> || nexty &gt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[nextx][nexty] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid,nextx,nexty);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//?</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][<span class="number">0</span>] == <span class="number">1</span>)<span class="built_in">dfs</span>(grid,i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(grid[i][m<span class="number">-1</span>] ==<span class="number">1</span>)<span class="built_in">dfs</span>(grid,i,m<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][j] == <span class="number">1</span>)<span class="built_in">dfs</span>(grid,<span class="number">0</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(grid[n<span class="number">-1</span>][j] == <span class="number">1</span>) <span class="built_in">dfs</span>(gris,n<span class="number">-1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] ==<span class="number">1</span>)<span class="built_in">dfs</span>(grid,i,j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;count &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> count =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid, <span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;que;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    count ++;</span><br><span class="line">    grid[x][y] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> nextx = curx +dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury +dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextx &lt;<span class="number">0</span> || nextx &gt;=grid.<span class="built_in">size</span>() || nexty &lt;<span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(grid[nextx][nexty] == <span class="number">1</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx,nexty&#125;);</span><br><span class="line">                count ++;<span class="comment">//注意</span></span><br><span class="line">                grid[nextx][nexty] = <span class="number">0</span>;<span class="comment">//处理</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &lt;&lt;n &lt;&lt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">grid</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;i&lt;m;j++)&#123;</span><br><span class="line">            cin &gt;&gt;grid[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (grid[i][m - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从上边和下边 向中间遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (grid[n - <span class="number">1</span>][j] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, n - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="built_in">bfs</span>(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="沉没孤岛"><a href="#沉没孤岛" class="headerlink" title="沉没孤岛"></a>沉没孤岛</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>
<p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p>
<p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述</p>
<p>输出将孤岛“沉没”之后的岛屿矩阵。</p>
<p>输入示例：</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1<br>输出示例：</p>
<p>1 1 0 0 0<br>1 1 0 0 0<br>0 0 0 0 0<br>0 0 0 1 1</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>太机智了 先把所有边缘的变成2，   后续直接遍历判断再把按照条件中间的变成0 孤岛变成1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// 保存四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 向四个方向遍历</span></span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 超过边界</span></span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 不符合条件，不继续遍历</span></span><br><span class="line">        <span class="keyword">if</span> (grid[nextx][nexty] == <span class="number">0</span> || grid[nextx][nexty] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span> (grid, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：</span></span><br><span class="line">    <span class="comment">// 从左侧边，和右侧边 向中间遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (grid[i][m - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上边和下边 向中间遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, <span class="number">0</span>, j);</span><br><span class="line">        <span class="keyword">if</span> (grid[n - <span class="number">1</span>][j] == <span class="number">1</span>) <span class="built_in">dfs</span>(grid, n - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤二、步骤三</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cout &lt;&lt; grid[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="水流问题"><a href="#水流问题" class="headerlink" title="水流问题"></a>水流问题</h2><p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p>
<p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p>
<p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p>
<p>输出描述：</p>
<p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p>
<p>输入示例：</p>
<p>5 5<br>1 3 1 2 4<br>1 2 1 3 2<br>2 4 7 2 1<br>4 5 6 1 1<br>1 4 1 2 1<br>输出示例：</p>
<p>0 4<br>1 3<br>2 2<br>3 0<br>3 1<br>3 2<br>4 0<br>4 1</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>为了复杂度问题 逆向解决</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] &gt; grid[nextx][nexty]) <span class="keyword">continue</span>; <span class="comment">// 注意：这里是从低向高遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span> (grid, visited, nextx, nexty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">firstBorder</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">secondBorder</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最上和最下行的节点出发，向高处遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span> (grid, firstBorder, i, <span class="number">0</span>); <span class="comment">// 遍历最左列，接触第一组边界</span></span><br><span class="line">        <span class="built_in">dfs</span> (grid, secondBorder, i, m - <span class="number">1</span>); <span class="comment">// 遍历最右列，接触第二组边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最左和最右列的节点出发，向高处遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span> (grid, firstBorder, <span class="number">0</span>, j); <span class="comment">// 遍历最上行，接触第一组边界</span></span><br><span class="line">        <span class="built_in">dfs</span> (grid, secondBorder, n - <span class="number">1</span>, j); <span class="comment">// 遍历最下行，接触第二组边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span></span><br><span class="line">            <span class="keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造最大岛屿"><a href="#建造最大岛屿" class="headerlink" title="建造最大岛屿"></a>建造最大岛屿</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p>
<p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述：</p>
<p>输出一个整数，表示最大的岛屿面积。</p>
<p>输入示例：</p>
<p>4 5<br>1 1 0 0 0<br>1 1 0 0 0<br>0 0 1 0 0<br>0 0 0 1 1<br>输出示例</p>
<p>6</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>首先给是1的陆地打上标签 之后再遍历所有为0的数 同时看和没和不同的陆地相互联系<br>这里需要加一个map来存储每一块的陆地本身含有的面积 加上一个set来再每次遍历的时候看有没有不同的标签标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> mark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[x][y] || grid[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 终止条件：访问过的节点 或者 遇到海水</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 标记访问过</span></span><br><span class="line">    grid[x][y] = mark; <span class="comment">// 给陆地标记新标签</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= n || nexty &lt; <span class="number">0</span> || nexty &gt;= m) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, visited, nextx, nexty, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>)); <span class="comment">// 标记访问过的点</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; gridNum;</span><br><span class="line">    <span class="type">int</span> mark = <span class="number">2</span>; <span class="comment">// 记录每个岛屿的编号</span></span><br><span class="line">    <span class="type">bool</span> isAllGrid = <span class="literal">true</span>; <span class="comment">// 标记是否整个地图都是陆地</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) isAllGrid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, visited, i, j, mark); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                gridNum[mark] = count; <span class="comment">// 记录每一个岛屿的面积</span></span><br><span class="line">                mark++; <span class="comment">// 记录下一个岛屿编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAllGrid) &#123;</span><br><span class="line">        cout &lt;&lt; n * m &lt;&lt; endl; <span class="comment">// 如果都是陆地，返回全面积</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 记录最后结果</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; visitedGrid; <span class="comment">// 标记访问过的岛屿</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            count = <span class="number">1</span>; <span class="comment">// 记录连接之后的岛屿数量</span></span><br><span class="line">            visitedGrid.<span class="built_in">clear</span>(); <span class="comment">// 每次使用时，清空</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;<span class="comment">//上下左右观察</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> neari = i + dir[k][<span class="number">1</span>]; <span class="comment">// 计算相邻坐标</span></span><br><span class="line">                    <span class="type">int</span> nearj = j + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (neari &lt; <span class="number">0</span> || neari &gt;= n || nearj &lt; <span class="number">0</span> || nearj &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visitedGrid.<span class="built_in">count</span>(grid[neari][nearj])) <span class="keyword">continue</span>; <span class="comment">// 添加过的岛屿不要重复添加</span></span><br><span class="line">                    <span class="comment">// 把相邻四面的岛屿数量加起来</span></span><br><span class="line">                    count += gridNum[grid[neari][nearj]];</span><br><span class="line">                    visitedGrid.<span class="built_in">insert</span>(grid[neari][nearj]); <span class="comment">// 标记该岛屿已经添加过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串接龙"><a href="#字符串接龙" class="headerlink" title="字符串接龙"></a>字符串接龙</h2><p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：</p>
<p>序列中第一个字符串是 beginStr。</p>
<p>序列中最后一个字符串是 endStr。</p>
<p>每次转换只能改变一个字符。</p>
<p>转换过程中的中间字符串必须是字典 strList 中的字符串。</p>
<p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p>
<p>输入描述</p>
<p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。</p>
<p>输出描述</p>
<p>输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。</p>
<p>输入示例</p>
<p>6<br>abc def<br>efc<br>dbc<br>ebc<br>dec<br>dfc<br>yhn<br>输出示例</p>
<p>4</p>
<p>提示信息</p>
<p>从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4</p>
<p>数据范围：</p>
<p>2 &lt;&#x3D; N &lt;&#x3D; 500</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>这道题也是看题解做出来的<br>这道题属于图论的原因是每个新的节点都可能和其他节点有连接 之后在加上这是一个无向图<br>因为无向图的原因需要加上一个记录节点的表防止进入死循环<br>每一个字节都需要遍历24个字母来看有没有节点变化和它相等用作新的节点<br>这道题要求最小的路程 那么就是说可以当作bfs来解决问题这样第一个和最后相等的直接返回路程一定是最短的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string beginStr，endStr，str</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_set&lt;string&gt; strSet;<span class="comment">//用作存储输入字符串的</span></span><br><span class="line">    cin &gt;&gt; beginStr&gt;&gt; endStr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt;str;</span><br><span class="line">        strSet.<span class="built_in">insert</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; visitedMap;<span class="comment">//选择的字符串 从开始到达当前字符串走过的路程</span></span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(beginStr);</span><br><span class="line">    visitMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(beginStr,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        string word =que.<span class="built_in">frong</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> path = visitMap[word];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string newWord = word;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line">                newWord[i] = <span class="string">&#x27;a&#x27;</span> + j;<span class="comment">//全都换一遍</span></span><br><span class="line">                <span class="keyword">if</span>(newWord == endStr)&#123;</span><br><span class="line">                    cout &lt;&lt; path <span class="number">+1</span> &lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(strStr.<span class="built_in">find</span>(newWord) != strSet.<span class="built_in">end</span>() &amp;&amp; visitedMap.<span class="built_in">find</span>() ==  visitMap.<span class="built_in">end</span>())&#123;<span class="comment">//为了不陷入死循环</span></span><br><span class="line">                    visitMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(newWord,path + <span class="number">1</span>));</span><br><span class="line">                    que.<span class="built_in">push</span>(newWord);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有向图的完全可达性"><a href="#有向图的完全可达性" class="headerlink" title="有向图的完全可达性"></a>有向图的完全可达性</h2><p>【题目描述】</p>
<p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p>
<p>【输出描述】</p>
<p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p>
<p>【输入示例】</p>
<p>4 4<br>1 2<br>2 1<br>1 3<br>2 4</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>这是我第一次接触有向图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;list&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> key, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[key]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[key] = <span class="literal">true</span>;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; keys = graph[key];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys) &#123;</span><br><span class="line">        <span class="comment">// 深度优先搜索遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, key, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span></span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span></span><br><span class="line">        graph[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">1</span>, visited);</span><br><span class="line">    <span class="comment">//检查是否都访问到了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h2><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p>
<p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>输出描述</p>
<p>输出一个整数，表示岛屿的周长。</p>
<p>输入示例</p>
<p>5 5<br>0 0 0 0 0<br>0 1 0 1 0<br>0 1 1 1 0<br>0 1 1 1 0<br>0 0 0 0 0</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>这道题和搜索没有关系 分类讨论即可<br>遍历每一个边 如果新的地方有水则是一条边 或者到了边界也是一条边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;       <span class="comment">// 上下左右四个方向</span></span><br><span class="line">                    <span class="type">int</span> x = i + direction[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> y = j + direction[k][<span class="number">1</span>];    <span class="comment">// 计算周边坐标x,y</span></span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span>                       <span class="comment">// x在边界上</span></span><br><span class="line">                            || x &gt;= grid.<span class="built_in">size</span>()     <span class="comment">// x在边界上</span></span><br><span class="line">                            || y &lt; <span class="number">0</span>                <span class="comment">// y在边界上</span></span><br><span class="line">                            || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()  <span class="comment">// y在边界上</span></span><br><span class="line">                            || grid[x][y] == <span class="number">0</span>) &#123;   <span class="comment">// x,y位置是水域</span></span><br><span class="line">                        result++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。<br>将两个元素添加到一个集合中。<br>判断两个元素在不在同一个集合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始设定</span></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向</span></span><br><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找根节点</span></span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="comment">//直接让字节点指向接住根节点  结果没有变化 但是让指向变成了直接指向</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是一个根</span></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总体模板</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个<br>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上<br>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</p>
<p>另外一种表示 按秩合并</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rank = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">1</span>); <span class="comment">// 初始每棵树的高度都为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>; <span class="comment">// 也可以不写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : <span class="built_in">find</span>(father[u]);<span class="comment">// 注意这里不做路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="comment">// rank小的树合入到rank大的树</span></span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找存在的路径"><a href="#寻找存在的路径" class="headerlink" title="寻找存在的路径"></a>寻找存在的路径</h2><p>题目描述</p>
<p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p>
<p>你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p>
<p>输入描述</p>
<p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p>
<p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。</p>
<p>最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p>
<p>输出描述</p>
<p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p>
<p>输入示例</p>
<p>5 4<br>1 2<br>1 3<br>2 4<br>3 4<br>1 4<br>输出示例</p>
<p>1</p>
<h3 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h3><p>并查集可以解决什么问题呢？</p>
<p>主要就是集合问题，两个节点在不在一个集合，也可以将两个节点添加到一个集合中。<br>照抄一遍模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n =<span class="number">1000</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        father[i] =i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u:father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//v-&gt;u</span></span><br><span class="line">    u =<span class="built_in">find</span>(u);</span><br><span class="line">    v =<span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体使用操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 节点数量</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">101</span>, <span class="number">0</span>); <span class="comment">// 按照节点大小定义数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s, t, source, destination;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">join</span>(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; source &gt;&gt; destination;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSame</span>(source, destination)) cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冗余操作"><a href="#冗余操作" class="headerlink" title="冗余操作"></a>冗余操作</h2><p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图（其实就是一个线形图）<br>现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图<br>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p>
<p>输入描述</p>
<p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p>
<p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。</p>
<p>输出描述</p>
<p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p>
<p>输入示例</p>
<p>3<br>1 2<br>2 3<br>1 3<br>输出示例</p>
<p>1 3</p>
<h3 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h3><p>重点还是思路 他想变成使得结果图是一个有着N个节点的树（即：只有一个根节点）。<br>所以就是当有同一个根节点的时候不能建立连接了 要不就成为环路了<br>那么就遍历所有的边 如果之前的边有相联的关系 那么就是要输出这个边 如果没有就加入这个边</p>
<p>这道题在我看来没有很好的和并查集进行符合 但是并查集因为可以做到查看是否在一个集合中所有可以通过这个并查集来判断这个边该不该存在 如果在一个集合里面<br>那么新的边就是多余的 但是我认为不一定环形 题意是冗余有一条 那么这个冗余会造成已经一个集合的边在集合一遍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 节点数量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 按照节点大小范围定义数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSame</span>(s, t)) &#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">join</span>(s, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冗余连接2"><a href="#冗余连接2" class="headerlink" title="冗余连接2"></a>冗余连接2</h2><p>有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。</p>
<p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。</p>
<p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p>
<p>输入描述</p>
<p>第一行输入一个整数 N，表示有向图中节点和边的个数。</p>
<p>后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边</p>
<p>输出描述</p>
<p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。</p>
<p>输入示例</p>
<p>3<br>1 2<br>1 3<br>2 3<br>输出示例</p>
<p>2 3</p>
<h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><p>回头看解法处理最重要的问题是在回头遍历寻找边<br>当有两个入点的边 存入到数组里<br>之后正向循环并查集 通过并查集看没有这个节点构成的边是否是正常的连接 如果是边<br>分类条论 如果入度有两个 一种是删除其中一条边之后没问题<br>另一种删除一条边之后会发现丢了一个节点 同时环这个问题没有解决 可以通过并查集来判断环来判断这个问题影响<br>&#x2F;&#x2F;上边这两种情况属于有多个边的从后往前遍历</p>
<p>入度不为2的时候是一种为环的情况  这个时候就通过并查集判断是否有环就可以了-&gt;删除为环的那个边界 最后一个所以从前向后遍历就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span> <span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经典并查集集合</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在有向图里找到删除的那条边，使其变成树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRemoveEdge</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 遍历所有的边</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">same</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) &#123; <span class="comment">// 构成有向环了，就是要删除的边</span></span><br><span class="line">            cout &lt;&lt; edges[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删一条边之后判断是不是树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTreeAfterRemoveEdge</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> deleteEdge)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == deleteEdge) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">same</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) &#123; <span class="comment">// 构成有向环了，一定不是树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 记录节点入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        inDegree[t]++;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;s, t&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 记录入度为2的边（如果有的话就两条边）</span></span><br><span class="line">    <span class="comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[edges[i][<span class="number">1</span>]] == <span class="number">2</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(i);<span class="comment">//这里0和1的边界没有判断明白</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况一、情况二</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="number">0</span>])) &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[<span class="number">0</span>]][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="number">0</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; edges[vec[<span class="number">1</span>]][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[vec[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理情况三</span></span><br><span class="line">    <span class="comment">// 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了</span></span><br><span class="line">    <span class="built_in">getRemoveEdge</span>(edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/01/%E5%9B%BE%E8%AE%BA/" data-id="cm4ckzpek00034gvq45z12egg" data-title="图论" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-单调栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2024-11-28T07:48:52.000Z" itemprop="datePublished">2024-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这道题是单调栈的第一道题<br>首要要明白单调栈的排序顺序<br>记住当要求求右边第一个比自己大的距离 那么这个单调栈就应该设定为从栈头开头到栈底递增顺序才行<br>这样的话当第一个比自己大的时候就开始弹出计算<br>那么求右边第一个比自己小的 那么这个栈就是递减栈才行 放入了比自己小的就该弹出了</p>
<p>注意等于的时候应该也入库而不是计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; T)</span> </span>&#123;<span class="comment">//注意第一个入栈是0 因为result计算是按照栈顶元素开始所以不用担心第一个元素的问题</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(T.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;T.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i]&lt;T[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T[i] == T[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;T[i]&gt;T[st.top])&#123;</span><br><span class="line">                result[st.top] = i-st.top;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);<span class="comment">//这是关键</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="下一个更大元素1"><a href="#下一个更大元素1" class="headerlink" title="下一个更大元素1"></a>下一个更大元素1</h2><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 1:</p>
<p>输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
<p>示例 2:<br>输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 </p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>移行变换<br>相当于变换位置之后比较大小<br>我的想法是还是单调栈进行比较<br>首先确定是递增栈 这样才能求大的 大的才能弹出小的继续放<br>那么最后做一个映射就可以了 在计算第二个数组所有的距离的时候对比一下是否含有第一个数组的值之后纳入计算结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立映射</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; umap;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums<span class="number">1.</span>size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        umap[nums1[i]] =i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始建立单调栈关系</span></span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums<span class="number">2.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums2[st.<span class="built_in">top</span>()]&gt;=nums2[i]) st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">if</span>(umap.count[nums2[st.<span class="built_in">top</span>()]])&#123;</span><br><span class="line">                    <span class="type">int</span> index = umap[nums2[st.top]];</span><br><span class="line">                    result[index] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>()</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);<span class="comment">//判断完了之后加进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下一个更大的元素2"><a href="#下一个更大的元素2" class="headerlink" title="下一个更大的元素2"></a>下一个更大的元素2</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。<br>数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，<br>这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p>示例 1:</p>
<p>输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>和前面一样唯一的问题是加了个循环 可以通过拼接数组或者去余数去解决 还是拼接数组吧单调栈起码能<br>做出来<br>好吧题解就是这两种方法 服了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; i++) &#123; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] &lt; nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] == nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>()); </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例 2：</p>
<p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>双指针对比当前列有多少可以解<br>但是用单调栈<br>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</p>
<p>而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。</p>
<p>我先写个双指针的接雨水</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意这个</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    right[height.<span class="built_in">size</span>()<span class="number">-1</span>] = height [height.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;<span class="comment">//这有个不小的问题就是在考虑左右柱子的时候需要考虑一下自己这么做有两个方面 首先是能全局比较 第二面就是能在最后计算的时候如果自己最高能计入进去不算这个积累</span></span><br><span class="line">        left[i] = <span class="built_in">max</span>(left[i<span class="number">-1</span>],height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=height.<span class="built_in">size</span>()<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j-- )&#123;</span><br><span class="line">        right[j] = <span class="built_in">max</span>(right[j<span class="number">+1</span>],height[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        result +=<span class="built_in">min</span>(left[i],right[i])-height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再写一个单调栈写法<br>单调栈这个其实更好理解 不在执着于求每一列，而是遇到凹槽的时候直接把凹槽的求了<br>所以可以直接求很多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">  st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//既然是凹槽形式的 那么肯定是新的比旧的大才让旧的弹出去 那么本身应该就是递增栈 小的才能放进去</span></span><br><span class="line">  <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(height[i] &lt;<span class="built_in">height</span>(st.<span class="built_in">top</span>()))</span><br><span class="line">      &#123;</span><br><span class="line">          st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(height[i] == <span class="built_in">height</span>(st.<span class="built_in">top</span>()))&#123;</span><br><span class="line">          st.<span class="built_in">pop</span>();</span><br><span class="line">          st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; <span class="built_in">height</span>(st.top) )&#123;</span><br><span class="line">              <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">              st.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                  <span class="type">int</span> h = <span class="built_in">min</span>(height[st.top],height[i]) - height[mid];</span><br><span class="line">                  <span class="type">int</span> w = i - st.top - <span class="number">1</span>;</span><br><span class="line">                  result += h * w;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>第一点求面积最大 应该是当前高度下不低于它的高度的最大宽度这么取比较<br>第二点 接雨水的时候第一个柱子和最后一个柱子不能接雨水 但是求面积的时候 都能算上了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(heights.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(heights.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    right[height.<span class="built_in">size</span>()<span class="number">-1</span>] =heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> t =i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;=<span class="number">0</span> &amp;&amp; heights[t] &gt;=heights[i]) t = left[t];</span><br><span class="line">        left[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    right[heights.<span class="built_in">size</span>()<span class="number">-1</span>] =size;<span class="comment">//初始化用来跳出循环的最后一个条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=heights.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> t = t<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;heights.<span class="built_in">size</span>() &amp;&amp; heights[t] &gt;=heights[i] ) t = right[t];</span><br><span class="line">        right[i] =t;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum =heights[i] *(right[i]-left[i]<span class="number">-1</span>);</span><br><span class="line">        result =<span class="built_in">max</span>(sum,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的双指针难点在跳跃和初始化<br>下面用单调栈做一下 思路：<br>和接雨水反过来 当接下来的比它小就开始弹出去做一个面积计算<br>那么这个栈就是递减栈才行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// 数组头部加入元素0</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 数组尾部加入元素0</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素已经入栈，从下标1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 情况一</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] == heights[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 情况二</span></span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 这个可以加，可以不加，效果一样，思路不同</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况三</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 注意是while</span></span><br><span class="line">                    <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="type">int</span> right = i;</span><br><span class="line">                        <span class="type">int</span> w = right - left - <span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> h = heights[mid];</span><br><span class="line">                        result = <span class="built_in">max</span>(result, w * h);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code class="cpp">while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123; // 注意是while
                    int mid = st.top();
                    st.pop();
                    if (!st.empty()) &#123;
                        int left = st.top();
                        int right = i;
                        int w = right - left - 1;
                        int h = heights[mid];
                        result = max(result, w * h);
                    &#125;
                &#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/" data-id="cm4ckzpen000b4gvqh8h134p8" data-title="单调栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/" class="article-date">
  <time class="dt-published" datetime="2024-11-25T09:06:24.000Z" itemprop="datePublished">2024-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/">动态规划-3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1<br>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这个竟然可以用动态规划解决？离谱<br>从原理上来说就是回溯问题 回溯可以修改成dp<br>我看一下标准解答<br>看了解答了 非常的劲爆<br>设定dp[i]为以[i]为结尾的最长字串个数<br>递推公式<br>if(nums[i] &gt;nums[j]){<br>    dp[i] &#x3D;max(dp[j]+1,dp[i])这里的max单纯是更新dp[i]的最大值 这外面套了两层循环<br>}<br>初始化<br>dp[0] &#x3D; 1 表示长度为1的字串<br>遍历顺序<br>都按照从头开始遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">1</span>);<span class="comment">//每个最少都是1</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();<span class="comment">//起始节点单独判断</span></span><br><span class="line">   <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">           dp[i] = <span class="built_in">max</span>(dp[j]<span class="number">+1</span>,dp[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result =<span class="built_in">max</span>(result,dp[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。<br>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>多了个连续 感觉回溯更能做了 但是会超时<br>那么继续用上面的dp？ 递推公式需要修改 数组设置倒是不需要修改<br>在递推的时候就不需要考虑在前面循环去找最大的了 只需要考虑前一个和当前这个比较大小</p>
<p>没想到贪心这么好做：比前面大 ++ 不如前面就 &#x3D;1</p>
<p>用dp做一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() ,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 连续记录</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例：</p>
<p>输入：</p>
<p>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3, 2, 1] 。<br>提示：</p>
<p>1 &lt;&#x3D; len(A), len(B) &lt;&#x3D; 1000<br>0 &lt;&#x3D; A[i], B[i] &lt; 100</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这个从解法上来说使用了dp[i][j]<br>因为不想初始化<br>就设置dp[i][j]是前一个作为结尾相等的个数<br>这样递推公式<br>dp[i][j] &#x3D; dp[i-1]dp[j-1] +1;<br>从二维数组的角度来想<br>如果dp[i][j]表示当前这个为结尾的相等个数<br>那么第一行和第一列都需要初始化才行 这样才能递推后面的<br>这样-1的情况我就全变成0 可以当作起始位置<br>遍历条件二维数组怎么遍历顺序都可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(nums<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123; <span class="comment">//主要是-1</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="number">+1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(dp[i][j],result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">变成一维数组:</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;(B.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = B.<span class="built_in">size</span>(); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> dp[j] = <span class="number">0</span>; <span class="comment">// 注意这里不相等的时候要有赋0的操作</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; result) result = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//一维数组的情况具体来说就是二维数组的变形 这么使用需要从后往前遍历防止覆盖前一个不能得到后一个  同时因为当前如果不是相等的情况那么 需要重置为0 这样让后面续不上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:</p>
<p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。<br>提示:</p>
<p>1 &lt;&#x3D; text1.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; text2.length &lt;&#x3D; 1000 输入的字符串只含有小写英文字符。</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这个看来是加了可以断连的情况<br>离谱啊离谱 太难想了离谱中的离谱<br>在判定完dp[i][j]之后（相等的情况）还要判定一下dp[i-1][j] dp[i][j-1]；<br>多了两种判定是因为原有的[i-1][j-1]判定被否决了 同时[i-2][j-2]的判定已经完成了<br>到了[i-1][j-1]这种范围限制的时候分别用[i-2][j-1]  [i-1][j-2]尝试进行看看哪一种比较大<br>适合[i-1][j-1]同时[i-2][j-1]  [i-1][j-2]的两个值在进行当前判定的时候都已经求完了 而且默认比[i-2][j-2]等于大于看能不能多捞着一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span>  </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(text<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;text<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;text<span class="number">2.</span><span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] =  dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text<span class="number">1.</span><span class="built_in">size</span>()][text<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>从题目分析这个题求得就是最长公共子序列所以代码是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()][B.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>贪心就是求和之后如果等于0直接从下一个开始<br>dp的话<br>dp[i]表示一直到i为结尾的这个连续和的最大值&#x2F;&#x2F;这样递推公式好写<br>那么dp[i]有两种选择 加入之前的和放弃之前的用现在的<br>递推公式<br>dp[i] &#x3D; max(nums[i],dp[i-1]+nums[i])<br>初始化<br>dp[0] &#x3D; nums[0]<br>遍历顺序<br>从前向后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> result = dp[<span class="number">0</span>];<span class="comment">//注意这个初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i] =<span class="built_in">max</span>(nums[i].dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        result =<span class="built_in">max</span>(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “abc”, t &#x3D; “ahbgdc”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “axc”, t &#x3D; “ahbgdc”<br>输出：false<br>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 100<br>0 &lt;&#x3D; t.length &lt;&#x3D; 10^4<br>两个字符串都只由小写字符组成</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>最简单的就是双指针解法了</p>
<p>到手里可以用回溯去处理<br>那么dp的话开始设置也是只有两种状态<br>为了递推公式好些需要想好我这个dp的定义<br>题解的递推公式表示的含义是dp[i][j]以i-1 j-1结尾的两个数组所含有的最多公共子串有多少个<br>那么递推公式就得修改了<br>在nums[i-1] &#x3D;&#x3D; nums[j-1]的时候<br>dp[i][j] &#x3D;dp[i-1][j-1]<br>在不相等的时候<br>dp[i][j] &#x3D; dp[i-1][j]  这个时候不能j-1 因为我们要求得是s是否是t的字串所以s不能节省去和t匹配 一旦节省匹配上了 那么后续可能省略s中的一个<br>但是 但是 我发现只要最后判断是否数量上相等就可以了 所以省略不省略无所谓了 所以还是上文的代码最后进行一个判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>这道题的解法就是可以有重复的 那么对于当前的dp[i][j]它的个数既可以采用当前的i-1和j-1这两个特定数对应的数量dp[i-1][j-1] 同时dp[i][j]的个数还有不采用这个当前s这个对应的数量dp[i-1][j1]<br>这样就是分成两种情况对于当前的这个t序列采用不采用当前s来进行t的匹配 把情况占满了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置dp数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">szie</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//还有第一排和第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=t.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][j.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<p>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>理论上来说可以用相同的子序列算法 之后用所有的大小减去一下 等一下试试 本身肯定不难 但是为了铺垫距离计算只能用这个特殊方法了<br>现在用正常思路的dp<br>确定dp数组（dp table）以及下标的含义<br>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。<br>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] &#x3D; dp[i - 1][j - 1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] &#x3D; min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p>
<p>因为 dp[i][j - 1] + 1 &#x3D; dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] &#x3D; min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</p>
<p>需要注意的是dp[i - 1][j - 1] + 2 相当于不考虑一个的同时还删去了另一个 相当于不考虑两个所以<br>dp[i - 1][j - 1] + 2 &#x3D;另外两种方式 + 1 所以比较大小比较两个就可以了</p>
<p>遍历公式<br>从左到右<br>从上到下</p>
<p>初始化<br>dp[0][0] &#x3D; 0;<br>dp[i][0] &#x3D; i;i-1为结尾的字符删除多少个才能是空的字符串 0到i-1一共有i个<br>dp[0][j] &#x3D; j;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>，<span class="number">0</span>))；</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>]<span class="number">+1</span>,dp[i<span class="number">-1</span>][j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符</p>
<p>删除一个字符</p>
<p>替换一个字符</p>
<p>示例 1：</p>
<p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</p>
<p>输出：3</p>
<p>解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：</p>
<p>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”</p>
<p>输出：5</p>
<p>解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’)</p>
<p>提示：</p>
<p>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500<br>word1 和 word2 由小写英文字母组成</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>顶级了属于 增删查改<br>删除和上面一样<br>dp[i][j] &#x3D; min(dp[i-1][j]+1,dp[i][j-1]+1);<br>添加<br>dp[i][j] &#x3D; min(dp[i-1][j]+1,dp[i][j-1]+1);<br>添加也是有一个不同之后按照多出来的的一个的dp基础上进行添加操作 最后比大小<br>替换<br>当前的不对应 所以替换后对应了 这是1次操作 之前的操作是dp[i-1][j-1]<br>dp[i][j] &#x3D;dp[i-1][j-1]+1 &#x2F;&#x2F;这里想了想其他操作 如果按照顺序替换逻辑来说这么写没毛病</p>
<p>当我们不管是添加还是删除操作的时候因为当前两个元素不相等 那么多出来的那一个和没多出来的那一行本身匹配的次数再加上当前没多出来的那一行未被包含的那一个被删除的次数（+1）<br>添加操作也是如此本身也搭配不上多出来的那一个 那么就用原有的上一个状态加上添加这个操作<br>删除和添加都是为了尽量匹配 为不是一下就能匹配上</p>
<p>那么替换这个操作表示的则是当前两个i和j直接进行替换就能匹配上 那么就是原有的个数+1个 要是向增加和删除学习的话无法替换了 因为那种情况你都匹配完了 不知道该替换成什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化 第一列和第一行</span></span><br><span class="line">    <span class="comment">//如果一个是空字符串的话 其他的也只能全部删除了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;)<span class="number">+1</span>;<span class="comment">//起始我理解的也是没错的 因为是求最小值所以不能省略最后一个 要是求最大值直接把最后一个删去了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>(),word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<p>输入：”abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”<br>示例 2：</p>
<p>输入：”aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”<br>提示：输入的字符串长度不会超过 1000 。</p>
<h3 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h3><p>回溯能做到分割回文子串 为此我可以最后结果存在set里面<br>暴力可以做到两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文<br>我之前回溯的时候写过判断回文子串的函数等会粘一下<br>哈哈 我构建的函数原来就是dp数组求解方式哈哈</p>
<p>这道题dp的话<br>首先构建数组dp[i][j]表示i到j这个字符串可以判定是否是回文字符串<br>递推三种情况<br>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串<br>情况二：下标i 与 j相差为1，例如aa，也是回文子串<br>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。<br>初始化<br>都为false<br>遍历顺序 一个是从+1推出来的 一个是从-1推导出来的 那么就是从下到上 从左到右</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 只包含小写英文字母</p>
<h3 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h3><p>那就dp的时候加个距离最大判断呗<br>这就错了 子序列不要求连续<br>不能连续的话dp怎么判定数组呢 设置一个dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。</p>
<p>递推公式&#x2F;&#x2F;这里递推公式也有个不同的地方在于不能同时出发了 最少差了一个的遍历环境<br>如果s[i]与s[j]相同，那么dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;<br>不相等的话应该比较一下最大值<br>加入s[j]的回文子序列长度为dp[i + 1][j]。</p>
<p>加入s[i]的回文子序列长度为dp[i][j - 1]。<br>dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</p>
<p>初始化可能有些费劲了从下到上遍历 从左到右遍历 那么就是最下面那一行和最左面那一列<br>从表格来看可以设定对角线来设置最开始的数<br>从另外一个角度考虑就是这dp数组无法得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][i] =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递推公式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =i<span class="number">+1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">+1</span>][j<span class="number">-1</span>] <span class="number">+2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="交替组2"><a href="#交替组2" class="headerlink" title="交替组2"></a>交替组2</h2><p>给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：</p>
<p>colors[i] &#x3D;&#x3D; 0 表示第 i 块瓷砖的颜色是 红色 。<br>colors[i] &#x3D;&#x3D; 1 表示第 i 块瓷砖的颜色是 蓝色 。<br>环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。</p>
<p>请你返回 交替 组的数目。</p>
<p>注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的</p>
<h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><p>之前是用的k为固定所以很好解决 但是这一次k不固定了<br>那么拼接数组或者 取余数之后滑动窗口进行判定呢？<br>10101010<br>怎么用滑动窗口判定这个窗口是否符合呢 这类似与暴力了 会超时是的<br>拼接数组加枚举右端点解决 记住枚举右侧端点 下面这代码逻辑也改不了确实就是右侧端点逻辑<br>开始用第二个数组进行罗列的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfAlternatingGroups</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; colors, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//环的问题可以用%去解决 但是数这个问题  </span></span><br><span class="line">        <span class="type">int</span> n = colors.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; colors[i % n] == colors[(i - <span class="number">1</span>) % n]) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            ans += i &gt;= n &amp;&amp; cnt &gt;= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/" data-id="cm4ckzpeh00004gvq2eed6ll8" data-title="动态规划-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hot100/" rel="tag">hot100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hot100/" style="font-size: 10px;">hot100</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 12.5px;">图论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">算法，图论</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">语法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/25/hot100/">hot100</a>
          </li>
        
          <li>
            <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2024/12/13/xv6/">xv6</a>
          </li>
        
          <li>
            <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
          </li>
        
          <li>
            <a href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/">杂项语法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>