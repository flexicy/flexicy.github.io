<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>图论-2 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="prim算法题目描述： 在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。 不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。 给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。 输入描述： 第一行包含两个整数V 和 E，V">
<meta property="og:type" content="article">
<meta property="og:title" content="图论-2">
<meta property="og:url" content="http://example.com/2024/12/07/%E5%9B%BE%E8%AE%BA-2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="prim算法题目描述： 在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。 不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。 给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。 输入描述： 第一行包含两个整数V 和 E，V">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-07T07:46:36.000Z">
<meta property="article:modified_time" content="2024-12-10T13:30:18.317Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法，图论">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-图论-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/" class="article-date">
  <time class="dt-published" datetime="2024-12-07T07:46:36.000Z" itemprop="datePublished">2024-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      图论-2
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>输入描述：</p>
<p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p>
<p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p>
<p>输出描述：</p>
<p>输出联通所有岛屿的最小路径总距离</p>
<p>输入示例：</p>
<p>7 11<br>1 2 1<br>1 3 1<br>1 5 2<br>2 6 1<br>2 4 2<br>2 3 2<br>3 4 1<br>4 5 1<br>5 6 2<br>5 7 1<br>6 7 1<br>输出示例：</p>
<p>6</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>官方解法在于三个步骤<br>第一步，选距离生成树最近节点<br>第二步，最近节点加入生成树<br>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</p>
<p>minDist数组 是记录了 所有非生成树节点距离生成树的最小距离。</p>
<p>最后，minDist数组 也就是记录的是最小生成树所有边的权值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> x, y, k;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="comment">// 填一个默认最大值，题目描述val最大为10000</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">10001</span>));</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">        <span class="comment">// 因为是双向图，所以两个方向都要填上</span></span><br><span class="line">        grid[x][y] = k;</span><br><span class="line">        grid[y][x] = k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有节点到最小生成树的最小距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(v + <span class="number">1</span>, <span class="number">10001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个节点是否在树里</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isInTree</span><span class="params">(v + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、prim三部曲，第一步：选距离生成树最近节点</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">-1</span>; <span class="comment">// 选中哪个节点 加入最小生成树</span></span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123; <span class="comment">// 1 - v，顶点编号，这里下标从1开始</span></span><br><span class="line">            <span class="comment">//  选取最小生成树节点的条件：</span></span><br><span class="line">            <span class="comment">//  （1）不在最小生成树里</span></span><br><span class="line">            <span class="comment">//  （2）距离最小生成树最近的节点</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp;  minDist[j] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[j];</span><br><span class="line">                cur = j;</span><br><span class="line">            &#125;<span class="comment">//   默认逻辑就是第一个节点就是加入的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span></span><br><span class="line">        isInTree[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="comment">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下</span></span><br><span class="line">        <span class="comment">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">            <span class="comment">// 更新的条件：</span></span><br><span class="line">            <span class="comment">// （1）节点是 非生成树里的节点</span></span><br><span class="line">            <span class="comment">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span></span><br><span class="line">            <span class="comment">// 其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span></span><br><span class="line">            <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">                minDist[j] = grid[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计结果</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= v; i++) &#123; <span class="comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span></span><br><span class="line">        result += minDist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展同时打印出最小生成树的每一条边</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(v + <span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">//用来记录边界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既然 minDist数组 记录了 最小生成树的边，是不是就是在更新 minDist数组 的时候，去更新parent数组来记录一下对应的边呢。所以 在 prim三部曲中的第三步，更新 parent数组，代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">        parent[j] = cur; <span class="comment">// 记录最小生成树的边 （注意数组指向的顺序很重要）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果写成 parent[cur] = j，在 for 循环中，有多个 j 满足要求， 那么 parent[cur] 就会被反复覆盖，因为 cur 是一个固定值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举个例子，cur = 1， 在 for循环中，可能 就 j = 2， j = 3，j =4 都符合条件，那么本来应该记录 节点1 与 节点 2、节点3、节点4相连的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 parent[cur] = j 这么写，最后更新的逻辑是 parent[1] = 2, parent[1] = 3， parent[1] = 4， 最后只能记录 节点1 与节点 4 相连，其他相连情况都被覆盖了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这么写 parent[j] = cur， 那就是 parent[2] = 1, parent[3] = 1， parent[4] = 1 ，这样 才能完整表示出 节点1 与 其他节点都是链接的，才没有被覆盖。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 最小生成树边的链接情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; parent[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>输入描述：</p>
<p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。</p>
<p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p>
<p>输出描述：</p>
<p>输出联通所有岛屿的最小路径总距离</p>
<p>输入示例：</p>
<p>7 11<br>1 2 1<br>1 3 1<br>1 5 2<br>2 6 1<br>2 4 2<br>2 3 2<br>3 4 1<br>4 5 1<br>5 6 2<br>5 7 1<br>6 7 1<br>输出示例：</p>
<p>6</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>题目一摸一样 换了个做法<br>和prim的区别在于<br>prim维护节点 这个维护边</p>
<p>kruscal的思路：</p>
<p>边的权值排序，因为要优先选最小的边加入到生成树里</p>
<p>遍历排序后的边:<br>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环<br>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</p>
<p>是否在一个集合使用并查集来判断问题 同时使用并查集添加节点<br>&#x2F;&#x2F;快排+并查集nlogn （快排） + logn （并查集）  -&gt;最后是nlogn</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l,r为 边两边的节点，val为边的数值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点数量</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10001</span>;</span><br><span class="line"><span class="comment">// 并查集标记节点关系的数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">// 节点编号是从1开始的，n要大一些</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的查找操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的加入集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v, e;</span><br><span class="line">    <span class="type">int</span> v1, v2, val;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    <span class="type">int</span> result_val = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">while</span> (e--) &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;v1, v2, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法</span></span><br><span class="line">    <span class="comment">// 按边的权值对边进行从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头开始遍历边</span></span><br><span class="line">    <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">        <span class="comment">// 并查集，搜出两个节点的祖先</span></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(edge.l);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">find</span>(edge.r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">            <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result_val &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这也加一个输出最小生成树的边</span></span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; result; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line"><span class="comment">// 如果祖先不同，则不在同一个集合</span></span><br><span class="line"><span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(edge); <span class="comment">// 记录最小生成树的边</span></span><br><span class="line">    result_val += edge.val; <span class="comment">// 这条边可以作为生成树的边</span></span><br><span class="line">    <span class="built_in">join</span>(x, y); <span class="comment">// 两个节点加入到同一个集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (Edge edge : result) &#123;</span><br><span class="line">        cout &lt;&lt; edge.l &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.r &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; edge.val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法比较"><a href="#方法比较" class="headerlink" title="方法比较"></a>方法比较</h2><p>Kruskal 与 prim 的关键区别在于，prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 如果 一个图中，节点多，但边相对较少，那么使用Kruskal 更优。</p>
<p>Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。</p>
<p>Kruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>题目描述：</p>
<p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;&#x3D; A, B &lt;&#x3D; N - 1）。请编写一个算法，用于确定文件处理的顺序。</p>
<p>输入描述：</p>
<p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p>
<p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p>
<p>输出描述：</p>
<p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p>
<p>如果不能成功处理（相互依赖），则输出 -1。</p>
<p>输入示例：</p>
<p>5 4<br>0 1<br>0 2<br>1 3<br>2 4<br>输出示例：</p>
<p>0 1 2 3 4</p>
<p>提示信息：</p>
<p>文件依赖关系如下：<br>0-&gt;1-&gt;3<br>0-&gt;2-&gt;4<br>所以，文件处理的顺序除了示例中的顺序，还存在</p>
<p>0 2 4 1 3</p>
<p>0 2 1 3 4</p>
<p>等等合法的顺序。</p>
<p>数据范围：</p>
<p>0 &lt;&#x3D; N &lt;&#x3D; 10 ^ 5<br>1 &lt;&#x3D; M &lt;&#x3D; 10 ^ 9</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。<br>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。<br>所以拓扑排序也是图论中判断有向无环图的常用方法</p>
<p>其实只要能在把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序。</p>
<p>实现拓扑排序的算法有两种：卡恩算法（BFS）和DFS</p>
<p>你看节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p>
<p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。</p>
<p>所以当我们做拓扑排序的时候，应该优先找 入度为 0 的节点，只有入度为0，它才是出发节点</p>
<p>具体步骤：</p>
<p>找到入度为0 的节点，加入结果集<br>将该节点从图中移除</p>
<p>循环以上两步，直到 所有节点都在图中被移除了。</p>
<p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">inDegree</span>(n,<span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    cin &gt;&gt;s&gt;&gt;t;</span><br><span class="line">    inDegree[t] ++;</span><br><span class="line">    umap[s].<span class="built_in">push_back</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(inDegree[i] ==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始从队列里遍历入度为0 的节点，将其放入结果集。</span></span><br><span class="line"><span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> cur =que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="comment">//将该节点从图中移除</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取cur指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果cur有指向的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历cur指向的节点</span></span><br><span class="line">            inDegree[files[i]] --; <span class="comment">// cur指向的节点入度都做减一操作</span></span><br><span class="line">            <span class="comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span></span><br><span class="line">            <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以，我们在代码实现的过程中，本质是要将 该节点作为出发点所连接的节点的 入度 减一 就可以了，这样好能根据入度找下一个节点，不用真在图里把这个节点删掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整体代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 记录每个文件的入度</span></span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; umap;<span class="comment">// 记录文件依赖关系</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 记录结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="comment">// s-&gt;t，先有s才能有t</span></span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        inDegree[t]++; <span class="comment">// t的入度加一</span></span><br><span class="line">        umap[s].<span class="built_in">push_back</span>(t); <span class="comment">// 记录s指向哪些文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 入度为0的文件，可以作为开头，先加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// int count = 0;</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span>  cur = que.<span class="built_in">front</span>(); <span class="comment">// 当前选中的文件</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//count++;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; files = umap[cur]; <span class="comment">//获取该文件指向的文件</span></span><br><span class="line">        <span class="keyword">if</span> (files.<span class="built_in">size</span>()) &#123; <span class="comment">// cur有后续文件</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                inDegree[files[i]] --; <span class="comment">// cur的指向的文件入度-1</span></span><br><span class="line">                <span class="keyword">if</span>(inDegree[files[i]] == <span class="number">0</span>) que.<span class="built_in">push</span>(files[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; result[n - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p>
<p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>
<p>【输出描述】</p>
<p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p>
<p>输入示例</p>
<p>7 9<br>1 2 1<br>1 3 4<br>2 3 2<br>2 4 5<br>3 4 2<br>4 5 3<br>2 6 4<br>5 7 4<br>6 7 9<br>输出示例：12</p>
<p>【提示信息】</p>
<p>能够到达的情况：</p>
<p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p>
<h3 id="解法-dijkstra算法-和prim算法-原理相似"><a href="#解法-dijkstra算法-和prim算法-原理相似" class="headerlink" title="解法  dijkstra算法 (和prim算法)原理相似&#x2F;"></a>解法  dijkstra算法 (和prim算法)原理相似&#x2F;</h3><p>和上面不同的在于不是每一个点都要参与进去 同时属于有向图问题</p>
<p>本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。</p>
<p>接下来，我们来详细讲解最短路算法中的 dijkstra 算法。</p>
<p>dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</p>
<p>需要注意两点：</p>
<p>dijkstra 算法可以同时求 起点到所有节点的最短路径<br>权值不能为负数</p>
<p>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
<p>不同的点在于路径规划的时候填充表格的值是从源点开始到目标的距离值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;climits&gt;</span><span class="comment">//前缀作用</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,p1,p2,val;</span><br><span class="line">    cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,INT_MAX));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin &gt;&gt;p1&gt;&gt;p2&gt;&gt;val;</span><br><span class="line">        grid[p1][p2] =val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end =n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n<span class="number">+1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    minDist[start] =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//遍历所有节点</span></span><br><span class="line">    <span class="type">int</span> minVal =INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur =<span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 1、选距离源点最近且未访问过的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; minDist[v] &lt; minVal) &#123;</span><br><span class="line">                minVal = minDist[v];</span><br><span class="line">                cur = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         visited[cur] = <span class="literal">true</span>;  <span class="comment">// 2、标记该节点已被访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// 被利用的节点加上这个节点到新的节点的距离 等于总的距离  被利用的节点之前就是最近节点的选择 就是这一点和prime不同的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应求路径</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">                minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">                parent[v] = cur; <span class="comment">// 记录边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意 不能出现负数<br>但是prime可以由负数权值 因为一个是双向一个是单向没有路径依赖 虽然都有visit</p>
<p>prim和dijkstra的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prim</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">        minDist[j] = grid[cur][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//因为 minDist表示 节点到最小生成树的最小距离，所以 新节点cur的加入，只需要 使用 grid[cur][j] ，grid[cur][j] 就表示 cur 加入生成树后，生成树到 节点j 的距离。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dijkstra</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur] + grid[cur][v] &lt; minDist[v]) &#123;</span><br><span class="line">        minDist[v] = minDist[cur] + grid[cur][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//因为 minDist表示 节点到源点的最小距离，所以 新节点 cur 的加入，需要使用 源点到cur的距离 （minDist[cur]） + cur 到 节点 v 的距离 （grid[cur][v]），才是 源点到节点v的距离。</span></span><br></pre></td></tr></table></figure>
<h2 id="dijkstra（堆优化版）精讲"><a href="#dijkstra（堆优化版）精讲" class="headerlink" title="dijkstra（堆优化版）精讲"></a>dijkstra（堆优化版）精讲</h2><p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>【输入描述】</p>
<p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p>
<p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>
<p>【输出描述】</p>
<p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p>
<p>输入示例</p>
<p>7 9<br>1 2 1<br>1 3 4<br>2 3 2<br>2 4 5<br>3 4 2<br>4 5 3<br>2 6 4<br>5 7 4<br>6 7 9<br>输出示例：12</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>题目还是那个题目<br>优化方式用在了把数组改成邻接表的情况</p>
<p>三部分<br>第一步，选源点到哪个节点近且该节点未被访问过<br>第二步，该最近节点被标记访问过<br>第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
<p>三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历 minDist 来寻找最近的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 遍历所有节点，第一层for循环 </span></span><br><span class="line">    <span class="type">int</span> minVal =INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;++v)&#123;<span class="comment">// 1、选距离源点最近且未访问过的节点 ， 第二层for循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!visited[v] &amp;&amp; minDist[v]&lt;minVal)&#123;</span><br><span class="line">            minVal =minDist[v];</span><br><span class="line">            cur =v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur] =<span class="literal">true</span>;<span class="comment">//这个点被标记访问过了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)&#123;<span class="comment">//更新没有访问过的节点到源点的最小距离</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v]&amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; minDist[cur]+grid[cur][v] &lt;minDist[v])&#123;</span><br><span class="line">            minDist[v] =minDist[cur] +grid[cur][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。</p>
<p>而且 直接把 边（带权值）加入到 小顶堆（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。</p>
<p>这样我们就不需要两层for循环来寻找最近的节点了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);<span class="comment">//邻接表图结构</span></span><br><span class="line"></span><br><span class="line">vector&lt;list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//第一个是节点 第二个是权值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用类取代pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数 初始列表型构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 链接的节点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>); <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用边取代点从而使用堆优化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为优先队列本身是大的在顶部被排序排出的 所以小顶堆就得重写CMP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myconparison</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; hls,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt;rhs.second<span class="comment">//优先队列这么做是为了反过来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparsion&gt;pq;</span><br><span class="line"><span class="comment">//第一个参数是存储什么 第二个参数是用什么存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//部曲中的第一步，我们不用 for循环去遍历，直接取堆顶元素：有了小顶堆自动对边的权值排序，那我们只需要直接从 堆里取堆顶元素（小顶堆中，最小的权值在上面），就可以取到离源点最近的节点了 （未访问过的节点，不会加到堆里进行排序）</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//第二步（该最近节点被标记访问过） 这个就是将 节点做访问标记，和 朴素dijkstra 一样 ，代码如下</span></span><br><span class="line"></span><br><span class="line">visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cur.first 就是cur节点编号， 参考上面pair的定义： pair&lt;节点编号，源点到该节点的权值&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来就是更新 非访问节点到源点的距离，代码实现和 朴素dijkstra 是一样的，代码如下：</span></span><br><span class="line"><span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line"><span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">    <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">    <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">        minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//整体代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个结构体来表示带权重的边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;  <span class="comment">// 邻接顶点</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 边的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w): <span class="built_in">to</span>(t), <span class="built_in">val</span>(w) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, p1, p2, val;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;list&lt;Edge&gt;&gt; <span class="built_in">grid</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; </span><br><span class="line">        <span class="comment">// p1 指向 p2，权值为 val</span></span><br><span class="line">        grid[p1].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(p2, val));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start = <span class="number">1</span>;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> end = n;    <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储从源点到每个节点的最短距离</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录顶点是否被访问过</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(start, <span class="number">0</span>)); </span><br><span class="line">    </span><br><span class="line">    minDist[start] = <span class="number">0</span>;  <span class="comment">// 起始点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span></span><br><span class="line">        <span class="comment">// &lt;节点， 源点到该节点的距离&gt;</span></span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = pq.<span class="built_in">top</span>(); </span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[cur.first]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 第二步，该最近节点被标记访问过</span></span><br><span class="line">        visited[cur.first] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : grid[cur.first]) &#123; <span class="comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span></span><br><span class="line">            <span class="comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[edge.to] &amp;&amp; minDist[cur.first] + edge.val &lt; minDist[edge.to]) &#123; <span class="comment">// 更新minDist</span></span><br><span class="line">                minDist[edge.to] = minDist[cur.first] + edge.val;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(edge.to, minDist[edge.to]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 不能到达终点</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl; <span class="comment">// 到达终点最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得讨论的复杂度O(ElogE) E 为边的数量</p>
<h2 id="Bellman-ford-算法"><a href="#Bellman-ford-算法" class="headerlink" title="Bellman_ford 算法"></a>Bellman_ford 算法</h2><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。</p>
<p>如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</p>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p>
<p>输入描述</p>
<p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p>
<p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v（单向图）。</p>
<p>输出描述</p>
<p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p>
<p>输入示例：</p>
<p>6 7<br>5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/07/%E5%9B%BE%E8%AE%BA-2/" data-id="cm4iipakk0000b0vq3nm2a1xp" data-title="图论-2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          杂项语法
        
      </div>
    </a>
  
  
    <a href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">每日一题</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">算法，图论</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">语法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/10/%E6%9D%82%E9%A1%B9%E8%AF%AD%E6%B3%95/">杂项语法</a>
          </li>
        
          <li>
            <a href="/2024/12/07/%E5%9B%BE%E8%AE%BA-2/">图论-2</a>
          </li>
        
          <li>
            <a href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a>
          </li>
        
          <li>
            <a href="/2024/12/01/%E5%9B%BE%E8%AE%BA/">图论</a>
          </li>
        
          <li>
            <a href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>