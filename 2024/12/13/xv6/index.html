<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xv6 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些操作系统上的东西文件系统mknod(“&#x2F;console”, 1, 1);这行是关键。mknod 系统调用用来创建特殊文件。它接受三个参数： 第一个参数 &#x2F;console 是你要创建的设备文件的路径。第二个参数 1 是主设备号（major device number）。第三个参数 1 是次设备号（minor device number） 1234567891011121314">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6">
<meta property="og:url" content="http://example.com/2024/12/13/xv6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一些操作系统上的东西文件系统mknod(“&#x2F;console”, 1, 1);这行是关键。mknod 系统调用用来创建特殊文件。它接受三个参数： 第一个参数 &#x2F;console 是你要创建的设备文件的路径。第二个参数 1 是主设备号（major device number）。第三个参数 1 是次设备号（minor device number） 1234567891011121314">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-13T08:17:31.000Z">
<meta property="article:modified_time" content="2025-03-10T07:15:57.129Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-xv6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/13/xv6/" class="article-date">
  <time class="dt-published" datetime="2024-12-13T08:17:31.000Z" itemprop="datePublished">2024-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      xv6
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一些操作系统上的东西"><a href="#一些操作系统上的东西" class="headerlink" title="一些操作系统上的东西"></a>一些操作系统上的东西</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>mknod(“&#x2F;console”, 1, 1);<br>这行是关键。mknod 系统调用用来创建特殊文件。它接受三个参数：</p>
<p>第一个参数 &#x2F;console 是你要创建的设备文件的路径。<br>第二个参数 1 是主设备号（major device number）。<br>第三个参数 1 是次设备号（minor device number）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span>    <span class="comment">// 引入基本数据类型定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span>     <span class="comment">// 引入文件状态结构体定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span>       <span class="comment">// 引入用户空间的系统调用和函数声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span>       <span class="comment">// 引入文件系统相关结构体和常量定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个递归查找函数，接受两个参数：起始路径和目标文件名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;          <span class="comment">// buf用于构建新的路径，p是指向buf中当前操作位置的指针</span></span><br><span class="line">    <span class="type">int</span> fd;                     <span class="comment">// 文件描述符，用于打开文件或目录</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;           <span class="comment">// 目录项结构体，用于存储读取的目录项信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;             <span class="comment">// 文件状态结构体，用于存储文件的元数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试以只读方式打开指定路径</span></span><br><span class="line">    <span class="keyword">if</span>((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);  <span class="comment">// 如果打开失败，向标准错误输出错误信息</span></span><br><span class="line">        <span class="keyword">return</span>;                                       <span class="comment">// 返回，结束当前函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取打开文件的状态信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);  <span class="comment">// 如果获取失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">close</span>(fd);                                    <span class="comment">// 关闭文件描述符，释放资源</span></span><br><span class="line">        <span class="keyword">return</span>;                                       <span class="comment">// 返回，结束当前函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据文件类型进行不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="comment">// 如果当前路径是一个文件，检查文件名是否以目标名结尾</span></span><br><span class="line">        <span class="comment">// 通过比较路径字符串的最后部分是否与目标字符串相同</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path + <span class="built_in">strlen</span>(path) - <span class="built_in">strlen</span>(target), target) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);  <span class="comment">// 如果匹配，打印文件的完整路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 结束当前case</span></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="comment">// 如果当前路径是一个目录，首先检查构建新路径时是否会超出缓冲区大小</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);  <span class="comment">// 如果超出，输出错误信息</span></span><br><span class="line">            <span class="keyword">break</span>;                             <span class="comment">// 结束当前case</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);          <span class="comment">// 将当前路径复制到buf中</span></span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);     <span class="comment">// 设置指针p指向buf的末尾</span></span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;                 <span class="comment">// 在buf末尾添加一个斜杠，准备拼接子目录或文件名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环读取目录中的每一个目录项</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))&#123;</span><br><span class="line">            <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 如果目录项的inode号为0，表示无效，跳过</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memmove</span>(p, de.name, DIRSIZ);  <span class="comment">// 将目录项的名称复制到buf的当前指针位置</span></span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;                <span class="comment">// 在复制的名称后添加字符串终止符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取新路径的文件状态信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);  <span class="comment">// 如果获取失败，输出错误信息</span></span><br><span class="line">                <span class="keyword">continue</span>;                                 <span class="comment">// 跳过当前目录项，继续下一个</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过当前目录和父目录，避免无限递归</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf + <span class="built_in">strlen</span>(buf) - <span class="number">2</span>, <span class="string">&quot;/.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf + <span class="built_in">strlen</span>(buf) - <span class="number">3</span>, <span class="string">&quot;/..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">find</span>(buf, target);  <span class="comment">// 递归调用find函数，继续查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 结束当前case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);  <span class="comment">// 关闭文件描述符，释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查命令行参数的数量是否少于3个</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 如果参数不足，程序退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> target[<span class="number">512</span>];        <span class="comment">// 定义一个字符数组用于存储目标文件名</span></span><br><span class="line">    target[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;         <span class="comment">// 在目标文件名前添加一个斜杠</span></span><br><span class="line">    <span class="built_in">strcpy</span>(target + <span class="number">1</span>, argv[<span class="number">2</span>]);  <span class="comment">// 将命令行的第三个参数（目标文件名）复制到target中，紧跟斜杠之后</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">find</span>(argv[<span class="number">1</span>], target);   <span class="comment">// 调用find函数，传入起始路径和目标文件名</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                 <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户空间调用内核空间程序流程"><a href="#用户空间调用内核空间程序流程" class="headerlink" title="用户空间调用内核空间程序流程"></a>用户空间调用内核空间程序流程</h2><p>用户程序<br>   |<br>   | 设置寄存器 a0, a1, a7<br>   | 执行 ecall<br>   |<br>陷阱处理程序（uservec）<br>   |<br>   | 保存用户寄存器到 Trapframe<br>   | 调用 usertrap<br>   |<br>usertrap<br>   |<br>   | 识别陷阱类型为系统调用<br>   | 调用 syscall<br>   |<br>syscall<br>   |<br>   | 从 Trapframe 获取系统调用号（a7）<br>   | 查找 syscalls[num] 调用对应函数（如 sys_exec）<br>   | 将返回值存入 Trapframe 的 a0<br>   |<br>返回用户空间</p>
<h2 id="lab-4"><a href="#lab-4" class="headerlink" title="lab 4"></a>lab 4</h2><p>首先是小端序问题<br>正常来说数字是从左到右 左边是高位 右边是低位<br>小端序是把低位存储在低位 高位存储在高位<br>大端序时把高位存储在低位 低位存储在高位上</p>
<p>对于 i &#x3D; 0x00646c72 这个 32 位数，按位分解可以写成<br>低地址 ──&gt;  0x72 (‘r’)<br>            0x6c (‘l’)<br>            0x64 (‘d’)<br>            0x00 (‘\0’)<br>高地址</p>
<ol start="2">
<li>在RISC-V指令集中，jal（Jump and Link）和jalr（Jump and Link Register）是用于实现函数调用和返回的指令。</li>
</ol>
<p>jal（Jump and Link）指令用于无条件跳转到指定的相对地址，并将下一条指令的地址保存到指定的寄存器中（通常是ra，即返回地址寄存器）。这种方式常用于函数调用。例如，如果你想调用一个函数，可以用jal ra, function_label，这里function_label是函数的标签。</p>
<p>jalr（Jump and Link Register）指令则用于无条件跳转到由寄存器加上一个常数偏移得到的地址，并将下一条指令的地址保存到指定的寄存器中。这种方式通常用于函数返回，例如jalr x0, 0(ra)，这里ra存储了返回地址。</p>
<p>总的来说，这两条指令在函数的调用和返回上扮演着关键角色，使得程序可以跳转到函数执行，执行完毕后再返回到调用点继续执行。</p>
<ol start="3">
<li><p>在 main 中 printf 的 jalr 之后，寄存器 ra 中有什么值？<br>RISC-V 的 jal &#x2F; jalr 指令会把下一条指令（return address）的地址放到寄存器 ra 中。例如，如果 main 中有：</p>
<p> jalr ra, t0</p>
</li>
</ol>
<p>  调用了 printf<br>那么执行这条指令后，ra 会保存调用 jalr 指令的下一条指令的地址（即返回地址）。用更通俗的话说，ra 中是 “调用完 printf 函数后要回来继续执行的那条指令地址”。</p>
<ol start="4">
<li>在 RISC-V 的 32 个通用寄存器中，函数调用时约定将前 8 个函数参数放在 a0 ~ a7 中（超过 8 个的参数会放在栈中）。因此：</li>
</ol>
<p>第 1 个参数：存储在 a0<br>第 2 个参数：存储在 a1<br>第 3 个参数：存储在 a2<br>依此类推，直到 a7<br>如果在 main 中的调用形如：</p>
<p>c<br>复制代码<br>printf(“%d”, 13);<br>那么：</p>
<p>“%d” 这个字符串指针会放在 a0<br>13 会放在 a1<br>因此，13 最终存放在寄存器 a1。</p>
<h2 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h2><h2 id="第五章课本"><a href="#第五章课本" class="headerlink" title="第五章课本"></a>第五章课本</h2><p>驱动程序必须处理与硬件同时发生的事件<br>这里同时的含义并不是同时进行 同时表示的是它们的交互式同步的 当请求硬盘读写操作的时候 驱动先发命令 之后等待 硬件完成之后触发中断 驱动程序需要立刻做出反应</p>
<p>驱动程序运行分为两个部分<br>第一个部分运行在进程的内核线程中&#x2F;&#x2F; </p>
<p>驱动程序实际上是操作系统的一部分，输入操作系统的一部分<br>它需要与硬件设备交互，并执行特定的系统级任务。在这些任务中，涉及到访问硬件资源和处理中断等操作，这些操作需要更高的权限，因此 驱动程序必须运行在内核空间。因此，当系统调用或者中断发生时，驱动程序就进入了内核空间。</p>
<p>进程：是操作系统中资源分配的基本单位，每个进程都有独立的虚拟地址空间、文件描述符等。进程在用户空间和内核空间都有运行的时机。</p>
<p>线程：是进程内部的执行单位，多个线程可以在同一个进程中共享资源（例如内存、文件描述符等）。每个线程有自己的执行栈和程序计数器。</p>
<p>这部分为主要部分 上半个部分的代码会请求设备进行I&#x2F;O操作 读取和写入数据 这些操作命令提供给硬件运行 之后等待硬件完成这个命令</p>
<p>第二部分就是下半部分 当上面的命令运行之后就会实行中断处理 这个中断执行后 操作系统就会调用中断处理程序执行下半部分的代码。这部分代码主要会检查哪些操作已经完成了  更新一下设备状态。 特殊的情况会唤醒等待过程中的进程</p>
<h2 id="5-1-控制台的输入"><a href="#5-1-控制台的输入" class="headerlink" title="5.1 控制台的输入"></a>5.1 控制台的输入</h2><p>控制台驱动程序 连接到XV6中的uart串口接收用户通过串口输入的字符 uart::通用串行通信硬件接口。<br>接收用户的输入  处理输入行通过回车隔离<br>这个起始不属于控制台程序的本职工作了：通过read系统调用读取标准输入：：允许用户进程在程序中读取用户的键盘输入</p>
<p>uart 硬件的内存映射<br>这个内存映射是一种硬件访问方式 允许通过常规的内存操作：loarcd 和store 与硬件是设备进行交互<br>这个交互重点是 uart硬件通过内存映射的控制寄存器来与操作系统交互<br>具体解释1<br>内存映射控制的寄存器 uart硬件通过一组控制寄存器与操作系统进行交互。每个寄存器有着自己的作用，读入输入的字符 检查输入缓存区是否为空<br>LSR寄存器 这个寄存器包含了多个标志位 其中一个标志表示的是是否又需要读取的输入字符。如果有需要的，操作系统可以通过读取RHR寄存器获取这些字符</p>
<p>总的来讲就是这个硬件与操作系统的交互所有的操作都是使用了进程之中的寄存器来进行交互的</p>
<p>FIFO被使用 作为uart硬件缓存输入字符的程序 FIFO寄存器用于暂时存储从外部设备接收得到的数据 当操作系统读取输入的时候 操作系统救赎从FIFO寄存器中获取字符。</p>
<p>需要阐明的是： 当操作系统读取输入的字符的时候实际上是RHR寄存器读取的 但是RHR本质上就是一个FIFO队列的入口。FIFO这个队列属于先进先出：Receiver Holding Register</p>
<p>[UART 硬件]<br>  ↓  外部设备（键盘）输入字符<br>  ↓  数据进入 UART 内部的 FIFO（如果启用 FIFO）<br>  ↓  FIFO 里有数据时，UART 自动把 FIFO 头部字符放到 RHR<br>  ↓  操作系统从 RHR 读取数据<br>  ↓  FIFO 头部数据被删除，FIFO 向前移动</p>
<p>严格来说，0x10000000 是物理地址，不属于普通的内核虚拟地址，但：<br>✅ 在启用了 MMU 的 xv6 内核中，它会被映射到内核态的虚拟地址（通常 1:1 映射），使得内核可以通过这个虚拟地址访问它。<br>✅ 用户态进程无法访问 0x10000000，因为 MMU 的页表不会映射这个地址到用户空间。</p>
<p>UART在操作系统的整体流程：<br>1<br>main函数里面调用 consoleinit()初始化控制台<br>硬件行为变成了接收到一个字节生成一个接收中断<br>成功发送了一个字节生成一个发送完成中断<br>中断通知内核：：有新输入可以读取 需要把输入的字符处理并且存储起来<br>上一个字节发送完毕了 可以继续发送新的字节了</p>
<p>2<br>shell进程是init进程 通过open获取控制台输入的文件描述符 之后可以用read来获取读入<br>这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd =<span class="built_in">open</span>(<span class="string">&quot;/dev/console&quot;</span>,O_REWD);</span><br><span class="line">这里使用了fd读取键盘的输入</span><br><span class="line">问题是文件描述符在哪里 但是这个他把对应的文件修改了属性 变换成了 可以读写</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(fd,buf,size)<span class="comment">//这里使用了获取的文件描述符</span></span><br><span class="line">首先使用了系统调用机制read进入系统内核</span><br><span class="line">之后进入了console.<span class="function">c</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> 的实际实现会调用 <span class="title">consoleread</span><span class="params">()</span>，路径如下：</span></span><br><span class="line"><span class="function">用户进程 shell 调用 <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">→ 进入内核，调用 <span class="title">consoleread</span><span class="params">()</span>（kernel/console.c:<span class="number">82</span>）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">这个函数两个作用 一个是等待完整的输入 如果这个输入没有完整的一行 那么进入SLEEP让进程挂起等待中断 读取完整的输入</span></span><br><span class="line"><span class="function">第二个作用是拷贝输入数据到用户空间 如果存储已经他有了完整的一行输入 那么把数据复制到用户进程的缓存区并且放回</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">3</span> 在用户输入字符的时候 比如按键“a”这个时候uart会触发一个接收中断信号 </span></span><br><span class="line"><span class="function">uart触发外部中断 检测到输入了 发送中断信号给cpu 要求cou处理</span></span><br><span class="line"><span class="function">之后触发trap机制 进入了系统内核中断处理程序</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">devintr() 处理外部设备中断</span></span><br><span class="line"><span class="function">在 kernel/trap.c:<span class="number">177</span>，中断处理程序 devintr() 会检查 scause 寄存器，判断中断来源：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">devintr()  // kernel/trap.c:<span class="number">177</span></span></span><br><span class="line"><span class="function">它发现 中断来源是一个外部设备，于是调用 PLIC（Platform-Level Interrupt Controller），询问 哪个设备 触发了中断：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">plic_claim();</span>  <span class="comment">// kernel/trap.c:186</span></span><br><span class="line">如果 PLIC 告诉 xv6 是 UART 触发了中断，那么 <span class="built_in">devintr</span>() 会调用：</span><br><span class="line"><span class="built_in">uartintr</span>();  <span class="comment">// kernel/uart.c:180</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> 最后的函数处理uart输入</span><br><span class="line">在这个函数中uart驱动程序会通过读取RHR获取等待的输入字符</span><br><span class="line">之后把这些输入字符交给<span class="built_in">consoleintr</span>() 处理：</span><br><span class="line"></span><br><span class="line">函数负责存储输入字符到CONS.BUF中 这个是一个输入缓存区 存储用户输入的字符 直到形成一个整行</span><br><span class="line">处理特殊按键</span><br><span class="line">处理enter换行  当这个被识别到了之后 开始唤醒<span class="built_in">consoleread</span>()（kernel/console.c:<span class="number">82</span>） 这个既可</span><br><span class="line">把完整的输入存储在用户进程中</span><br><span class="line"></span><br><span class="line">最后：：返回输入数据，Shell 进程的 <span class="built_in">read</span>() 调用成功返回。</span><br><span class="line"></span><br><span class="line">完整的流程 如下：</span><br><span class="line">(<span class="number">1</span>) Shell 进程等待用户输入</span><br><span class="line">Shell 调用 <span class="built_in">read</span>(fd, buf, size)</span><br><span class="line">→ 内核调用 <span class="built_in">consoleread</span>()</span><br><span class="line">→ 如果没有输入，进程 <span class="built_in">sleep</span>()</span><br><span class="line">(<span class="number">2</span>) 用户按下键盘</span><br><span class="line">用户按下 <span class="string">&#x27;a&#x27;</span></span><br><span class="line">→ UART 硬件检测到输入</span><br><span class="line">→ UART 触发 RISC-V 外部中断</span><br><span class="line">→ 进入 xv6 的陷阱处理程序 <span class="built_in">trap</span>()</span><br><span class="line">(<span class="number">3</span>) 内核处理中断</span><br><span class="line"><span class="built_in">trap</span>() 调用 <span class="built_in">devintr</span>()</span><br><span class="line">→ 发现 UART 设备触发了中断</span><br><span class="line">→ 调用 <span class="built_in">uartintr</span>()</span><br><span class="line">→ 读取 UART 硬件的 RHR 寄存器</span><br><span class="line">→ 调用 <span class="built_in">consoleintr</span>() 处理字符</span><br><span class="line">(<span class="number">4</span>) 内核存储输入</span><br><span class="line"><span class="built_in">consoleintr</span>() 将字符存入 cons.buf</span><br><span class="line">→ 如果按下了 Enter，调用 <span class="built_in">wakeup</span>() 唤醒 <span class="built_in">read</span>() 进程</span><br><span class="line">(<span class="number">5</span>) 进程读取数据</span><br><span class="line"><span class="built_in">consoleread</span>() 复制 cons.buf 中的数据到用户进程</span><br><span class="line">→ <span class="built_in">read</span>() 调用返回，Shell 获取输入</span><br></pre></td></tr></table></figure>
<h2 id="控制台的输出"><a href="#控制台的输出" class="headerlink" title="控制台的输出"></a>控制台的输出</h2><p>1 进程调用write把数据写入控制台 控制台是由UART硬件实现的<br> write(fd, “hello”, 5);&#x2F;&#x2F;这是想要给控制台也就是uart设备写入hello<br> write 在内核中的执行流程：<br> 用户进程 write()  &#x2F;&#x2F;因为是系统调用所以也就需要使用对应内核态里面的数据<br>→ 进入内核态<br>→ 调用 consolewrite()（kernel&#x2F;console.c）<br>→ 调用 uartputc()（kernel&#x2F;uart.c:87）<br>consolewrite() 是控制台的 write() 实现，负责处理控制台的输出。<br>consolewrite() 会逐个字符调用 uartputc()，把数据传输到 UART 设备。</p>
<p>2 uartputc()把数据写入uart设别<br>采用缓冲区 uart_tx_buf 避免进程阻塞<br>由于 UART 设备传输速度较慢（可能是 115200 bps，每秒大约 11.5 KB），如果进程每次都等待 UART 发送完成，CPU 资源会被浪费。因此，xv6 采用 缓冲区（uart_tx_buf） 来 缓存待发送数据。</p>
<p>具体逻辑 uartputc<br>1调用write，之后字符进入了人进入缓冲区 然后uartputc 立即返回 不需要等待uart传输完成<br>如果uart空闲呢 那么会调用uartstart开始传输 如果缓存区满了 uartputc进程会进入sleep（）等待缓冲区有空间</p>
<p>2<br>uartstart 仅在uart设备空闲的时候启动拆散农户<br>检测uart是否正在发送过程<br>如果设备空闲 从缓存区去除一个字节并送入到uart的THR(Transmit Holding Register)<br>让uart开始发送这字节 并且返回让进程继续运行下去</p>
<p>如果 write(“hello”) 发送 “hello”：</p>
<p>uartputc(‘h’) 先把 ‘h’ 放入 uart_tx_buf，然后 uartstart() 让 UART 设备开始发送。<br>uartputc(‘e’) 只是放入 uart_tx_buf，不需要立即发送（因为 UART 仍在发送 ‘h’）。<br>进程不会等待 UART 传输，而是继续运行。</p>
<p>3 设备完成发送后触发中断<br>uart硬件会调用 uartintr<br>这个的作用在于检查是否真的完成了字节发送<br>如果缓存区还有数据 会继续调用uartstart继续发送下一个字节数据</p>
<p>UART 发送完 ‘h’，触发中断：</p>
<p>uartintr() 读取 uart_tx_buf，发现 ‘e’ 还在缓冲区。<br>uartintr() 调用 uartstart() 发送 ‘e’。<br>UART 发送完 ‘e’，再次触发中断：</p>
<p>uartintr() 发现还有 ‘l’，继续调用 uartstart() 发送 ‘l’。<br>这个过程持续，直到 uart_tx_buf 为空：</p>
<p>uartintr() 不再调用 uartstart()，UART 传输完成。</p>
<p>最后  为什么采用缓存区加中断的机制</p>
<p>这个机制是一种典型的设备I&#x2F;O并发模型 通过缓存区和中断解耦进程和设备的执行 提高性能<br>1 系统调用了write 数据进入了 缓存区 之后立即返回了 不需要等待uart硬件全都发完再进入下一个操作<br>cpu同时进行了多种操作 提高了系统的并发能力<br>2 uart通过中断驱动发送 在每一个字节发完之后 自动把缓存区中的一个数据取出 让uart继续传输<br>进程和设备可以并发执行 提高吞吐量  这个中断触发了之后响应的是硬件 但是也会进入trap环节 同时这个环节会检测寄存器看到底是什么原因引发的中断 之后就正常进行了</p>
<p>慢速设备（如 UART，网络）——进程不需要等待设备完成，避免浪费 CPU 时间。<br>需要立即响应的场景（如终端输入回显 echo）——键入的字符可以立即显示，而不影响进程执行。</p>
<p>✅ 进程调用 write()，数据进入 uart_tx_buf，然后立即返回，不等待 UART 传输完成。<br>✅ UART 设备通过 uartstart() 发送第一个字节，后续字节由 UART 触发中断后继续发送。<br>✅ UART 每发送完 1 字节，触发中断，调用 uartintr() 继续发送下一个字节，直到 uart_tx_buf 为空。<br>✅ 这种机制提高了进程和设备的并行度，避免 CPU 在 I&#x2F;O 过程中的空转，提升系统性能。</p>
<p>这就是 xv6 控制台输出的完整流程 🚀。</p>
<h2 id="控制台驱动的并发问题"><a href="#控制台驱动的并发问题" class="headerlink" title="控制台驱动的并发问题"></a>控制台驱动的并发问题</h2><p>consoleread 作用纯纯就是把uart输入到缓存区的数据转换到用户进程缓存区中<br>consoleintr 这个是每一次发一个字符就一个中断之后的处理程序 把输入存储到缓存区里面</p>
<p>处理三种并发风险<br>第一种<br>两个不同的cpu同时调用 consoleread </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU1: <span class="built_in">read</span>(fd, buf, size)   <span class="comment">// 进程 A</span></span><br><span class="line">CPU2: <span class="built_in">read</span>(fd, buf, size)   <span class="comment">// 进程 B</span></span><br></pre></td></tr></table></figure>
<p>这样就出现了两个进程同时修改cons.buf缓存区 导致无法直到具体输入了什么数<br>一个没有问题 另一个读不全了<br>所以在consolread加了一条个acquair(&amp;cons.lock)加锁 确保只有一个cpu能修改这个buf缓存区</p>
<p>第二种情况<br>在正在把缓存区数据转换到用户进程缓存区里面的时候出发了uart中断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = cons.buf[pos];</span><br><span class="line"><span class="comment">//读取了缓存区的数据呢</span></span><br><span class="line"><span class="comment">//这个时候</span></span><br><span class="line"><span class="built_in">consoleintr</span>(c)；<span class="comment">//这回有新的数据从外部进来触发中断了</span></span><br></pre></td></tr></table></figure>
<p>可能还没有准阿姨呢 BUF里面的数据已经被修改完了<br>所以在中断输入处理函数CONSOLREINTR里面也使用acquair(&amp;cons.lock)加锁 确保只有一个能修改cons.buf</p>
<p>第三种<br>在xv6的多核系统只用 中断可能不会再正在普通输入转换函数运行的cpu上触发 而是在另一个cpu上触发处理了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU1: 进程 A 运行 <span class="built_in">consoleread</span>()</span><br><span class="line">CPU2: UART 触发中断 -&gt; 执行 <span class="built_in">consoleintr</span>()</span><br></pre></td></tr></table></figure>
<p>也是同一个问题 两个进程同时对缓存区进行了修改 或者一个cpu在另一个cpu还没有转换完就去修改缓存区 这样会数据丢失<br>解决方案也是在中断输入处理函数里面加入锁 这样确保所有cpu访问这个缓存区的时候是互斥的</p>
<p>这里有一个疑问 就是中断处理程序不能假设正在运行的进程仍然是被中断的进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程 A 运行中...</span></span><br><span class="line">UART 触发中断 → 进入 <span class="built_in">trap</span>() → <span class="built_in">devintr</span>() → <span class="built_in">uartintr</span>()</span><br></pre></td></tr></table></figure>
<p>在中断处理（uartintr()）执行时，进程 A 可能已经被调度器替换为进程 B。<br>这意味着：<br>uartintr() 并不属于任何进程，它运行在 独立的内核上下文，所以 不能依赖“当前进程”。</p>
<p>正因为这样就不能使用copyout这个函数了 这个函数的作用是吧当前的内核数据拷贝到当前进程的用户空间中去<br>因为中断发生处理的过程中 这个当前正在运行的进程可能已经变了</p>
<p>为了减少这种情况出现 解决方案就是中断处理程序只做最少的工作<br>只把数据存入到缓存区 不直接对数据进行处理 同时唤醒consolerread 这个是转换到用户进程的函数<br>让他在正确的进程上下文中执行copyout()；</p>
<p>总结一下<br>✅ acquire() 保护 cons.buf 免受多 CPU 和中断的并发访问，防止数据竞争。<br>✅ UART 中断处理程序不能假设它运行在特定进程的上下文，因此不能直接调用 copyout()，只能存数据并唤醒 consoleread()。<br>✅ 采用“上半部分（进程）+ 下半部分（中断）”模型，确保数据处理在正确的进程上下文中完成。</p>
<p>触发中断时，当前进程确实会“暂停”<br>进程 A 正在运行时，UART 发送完一个字节，触发 设备中断。<br>CPU 进入 trap()，执行 uartintr() 处理 UART 设备。<br>此时，进程 A 的状态会被保存，等待 CPU 处理完中断后恢复。<br>✅ 但中断处理结束后，CPU 不一定会继续执行原来的进程<br>如果 trap() 发现进程 A 仍然可以运行（没有触发调度），它会继续执行进程 A，用户进程不会察觉到这个短暂的中断。<br>如果 trap() 发现有更高优先级的任务（比如 sleep() 触发了进程切换），那么 CPU 可能会切换到进程 B。<br>✅ 什么时候会发生进程切换？<br>进程 A 进入 sleep()（例如 write() 等待 UART 发送完成）。<br>进程 A 的时间片耗尽，trap() 发现需要 yield() 进行调度。<br>另一个进程被 wakeup() 唤醒，并且优先级更高，调度器选择它执行。</p>
<h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>定时器中断是操作系统用来保持时钟更新并实现时间片轮转调度的一种机制。它使操作系统能够定期打断当前执行的进程<br>定时触发之后操作系统可以决定是否切换到另一个进程</p>
<p>进程切换：yield调用用于进程切换，它是xv6中协作式多任务的机制之一。当操作系统检测到定时器中断时，它会通过usertrap和kerneltrap来执行yield，从而让当前进程让出CPU，允许其他进程执行。</p>
<p>同时这个定时器中断只能处在机器模式而不是管理模式下运行定时器中断在机器模式下发生，而非管理模式下（即操作系统的正常运行模式）。机器模式下代码没有虚拟内存的保护，可以直接访问硬件资源，但它通常不适合运行应用程序或操作系统的核心代码。</p>
<p>由于机器模式下无法直接执行xv6的普通内核代码，xv6必须特别处理定时器中断。当定时器中断发生时，RISC-V硬件会进入机器模式，xv6需要通过特定的代码来处理这种中断。</p>
<h2 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h2><p>虚拟内存的两个好处<br>隔离性<br>提供映射抽象 处理器和所有指令都可以使用虚拟内存</p>
<p>所以缺页就从这个映射抽象出发提供了一个新的功能<br>除了下面两个就只用静态影射了<br>trampline 使得内核可以将一个物理内存page映射到多个用户地址空间中<br>guard page 在不同空间中保护栈</p>
<p>通过缺页 内核就能更新页表的映射关系</p>
<h2 id="6-竞态锁的条件"><a href="#6-竞态锁的条件" class="headerlink" title="6 竞态锁的条件"></a>6 竞态锁的条件</h2><p>进程的并发执行：：假设有两个进程在两个不同的 CPU 上同时运行，这两个进程调用 wait 函数来释放它们的子进程内存。当子进程终止时，内核会释放与之关联的内存。<br>在每个 CPU 上，内核会调用 kfree() 函数来释放子进程占用的内存页面。</p>
<p>内存分配：：使用一个空闲页面的链表来管理内存页面。这些页面通过 kalloc() 函数分配（从空闲页面列表中取出），而通过 kfree() 函数释放（将页面添加回空闲页面列表）。<br>kalloc() 和 kfree() 都需要操作空闲页面链表。</p>
<p>并发执行？：：<br>为了提高系统的性能，我们可能希望在不同的 CPU 上同时执行 kfree() 操作，而不需要相互等待。这样做的好处是可以提高系统的吞吐量，使得多个进程能够并行释放内存。<br>然而，并行执行kfree()可能会导致问题，因为两个进程可能会同时修改共享的空闲页面链表。如果没有适当的同步机制（如锁），这种并行执行会导致数据竞争和错误。例如，一个进程可能会删除链表中的页面，而另一个进程则可能会尝试操作已经被删除的页面，从而导致内存访问错误。</p>
<p>锁的必要性：<br>为了防止这种竞态条件，锁（例如互斥锁）是必要的。当一个进程执行 kfree() 时，它需要获取锁来保证空闲页面链表的操作是互斥的。这样，另一个进程就不能在同一时间修改链表，从而避免数据损坏。<br>锁保证了在同一时刻，只有一个进程可以操作空闲页面链表，其他进程必须等待，直到锁被释放。</p>
<p>竞争的结果取决于进程在处理器运行的确切时机以及内存系统如何排序它们的内存操作，这可能会使竞争引起的错误难以复现和调试。例如，在调试push时添加printf语句可能会改变执行的时间，从而使竞争消失。</p>
<p>避免竞争的通常方法是使用锁。锁确保互斥，这样一次只有一个CPU可以执行push中敏感的代码行；这使得上述情况不可能发生。上面代码的正确上锁版本只添加了几行（用黄色突出显示）：<br>更新锁的简单代码·</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个链表元素结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">element</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;                <span class="comment">// 存储数据的字段</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">element</span> *next;    <span class="comment">// 指向链表中下一个元素的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表头指针，初始化为 NULL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">element</span> *list = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个锁，用于保护对链表的访问</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lock</span> listlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 函数：将新数据添加到链表的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">element</span> *l;  <span class="comment">// 声明一个指针 l，用于指向新创建的链表元素</span></span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);  <span class="comment">// 为新节点分配内存空间，大小为 struct element 的大小</span></span><br><span class="line">    l-&gt;data = data;         <span class="comment">// 将传入的数据存入新节点的 data 字段</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;listlock);     <span class="comment">// 获取锁，确保在修改链表时没有其他线程/进程同时访问链表</span></span><br><span class="line"></span><br><span class="line">    l-&gt;next = list;         <span class="comment">// 将新节点的 next 指针指向当前的头节点（即链表的第一个元素）</span></span><br><span class="line"></span><br><span class="line">    list = l;               <span class="comment">// 将链表的头指针 list 更新为新节点，新的节点现在是链表的头</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">release</span>(&amp;listlock);     <span class="comment">// 释放锁，允许其他线程/进程访问链表</span></span><br><span class="line">&#125;</span><br><span class="line">创建了一个新的节点指向头节点之后 把这个新的节点定义为头节点 就是头插法整这么复杂</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们说锁保护数据时，我们实际上是指锁保护适用于数据的某些不变量集合<br>您可以将锁视为串行化（serializing）并发的临界区域，以便同时只有一个进程在运行这部分代码，从而维护不变量（假设临界区域设定了正确的隔离性）。您还可以将由同一锁保护的临界区域视为彼此之间的原子，即彼此之间只能看到之前临界区域的完整更改集，而永远看不到部分完成的更新</p>
<p>讨论锁本身对性能的影响<br>例如，如果两个进程并发调用 kfree()，并且在同一个资源（如链表）上使用锁，那么即使这两个进程在不同的 CPU 上运行，锁将串行化这两个调用，也就是说它们不能同时进行。这是因为在获取锁时，必须等待另一个进程释放锁，这样就无法充分利用多核 CPU 的并行计算能力。</p>
<p>锁争用发生在多个进程或线程竞争同一个锁时。如果两个进程同时请求获取相同的锁，而此时锁已经被另一个进程持有，那么这两个进程就会进入等待状态，直到锁被释放。这种情况会导致性能下降，因为进程&#x2F;线程不得不等待，而不能并行执行</p>
<p>每个CPU可能维护一个独立的空闲页面链表。这意味着，每个CPU都有自己的内存资源列表，它们可以在自己的列表中分配内存页面，而无需去访问其他CPU的资源列表。只有在某个CPU的空闲列表为空时，它才会去访问其他CPU的列表。<br>这种策略叫做CPU本地化（locality），它的目标是减少不同CPU之间的内存访问，从而减少锁争用。每个CPU自己管理自己的资源，只有在必要时才发生跨CPU的资源共享。<br>更复杂的设计：对于一些更复杂的内核，可能需要更多的优化技术。例如，使用 读写锁（read-write lock）、自旋锁（spinlock）等机制来优化锁的争用情况。<br>读写锁允许多个线程同时读取资源，但在写操作时只允许一个线程进行，避免了不必要的等待</p>
<h2 id="6-2自旋锁和睡眠锁"><a href="#6-2自旋锁和睡眠锁" class="headerlink" title="6.2自旋锁和睡眠锁"></a>6.2自旋锁和睡眠锁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">    lk-&gt;locked =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个 CPU 在检查 lk-&gt;locked 时看到它是 0，然后都认为自己可以获取锁。<br>因此，它们都设置了 lk-&gt;locked &#x3D; 1，这导致 两个不同的 CPU 同时持有锁，从而破坏了互斥锁的核心属性 —— 互斥性（即同一时刻只能有一个 CPU 持有锁）。</p>
<p>在 RISC-V 架构中，提供了一个名为 amoswap 的指令，这个指令可以实现原子交换（atomic swap）。它的作用是：</p>
<p>读取内存地址 a 处的值。<br>将寄存器 r 的内容写入该内存地址。<br>将该内存地址原来的值放入寄存器 r。<br>具体来说，amoswap r, a 指令会：</p>
<p>原子地交换内存地址 a 的值和寄存器 r 的值。<br>在执行交换的过程中，硬件会防止其他 CPU 在读取和写入之间进行干扰，从而保证这个操作的原子性。</p>
<p>所以在这个操作系统在中锁的获取函数 acquir 内部包装的是原子操作，<br>具体流程如下<br>1.<br>自选也就是循环 在使用了这个函数的时候吧 会返回锁之前的赋值同时把锁的值置为1<br>2.<br>判定这个返回的值是否为1 如果返回值为 1，则说明另一个 CPU 已经持有了锁，当前 CPU 需要继续尝试获取锁。Xv6 采用自旋锁的方式，即不断重试，直到成功获取锁。<br>如果返回值为 0，意味着在交换操作之前，锁的状态是 0（未被锁定），那么当前线程成功获得了锁。<br>3.<br>获得锁以后：acquire 还会记录下锁的持有者，即记录哪个 CPU 获取了锁。这是通过修改 lk-&gt;cpu 来实现的，该字段仅在持有锁的情况下才可以被更改</p>
<p>4 对应release函数<br>release 函数用于释放锁，它的操作和 acquire 函数相反：</p>
<p>清除 lk-&gt;cpu 字段，表示锁不再被任何 CPU 持有。<br>将 lk-&gt;locked 设置为 0，表示释放锁。</p>
<p>简介<br>原子操作：为了确保互斥锁的正确性，acquire 和 release 需要使用原子操作来防止锁的争用和竞态条件。<br>硬件支持：RISC-V 提供了 amoswap 指令，帮助实现原子交换操作，以保证多核处理器下的同步。<br>自旋锁机制：acquire 使用自旋（busy-waiting）机制，反复尝试获取锁，直到成功获得锁。<br>可移植性：通过 __sync_lock_test_and_set 和 __sync_lock_release 等 C 库函数，Xv6 在不同平台上也能保证原子操作的实现。</p>
<h3 id="睡眠锁本身"><a href="#睡眠锁本身" class="headerlink" title="睡眠锁本身"></a>睡眠锁本身</h3><p>自旋锁本身会浪费cpu资源：：当锁被长时间持有时，其他进程的 CPU 时间会被浪费，因为它们在自旋等待，而不能继续执行其他任务。</p>
<p>如果为了节省资源而进行cpu让步：当锁被长时间持有时，其他进程的 CPU 时间会被浪费，因为它们在自旋等待，而不能继续执行其他任务。会出现死锁<br>自旋锁的实现通常是一个不断检查的循环（自旋）。如果进程在持有自旋锁的过程中让出了 CPU 控制权（例如通过调用 yield()），并且另一个进程试图获取相同的锁，这将导致死锁。因为 acquire（获取锁的函数）不让出 CPU，如果第二个进程在自旋时也需要获取该锁，它会阻塞第一个进程的运行，进而导致死锁。</p>
<p>定义：睡眠锁：当一个进程尝试获取睡眠锁时，如果该锁已经被其他进程持有，它会让出 CPU 并进入睡眠状态，直到锁被释放。这种方式避免了自旋锁的 CPU 浪费问题，因为等待锁的进程不会占用 CPU 资源，而是进入一个阻塞状态，允许其他进程运行。</p>
<p>尽管 睡眠锁本身 允许进程在等待时让出 CPU，但它的 内部状态 需要通过 自旋锁 来保护。这是因为：</p>
<p>并发访问问题：在多核或多线程的系统中，如果多个进程或线程同时试图修改睡眠锁的状态（例如，锁是否被持有，哪个进程正在等待锁等），就会导致 竞态条件，可能会破坏睡眠锁的正确性和一致性。<br>保证原子性：自旋锁用于确保对睡眠锁的操作是原子的。也就是说，在修改睡眠锁的内部状态时，必须确保在同一时刻只有一个进程能够进行修改操作，这样就避免了并发访问可能引发的不一致问题。</p>
<h3 id="两种锁的限制范围"><a href="#两种锁的限制范围" class="headerlink" title="两种锁的限制范围"></a>两种锁的限制范围</h3><p>睡眠锁不能在中断处理中使用：因为睡眠锁 会让出 CPU（当进程等待锁时，它会进入阻塞状态，放弃对 CPU 的控制），这会与中断处理程序的要求冲突。在中断处理中，系统需要确保快速响应外部事件，而如果中断处理程序尝试获取睡眠锁并被阻塞，它将导致系统响应延迟或不可预测的行为。因此，睡眠锁不能在中断处理程序中使用。</p>
<p>睡眠锁不能在自旋锁临界区中使用：这是因为，acquiresleep 会导致当前进程让步 CPU，当进程尝试获取睡眠锁时，它会放弃 CPU 的控制权。如果睡眠锁在自旋锁的临界区内使用，那么当进程在 acquiresleep 中等待时，它会让步 CPU，但是由于 自旋锁的临界区内不允许让步 CPU，这会导致死锁或不可预期的行为。</p>
<h2 id="6-3锁使用·条件"><a href="#6-3锁使用·条件" class="headerlink" title="6.3锁使用·条件"></a>6.3锁使用·条件</h2><p>首先，任何时候可以被一个CPU写入，同时又可以被另一个CPU读写的变量，都应该使用锁来防止两个操作重叠。其次，请记住锁保护不变量（invariants）：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁来保护，以确保不变量不被改变。</p>
<p>为了提高效率，不要在不必要的地方加锁是非常重要的。如果没有锁的保护，多线程程序可能会出现竞态条件，导致错误；但如果锁的使用过度，可能会导致性能下降，尤其是在多核系统中，过多的锁会阻碍多个 CPU 并行执行任务。</p>
<p>大内核锁：：它的做法是在进入内核时获取一个全局的锁，并在退出内核时释放这个锁。这意味着在进入内核的过程中，所有 CPU 必须排队等候同一个锁，这样就避免了对多个内核资源的锁竞争。<br>缺点：虽然这种方式能确保内核操作的互斥性，但它牺牲了并行性。因为只要有一个 CPU 获取了锁，其他 CPU 就无法进入内核执行任务。这就导致了一个瓶颈，如果内核需要执行较为繁重的计算，那么整个系统的性能会受到极大影响，无法充分利用多核处理器的计算能力。</p>
<p>作为粗粒度锁的一个例子，xv6的kalloc.c分配器有一个由单个锁保护的空闲列表。如果不同CPU上的多个进程试图同时分配页面，每个进程在获得锁之前将必须在acquire中自旋等待。自旋会降低性能，因为它只是无用的等待。如果对锁的争夺浪费了很大一部分CPU时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲列表，每个列表都有自己的锁，以允许真正的并行分配。</p>
<p>作为细粒度锁定的一个例子，xv6对每个文件都有一个单独的锁，这样操作不同文件的进程通常可以不需等待彼此的锁而继续进行。文件锁的粒度可以进一步细化，以允许进程同时写入同一个文件的不同区域。最终的锁粒度决策需要由性能测试和复杂性考量来驱动</p>
<h2 id="6-4死锁和锁排序"><a href="#6-4死锁和锁排序" class="headerlink" title="6.4死锁和锁排序"></a>6.4死锁和锁排序</h2><p>死锁定义：假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。假设线程T1执行代码路径1并获取锁A，线程T2执行代码路径2并获取锁B。接下来T1将尝试获取锁B，T2将尝试获取锁A。两个获取都将无限期阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。为了避免这种死锁，所有代码路径必须以相同的顺序获取锁。全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者必须以一种使锁按照约定顺序被获取的方式调用函数。</p>
<p>锁顺序链：Xv6 中的多个锁通常有一个锁顺序链，即一组锁按照特定的顺序进行获取。一个典型的锁链包括进程锁（p-&gt;lock）和其他资源的锁（如控制台锁、文件系统锁等）。<br>例如，在处理控制台输入时，consoleintr 需要获取 cons.lock，然后才能调用 wakeup 函数来唤醒等待的进程。为了避免死锁，wakeup 在唤醒进程时需要获取进程的锁，因此 consoleintr 必须先获取 cons.lock，然后再获取进程的锁。</p>
<p>为了避免死锁，Xv6 文件系统代码规定了一种严格的锁获取顺序：<br>获取目录上的锁。<br>获取新文件 inode 的锁。<br>获取磁盘块缓冲区上的锁。<br>获取磁盘驱动程序的 vdisk_lock。<br>获取进程的锁（p-&gt;lock）。</p>
<h2 id="6-5-锁的中断处理函数"><a href="#6-5-锁的中断处理函数" class="headerlink" title="6.5 锁的中断处理函数"></a>6.5 锁的中断处理函数</h2><p>在 定时器中断处理程序 clockintr 中，每次定时器中断触发时，程序都会增加 ticks 的值。这是对 ticks 的写操作。<br>内核线程 在执行 sys_sleep 系统调用时，它会读取 ticks 的值来判断进程是否应该继续睡眠，或者是否需要唤醒。这是对 ticks 的读操作。<br>由于 ticks 是一个共享变量，clockintr 和 sys_sleep 可能会同时访问它，这就会导致 数据竞争，即一个进程正在修改 ticks 的值，而另一个进程正在读取它，这可能导致不一致的数据或错误的行为。</p>
<p>为了避免这种数据竞争和确保 ticks 的一致性，Xv6 使用了 tickslock 这个自旋锁。具体地：</p>
<p>tickslock 用于保护 ticks 变量的访问，确保在任意时刻，只有一个进程或中断处理程序可以访问 ticks。<br>当 clockintr 需要更新 ticks 时，它必须先获取 tickslock，确保没有其他进程或中断同时访问或修改 ticks。<br>同样，在 sys_sleep 中，内核线程也必须获取 tickslock 才能安全地读取 ticks 变量。</p>
<p>这产生了一个问题：<br>在 sys_sleep 系统调用中，内核线程获取了 tickslock 锁，准备读取或操作 ticks 变量。<br>然后，定时器中断发生了，打断了正在运行的 sys_sleep 进程。中断处理程序 clockintr 会试图获取 tickslock，以更新 ticks 的值。<br>由于 tickslock 已经被 sys_sleep 持有，clockintr 会等待锁的释放。然而，问题出现在这里：sys_sleep 不能释放 tickslock，因为它的执行被中断了，它必须等到 clockintr 处理完毕并返回后才能继续执行。<br>这样就形成了一个死锁：sys_sleep 等待 clockintr 返回，而 clockintr 又等待 sys_sleep 释放锁。由于没有任何进程可以继续执行，系统陷入死锁</p>
<p>这里有个前提条件：当系统运行中的一个进程（例如 sys_sleep）正在执行时，硬件定时器可能会发出一个定时器中断（如 clockintr）。中断机制允许系统中断当前正在执行的代码，并立刻去执行一个特定的中断处理程序（clockintr）。这是一个异步的事件，意味着进程的执行被打断，转而执行中断处理程序。</p>
<p>解决方案<br>避免自旋锁被中断处理程序所使用的一个关键原则是：如果一个自旋锁被中断处理程序所使用，那么 CPU 必须保证在启用中断的情况下，永远不能持有该锁。这意味着，防止进程持有锁时中断发生，可以通过禁用中断来确保。<br>虽然禁用了当前 CPU 上的中断，其他 CPU 上的中断仍然可以发生，导致其他 CPU 上的中断处理程序自旋等待，但不会导致死锁。</p>
<p>多个锁的嵌套<br>嵌套临界区：当一个进程在持有锁的情况下调用其他需要获取锁的操作时，就会进入一个嵌套的临界区。例如，如果在一个临界区内再次调用 acquire 来请求同一个锁，那么就进入了一个嵌套的锁获取过程。为了避免中断干扰，我们需要精确跟踪锁的嵌套级别。<br>push_off：在获取锁时，acquire 会调用 push_off 来禁用当前 CPU 上的中断。它还会记录中断禁用的层级，以便跟踪嵌套的临界区。<br>pop_off：在释放锁时，release 会调用 pop_off 来恢复最外层临界区开始时的中断使能状态。当嵌套的临界区完成时，它会检查是否可以恢复中断。</p>
<p>顺序<br>在 acquire 函数中，必须在设置锁状态之前调用 push_off，也就是在锁的获取之前禁用中断。这样做是为了确保在锁获取过程中，中断不会打断当前进程，否则会产生一个 短暂的窗口期，在这个窗口期内，系统可能会允许中断发生，进而引发 死锁。<br>release 和 pop_off 的顺序：在 release 函数中，必须在释放锁之后调用 pop_off。这也有助于恢复最外层临界区的中断状态，确保中断状态只在没有锁被持有时才恢复。</p>
<h2 id="6-6指令和内存访问顺序"><a href="#6-6指令和内存访问顺序" class="headerlink" title="6.6指令和内存访问顺序"></a>6.6指令和内存访问顺序</h2><p>编译器和中央处理器为了获得更高的性能而不按顺序执行代码<br>编译器和CPU在重新排序时需要遵循一定规则，以确保它们不会改变正确编写的串行代码的结果。然而，规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</p>
<p>为了告诉硬件和编译器不要执行这样的重新排序，xv6在acquire(kernel&#x2F;spinlock.c:22) 和release(kernel&#x2F;spinlock.c:47)中都使用了__sync_synchronize()。__sync_synchronize()是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序load或store指令。因为xv6在访问共享数据时使用了锁，xv6的acquire和release中的障碍在几乎所有重要的情况下都会强制顺序执行。</p>
<h2 id="锁本身的开销问题："><a href="#锁本身的开销问题：" class="headerlink" title="锁本身的开销问题："></a>锁本身的开销问题：</h2><p>锁竞争的开销：在多核处理器系统中，当多个 CPU 竞争同一锁时，缓存一致性和同步机制带来的开销可能非常昂贵。<br>无锁编程的优势与挑战：无锁编程通过避免锁来提高性能，但它的实现要比有锁编程更复杂，涉及到诸如内存重新排序等问题。<br>Xv6 的选择：Xv6 避免了无锁编程的复杂性，选择了使用有锁的数据结构来简化开发，并避免了无锁编程的额外挑战。</p>
<h2 id="页表项查找好的例子"><a href="#页表项查找好的例子" class="headerlink" title="页表项查找好的例子"></a>页表项查找好的例子</h2><p>假设我们有一个 64 位虚拟地址，并且系统采用 4KB 页面大小，以及 4级页表结构（如 x86-64 架构）。在这种系统中，虚拟地址被分解为多个部分，每一部分用于查找不同层级的页表。</p>
<p>假设系统参数<br>虚拟地址长度：64 位<br>页面大小：4KB（即 PGSIZE &#x3D; 4096）<br>页表项大小：8 字节（64 位系统下通常为 8 字节）<br>虚拟地址结构：根据 x86-64 架构，64 位虚拟地址分解为以下几个部分：<br>PML4 索引：9 位<br>PDPT 索引：9 位<br>PDT 索引：9 位<br>页内偏移：12 位<br>虚拟地址结构示意图<br>PML4 索引（9 位）<br>PDPT 索引（9 位）<br>PDT 索引（9 位）<br>页内偏移（12 位）<br>因此，一个 64 位虚拟地址可以分为：</p>
<p>复制<br>| PML4 索引 (9 位) | PDPT 索引 (9 位) | PDT 索引 (9 位) | 页内偏移 (12 位) |<br>例子<br>假设我们有一个虚拟地址 0x00007FFFBF3A5000。</p>
<p>将虚拟地址转为二进制：</p>
<p>text<br>复制<br>0x00007FFFBF3A5000 &#x3D; 0000 0000 0000 0111 1111 1111 1111 1011 1111 0011 1010 0101 0000 0000<br>分解虚拟地址： 我们将地址分解成 PML4 索引、PDPT 索引、PDT 索引和页内偏移。</p>
<p>PML4 索引（第 1-9 位）：000000111 → 7<br>PDPT 索引（第 10-18 位）：111111111 → 511<br>PDT 索引（第 19-27 位）：111110011 → 497<br>页内偏移（第 28-39 位）：101000000000 → 0xA00<br>查找过程<br>查找 PML4 页表：</p>
<p>从虚拟地址的 PML4 索引部分（7）开始，查找 PML4 页表。<br>PML4 页表是一个由 512 个条目（每个 8 字节）组成的数组，因此我们会查找索引 7 对应的条目。<br>这个条目存储的值是一个物理地址，指向 PDPT（Page Directory Pointer Table） 页表。<br>例如，假设 PML4 索引 7 对应的页表项是物理地址 0x00000000001F4000，那么我们知道，PDPT 页表就存储在物理地址 0x00000000001F4000 开始的位置。</p>
<p>查找 PDPT 页表：</p>
<p>使用虚拟地址中的 PDPT 索引部分（511），查找 PDPT 页表。<br>PDPT 页表也是一个包含 512 个条目的数组（每个条目 8 字节），所以我们查找索引 511 对应的条目。<br>假设 PDPT 页表项指向物理地址 0x00000000001F8000。<br>查找 PDT 页表：</p>
<p>使用虚拟地址中的 PDT 索引部分（497），查找 PDT 页表。<br>PDT 页表的结构与 PDPT 页表类似，也是一个包含 512 个条目的数组。<br>假设 PDT 页表项指向物理地址 0x0000000000200000。<br>查找物理页框：</p>
<p>最后，使用虚拟地址中的页内偏移部分（0xA00）来定位页内的具体位置。<br>PDT 页表项指向的物理地址（0x0000000000200000）表示物理页框的基址，结合页内偏移，得到最终的物理地址。<br>物理地址 &#x3D; 0x0000000000200000 + 0xA00 &#x3D; 0x000000000020A000。</p>
<h2 id="cow-的一个记忆点"><a href="#cow-的一个记忆点" class="headerlink" title="cow 的一个记忆点"></a>cow 的一个记忆点</h2><p>COW 页面 主要用于 用户空间，而 copyin 函数是从 用户空间 读取数据到 内核空间，没有涉及写操作，所以不需要考虑 COW 页面的状态。<br>COW 只在用户空间写操作时有效，因此 copyin 只需关心从用户空间正确读取数据即可，不需要判断是否是 COW 页面或处理 COW 机制。<br>内核空间 和 用户空间 是隔离的，内核读取用户空间数据时不需要担心是否是 COW 页面。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h2 id="7-1多路复用"><a href="#7-1多路复用" class="headerlink" title="7.1多路复用"></a>7.1多路复用</h2><p>避免并发争用（锁机制）： 在多核系统中，多个CPU核心可能同时尝试在进程之间切换，因此必须采取有效的同步机制来避免争用。xv6 使用了锁来防止多个处理器同时修改进程调度的状态，确保在进程切换时，只有一个核心能够执行相关的调度操作。否则，可能会导致不一致的内存状态或调度错误，影响系统的稳定性。</p>
<p>多核系统中的进程管理： 在多核机器上，每个核心都可能在不同的进程之间切换，因此必须确保每个核心都能够准确地知道自己正在执行哪个进程。xv6 通过在每个核心上维护一个当前执行进程的指针来管理这个问题。这可以确保系统调用能够正确地影响到正在执行的进程的内核状态。</p>
<p>如果一个进程结束后直接被重启，它将无法继承之前的内存数据，因为这些数据已经在进程退出时被回收。要在进程重启时继续使用之前的数据，必须采用持久化存储（如文件或数据库）来保存重要数据，或者在系统中实现检查点恢复机制。</p>
<h2 id="7-2-线程调度-上下文切换"><a href="#7-2-线程调度-上下文切换" class="headerlink" title="7.2 线程调度-上下文切换"></a>7.2 线程调度-上下文切换</h2><p>调度程序线程并不属于被暂停的进程，它是操作系统内核的一部分，负责在进程切换时决定下一个应该运行的进程。进程和线程之间的关系是，进程包含多个线程，但调度程序线程是内核的一部分，负责进程调度的工作，而不是用户进程的线程。</p>
<p>这段话描述了从一个用户进程切换到另一个用户进程时的详细步骤，特别是涉及到的上下文切换（context switch）和用户-内核转换的过程。我们可以将其分解并简要概述为：</p>
<p>用户-内核转换： 当一个用户进程需要执行系统调用或响应硬件中断时，它会从用户模式切换到内核模式。这个过程是通过触发系统调用或中断来完成的，使得当前的用户进程进入内核执行环境。</p>
<p>上下文切换： 进程切换时需要进行上下文切换。首先，操作系统需要保存旧进程的状态（如寄存器、程序计数器等），然后恢复新进程的状态，确保进程在恢复时能够从正确的位置继续执行。</p>
<p>从旧进程到当前CPU调度程序线程的上下文切换： 这个步骤是指操作系统从一个用户进程切换到调度程序线程。调度程序负责选择下一个要执行的进程，它运行在内核模式下，处理所有的调度决策。</p>
<p>从当前CPU调度程序线程到新进程的上下文切换： 调度程序确定了下一个要执行的进程后，会进行另一次上下文切换，这次是从调度程序线程切换到新进程的内核线程，恢复新进程的状态并准备好继续执行。</p>
<p>返回到用户级进程： 最后，内核将执行权交回给新进程的用户空间，这时进程进入用户模式，并开始执行用户代码。</p>
<p>注意这里的上下文说的就是进程本身的寄存器状态（如程序计数器 PC、栈指针 SP 等）</p>
<p>尽管内核空间本身是共享的，但每个进程在执行内核代码时都会有自己的内核栈。这个栈用于存储内核级的局部变量、函数调用等信息。因此，内核栈会随着进程切换而切换，即不同进程的内核栈在内核空间中是隔离的。<br>进程切换时，内核会保存当前进程的内核栈指针、程序计数器等信息，并恢复新进程的相关信息。因此，内核栈会随着进程切换而切换，但内核代码和内核空间的其他部分是共享的。</p>
<p>每个进程在内核中有自己的进程控制块（struct proc）和上下文（struct context），这些结构体用于保存进程的状态（如寄存器、程序计数器、栈指针等）。虽然这些结构体位于内核空间，但它们是独立于其他进程的，每个进程有自己对应的 struct proc 和 struct context。</p>
<p>truct context结构体：<br>这个结构体用来保存线程的寄存器集。它通常包含程序计数器、栈指针等信息，以便在切换时保存和恢复上下文。<br>struct context结构体可能会包含进程相关的状态信息。不同的操作系统或实现可能会对这个结构体有不同的定义，但它的核心目的是保存一个线程执行所需的状态信息</p>
<p>swtch函数有两个参数：</p>
<p>struct context *old：这是一个指向当前线程上下文的指针，swtch函数会将当前线程的寄存器值（如程序计数器、栈指针等）保存在old结构体中。<br>struct context *new：这是一个指向目标线程上下文的指针，swtch函数会将目标线程的寄存器值从new结构体中加载，恢复目标线程的执行状态。</p>
<h2 id="上下文切换的两个例子"><a href="#上下文切换的两个例子" class="headerlink" title="上下文切换的两个例子"></a>上下文切换的两个例子</h2><p>第一个<br>usertrap 调用 yield：</p>
<p>在 xv6 中，进程通常在执行系统调用时会触发一个陷阱（trap）。例如，当一个进程调用 yield 函数时，它表示该进程愿意放弃CPU的使用权，将CPU的控制权交给调度程序，以便调度其他进程。usertrap 是处理系统调用的函数之一，它会调用 yield。<br>yield 调用 sched：</p>
<p>yield 是一种主动放弃 CPU 使用权的机制，它通过调用 sched 来进行进程的调度。sched 负责将当前进程的上下文保存下来，并将调度程序的上下文恢复，继续执行调度程序。<br>sched 调用 swtch：</p>
<p>swtch 是上下文切换的核心函数。它负责保存当前进程的上下文，并将 CPU 控制权转移到调度程序。具体来说，swtch 将当前进程的上下文（保存了寄存器状态等）保存在 p-&gt;context 中，然后从 cpu-&gt;scheduler 中恢复调度程序的上下文。<br>swtch 函数：</p>
<p>swtch 的作用是切换进程或线程的执行状态（即上下文切换）。它的关键操作是保存当前执行的寄存器（callee-saved registers）并恢复新进程或线程的寄存器状态。<br>保存寄存器：swtch 只保存 被调用方保存的寄存器（callee-saved registers），而不保存调用方保存的寄存器（caller-saved registers）。在需要时，调用方会在栈上保存这些寄存器的值。<br>寄存器偏移量：swtch 知道 struct context 中每个寄存器字段的偏移量，从而可以正确地保存和恢复这些寄存器的值。<br>程序计数器（PC）：swtch 不会直接保存程序计数器的值，因为程序计数器实际上是通过 ra 寄存器来实现的。<br>ra 寄存器：ra 寄存器保存的是返回地址（即调用 swtch 时的返回地址），它指向当前进程调用 swtch 的返回指令。swtch 会在执行完上下文切换后，从 ra 寄存器恢复执行。<br>恢复新进程的上下文：</p>
<p>当 swtch 函数返回时，它从新进程的上下文中恢复寄存器值（这些寄存器是在之前调用 swtch 时保存的）。具体而言，swtch 会恢复 ra 寄存器，以确保新进程能够从正确的位置继续执行。<br>这也意味着，swtch 切换到的新进程的执行会从上次它调用 swtch 的位置开始，这保证了上下文切换后的无缝过渡。</p>
<p>返回新线程的栈：注意这里的存储的ra就是表示当这个进程被恢复的时候PC计数从哪个地方开始<br>swtch 在返回时还会在新线程的栈上返回，这意味着新线程的栈指针会被恢复，执行状态能够恢复到新线程的上下文。</p>
<p>保存的是ra寄存器而不是程序寄存器 用以区别</p>
<p>第二个例子<br>切换到 ls 程序的步骤：<br>保存当前进程（cc）的上下文：</p>
<p>当前正在运行的进程是 cc，在上下文切换发生时，操作系统会保存 cc 进程的当前执行状态（即上下文）。这包括 cc 的 内核寄存器（例如栈指针、程序计数器等）和 栈指针。cc 的内核线程的上下文保存在一个 context 对象中。<br>切换到 ls 程序：</p>
<p>由于 ls 程序之前运行过，所以它的状态是 RUNABLE，意味着 ls 程序处于可执行状态，并且它之前的执行上下文已经被保存。</p>
<p>用户空间状态：</p>
<p>在 ls 程序切换时，操作系统需要恢复 ls 的用户空间状态。ls 的用户空间状态（例如栈、局部变量、程序计数器等）被保存在一个 trapframe 中。这是因为当进程从内核空间返回用户空间时，trapframe 里保存了这些信息。<br>内核线程状态：</p>
<p>ls 程序的内核线程（也就是 ls 在内核模式下的执行状态）保存了其内核寄存器（程序计数器、栈指针等）。这些寄存器状态被保存在 context 对象中，类似于 cc 进程保存状态的方式。<br>恢复 ls 程序的内核线程的上下文：</p>
<p>接下来，操作系统恢复 ls 程序的内核线程状态。具体来说，操作系统会从 ls 的 context 对象中恢复其内核寄存器（包括程序计数器、栈指针等），将这些寄存器的值加载到 CPU 中，使得 ls 程序能够继续执行。<br>继续在 ls 的内核线程栈上执行：</p>
<p>恢复内核线程的上下文后，ls 程序会继续在其内核线程的栈上运行，完成中断处理程序或系统调用。<br>恢复 ls 程序的用户空间状态：</p>
<p>在进入用户空间之前，操作系统需要恢复 ls 程序的用户空间状态。ls 程序的用户空间状态（如栈、寄存器等）已经保存在 trapframe 中。操作系统会恢复这些寄存器的值，以确保 ls 能够从它上次停止的位置恢复执行。<br>返回到用户空间：</p>
<p>最后，swtch 函数会通过 trapframe 恢复 ls 程序的程序计数器（PC）和栈指针（SP），并切换到用户模式。这样，ls 程序就能够从之前中断的地方继续执行，恢复到用户空间的状态，继续运行用户代码。<br>关键点解析<br>trapframe 和 context：</p>
<p>trapframe：用于保存用户空间的状态（如栈、程序计数器等）。它在进程从内核空间返回用户空间时非常重要。<br>context：用于保存进程的内核空间状态，包括寄存器、栈指针等。当发生上下文切换时，内核会保存和恢复这些状态。<br>进程切换时的状态恢复：</p>
<p>在进程从内核切换到用户空间时，操作系统首先恢复内核状态，然后再恢复用户状态，确保程序能够从正确的地方恢复执行。<br>context 和 trapframe 提供了进程切换时所需要的所有状态信息。<br>无缝过渡：</p>
<p>通过在 swtch 中恢复新进程的上下文（包括内核和用户空间的状态），操作系统能够确保进程在上下文切换后继续执行。无论是切换到一个新进程还是恢复一个已暂停的进程，操作系统都能够保持进程的执行流不受影响。</p>
<h2 id="调度切换和进程切换的区别"><a href="#调度切换和进程切换的区别" class="headerlink" title="调度切换和进程切换的区别"></a>调度切换和进程切换的区别</h2><p>进程的上下文和调度程序的上下文<br>进程的上下文（context）：</p>
<p>每个进程都有一个与其相关的上下文，通常由操作系统在进程切换时保存和恢复。这个上下文包含了进程在内核模式下的所有重要状态，主要包括进程的寄存器状态（如程序计数器、栈指针、通用寄存器等）。<br>进程的上下文存储在一个 context 结构体中，这个结构体会在进程切换时被保存和恢复。<br>context 的典型内容：</p>
<p>程序计数器（PC）：保存当前执行的指令地址。<br>栈指针（SP）：指向当前进程的栈。<br>其他寄存器：保存进程执行时使用的寄存器值，如 eax, ebx, ecx 等。<br>调度程序的上下文（cpu-&gt;scheduler）：</p>
<p>调度程序（scheduler）是负责调度各个进程的内核部分，它运行时也有自己的上下文。调度程序的上下文通常存储在每个 CPU 的 struct cpu 对象中的 scheduler 字段。cpu-&gt;scheduler 存储了调度程序在执行时的寄存器状态。<br>调度程序上下文：调度程序本身也会使用 context 结构体来保存其执行时的状态，但它与进程的上下文不同。调度程序的上下文通常保存在 struct cpu 的 scheduler 字段中，这样操作系统能够恢复调度程序的状态，并让其继续执行。</p>
<h2 id="7-3-代码调度"><a href="#7-3-代码调度" class="headerlink" title="7.3 代码调度"></a>7.3 代码调度</h2><p>持有 p-&gt;lock 的重要性：在进行上下文切换时，xv6 强制要求在调用 swtch 前持有进程锁 p-&gt;lock，以防止在切换过程中进程的状态（如 p-&gt;state 和 p-&gt;context）被其他 CPU 修改。这样可以确保进程切换的安全性，避免栈上的竞争。<br>为什么打破惯例：通常，获取锁的线程负责释放锁，但在上下文切换中，swtch 必须打破这一惯例，因为如果没有锁保护，其他 CPU 可能会在 swtch 切换期间操作进程的栈，导致栈冲突和系统不一致。<br>避免栈冲突：通过确保 swtch 执行期间持有锁，xv6 保证了上下文切换的过程中栈和其他进程状态的一致性，防止出现两个 CPU 在同一个栈上运行的问题。</p>
<p>打破惯例就是说<br>在上下文切换时，必须释放 p-&gt;lock，以防止死锁并确保调度程序能够运行。通过释放锁，操作系统确保了上下文切换过程中多个 CPU 不会同时在同一进程的栈上执行，从而避免栈冲突等错误。</p>
<p>在上下文切换时，进程 A 获取了锁（p-&gt;lock），并通过调用 sched 或 yield 来放弃 CPU，准备切换到调度程序。<br>但是，这时 进程 A 并不会自己释放锁。而是，调度程序负责释放锁，并且调度程序会在它完成任务后继续调度其他进程。这就是打破惯例的地方</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>调度（sched）和产量（yield）通常指代在特定工作流或计划中的安排和预计结果。<br>sched 和 yield 的区别<br>sched：通常是操作系统中的底层函数，用于执行进程调度。它会处理当前进程的状态更新、上下文保存，并通过 swtch 切换到调度程序的上下文。</p>
<p>yield：是一个高层函数，通常由进程调用，表示当前进程自愿放弃 CPU。它的目的是让进程能够主动放弃 CPU，让调度程序选择其他进程运行。yield 通过调用 sched 来完成上下文切换和调度。</p>
<p>总结<br>sched 是 进程调度的底层实现，负责进行进程的上下文切换和选择下一个进程运行。<br>yield 是 进程主动放弃 CPU 的高层接口，通过调用 sched 实现进程的调度和切换。<br>swtch 是 xv6 操作系统中的上下文切换函数，用于保存当前进程的状态并恢复新进程的状态。它是实现进程调度和任务切换的核心部分，使得操作系统能够在多个进程之间切换执行。</p>
<p>truct proc 是每个进程的 进程控制块，它存储了进程的状态、上下文、栈指针、进程锁等信息。<br>struct proc 实例存储在 进程表（ptable） 中，这是一个全局的进程数组。进程表用于管理所有进程。<br>进程的内核栈 是由操作系统为每个进程单独分配的，用来存储进程在内核模式下的临时数据。<br>进程控制块和内核栈是 分开管理的，但是进程控制块中会包含对内核栈的引用。</p>
<h2 id="初始化调度"><a href="#初始化调度" class="headerlink" title="初始化调度"></a>初始化调度</h2><p>在大多数情况下，进程通过调用 sched 来放弃 CPU，并由调度程序（scheduler）选择一个新的进程运行。然而，新进程的第一次调度 有一个特别的处理方式：<br>forkret 是一个特殊的函数，专门用于 新进程 被调度时的初始处理。它会被调用来启动新进程，并释放 进程锁（p-&gt;lock）。<br>usertrapret 是另一个可能的入口点，用于当新进程已经准备好返回用户模式时开始执行。<br>forkret 的作用：forkret 的关键作用是释放新进程的锁（p-&gt;lock），使得调度程序能够继续执行并选择合适的进程。如果不释放锁，可能会阻止其他进程的调度</p>
<p>2 调度程序的工作流程<br>调度程序的循环：scheduler 在内核模式下运行，它会不断循环查找 RUNNABLE 状态的进程。RUNNABLE 状态表示该进程准备好被调度执行。<br>选择进程：scheduler 会扫描 进程表，寻找一个 状态为 RUNNABLE 的进程，表示它可以被调度执行。一旦找到这样的进程，调度程序就会标记该进程为 RUNNING 并开始执行。<br>“一旦找到一个进程，它将设置CPU当前进程变量c-&gt;proc，将该进程标记为RUNNING，然后调用swtch开始运行它</p>
<p>3进程不变量的维护<br>xv6 中，调度程序需要确保每个进程的状态在切换期间保持一致。这些规则被称为 不变量（invariants），在上下文切换过程中，必须确保这些不变量始终成立。<br>如果一个进程正在 运行（RUNNING），并且计时器中断（如 yield）要求从该进程切换出去，那么 swtch 必须保证：<br>当前进程的寄存器状态被保存（这些寄存器的值不会丢失）。<br>c-&gt;proc 必须指向当前正在运行的进程，这样操作系统才能正确恢复该进程的上下文。<br>上面是runnning的情况 下面是runnable的情况<br>如果进程是RUNNABLE状态，空闲CPU的调度程序必须安全地运行它；这意味着p-&gt;context必须保存进程的寄存器（即，它们实际上不在实际寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的c-&gt;proc引用进程</p>
<p>这里是锁的情况<br>在上下文切换期间，p-&gt;lock 必须保持被持有状态，直到进程的上下文切换完成。否则，进程的状态可能会发生竞争性修改，导致不一致。<br>例如，如果进程正在运行，锁不能释放，否则可能导致 调度程序无法正确调度。同样，当一个进程从 RUNNABLE 状态切换到 RUNNING 状态时，p-&gt;lock 必须在进程开始运行之前保持被持有，确保在恢复进程上下文之前，进程的状态不被干扰</p>
<p>保持锁的原因<br>yield 调用期间，锁必须保持直到调度程序通过清除 c-&gt;proc 完成切换，并恢复不变量。<br>在 scheduler 中，将 RUNNABLE 进程切换为 RUNNING 时，锁必须在切换之前保持，直到上下文完全切换并且新的进程准备好执行</p>
<h2 id="7-4-mycpu-和myproc-cpu的单核与多核"><a href="#7-4-mycpu-和myproc-cpu的单核与多核" class="headerlink" title="7.4 mycpu 和myproc cpu的单核与多核"></a>7.4 mycpu 和myproc cpu的单核与多核</h2><p>在单核系统中，操作系统通常使用一个 全局变量 来指向 当前运行的进程 的 proc 结构体。由于系统只有一个 CPU，所以当前正在运行的进程是唯一的，因此全局指针足以跟踪当前进程。<br>在多核系统中，每个 CPU 核心可能同时运行不同的进程。由于每个核心的进程可能不同，单个全局变量 就无法正确地标识每个核心上正在运行的进程。</p>
<p>xv6 为每个 CPU 核心维护一个 struct cpu 结构体。每个 struct cpu 记录了与该 CPU 核心相关的信息：<br>当前在该核心上运行的进程（如果有的话）。<br>调度线程的寄存器，用于保存当前 CPU 调度线程的状态。<br>用于 管理中断禁用的嵌套自旋锁计数，确保在内核中安全地禁用中断。</p>
<p>在多核系统中，xv6 需要通过 每个 CPU 的唯一标识符 来查找相关的 struct cpu。具体的做法是：<br>每个 CPU 都有一个唯一的 hartid（硬件线程 ID）。在 RISC-V 架构中，hartid 是由硬件提供的，它是每个 CPU 核心的唯一标识符。<br>xv6 确保每个 CPU 的 hartid 存储在该 CPU 的 tp 寄存器中。tp 寄存器是 RISC-V 架构中的一个通用寄存器，用于存储该核心的唯一 ID。<br>通过 mycpu() 函数（位于 kernel&#x2F;proc.c 中），xv6 可以根据当前 CPU 的 hartid 找到对应的 struct cpu 实例。具体做法是：<br>mycpu() 使用 tp 寄存器中的 hartid 来 索引 cpus[] 数组，cpus[] 数组存储了每个 CPU 的 struct cpu。<br>通过 tp 获取 hartid，然后使用 hartid 来查找对应的 struct cpu，从而访问该核心的信息。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>tp 寄存器 是 RISC-V 架构中用于存储每个 CPU 核心的 hartid 的寄存器。每个 CPU 核心都有一个 唯一的硬件线程 ID（hartid），它用来区分不同的 CPU 核心。</p>
<p>在 xv6 中，mstart 函数在 CPU 启动的早期阶段设置 tp 寄存器，以便为每个 CPU 核心分配唯一的 hartid。<br>这发生在系统启动时，mstart 位于 kernel&#x2F;start.c 的第 46 行，在机器模式下进行。这时，CPU 还处于 机器模式（即最低级的特权模式），所以可以直接设置 tp 寄存器。</p>
<p>在用户进程运行时，tp 寄存器的值可能会被修改。这是因为用户程序可能会修改 tp 寄存器。然而，操作系统通过 usertrapret 来处理这个问题：<br>usertrapret 在用户空间的 蹦床页面（trampoline page） 中保存了 tp 寄存器的值。<br>对此：：当程序从用户空间进入内核空间时（如发生系统调用或异常），uservec 函数会恢复 tp 寄存器的值。这个过程确保了内核能够正确获取当前 CPU 核心的 hartid。<br>编译器保证 tp 寄存器永远不会被直接使用，确保它用于保存 CPU 核心的唯一标识符，并且不会被不小心覆盖。</p>
<p>如果 RISC-V 架构直接允许 xv6 读取当前的 hartid，操作会更加简单。但由于 RISC-V 的限制，xv6 只能在 机器模式下读取 hartid，而在管理模式（如内核模式）下无法直接读取 hartid。因此，操作系统必须通过寄存器来维护 hartid，并保证其在不同操作模式下的一致性。</p>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p>cpuid 和 mycpu 函数返回当前 CPU 的信息，但这些返回值是 脆弱的，可能会因为 定时器中断（timer interrupt）而失效。具体来说，当一个进程在 CPU 上运行时，计时器中断可能会导致进程 让步（yield），并且这个进程可能会被调度到另一个 CPU 核心上。<br>如果定时器中断发生，并且该进程被移到另一个 CPU 核心，之前由 cpuid 或 mycpu 返回的 struct cpu 信息将变得无效。因为返回的 CPU 信息 是针对当前运行的 CPU 的，而一旦进程迁移到其他 CPU，这些信息将不再准确。</p>
<p>重点是错误在这里：是的，正如你所理解的，如果不禁用中断，错误通常出现在你获取的 进程信息（例如 c-&gt;proc）指向了 新的进程，而不是原来你获取时的进程。这是因为在获取进程信息的过程中，系统可能发生了 上下文切换。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>为了解决这个问题，xv6 要求 禁用中断，以避免中断在返回的 struct cpu 被访问时造成问题。操作系统禁用中断，确保 当前返回的 struct cpu 信息在该进程调度期间不会发生变化。</p>
<h2 id="调度程序副本-程序只有一个"><a href="#调度程序副本-程序只有一个" class="headerlink" title="调度程序副本 程序只有一个"></a>调度程序副本 程序只有一个</h2><p>在 单核系统 中，调度程序是 全局的，只有一个调度线程，负责调度所有进程。<br>在 多核系统 中，调度程序在每个 CPU 核心上都有 独立的执行实例。每个 CPU 核心都有自己的调度线程，这些调度线程独立工作，调度本地的进程</p>
<p>调度程序的代码本身是 共享的，即所有的 CPU 核心都执行相同的调度程序代码。它并不是在每个核心上都存储一个完全独立的调度程序实例。每个核心都执行相同的调度逻辑，但调度的对象和调度的行为是基于该核心的 进程状态 来进行的。</p>
<h2 id="sleep-wakeup-睡眠与唤醒"><a href="#sleep-wakeup-睡眠与唤醒" class="headerlink" title="sleep wakeup 睡眠与唤醒"></a>sleep wakeup 睡眠与唤醒</h2><p>sleep 和 wakeup 是 xv6 中用于 条件同步 的机制，允许一个进程在等待某个事件时休眠，而另一个进程在事件发生后唤醒它。这种机制有助于进程间的协调与通信。<br>信号量（Semaphore） 是一种经典的同步工具，广泛用于生产者-消费者问题，通过维护一个计数器并提供 P 和 V 操作，来控制进程间的同步。<br>在多核系统中，信号量操作的正确性依赖于合理的同步手段，如锁机制、禁用中断等，确保多核系统中不同 CPU 上的进程能够正确协调。<br>这种 条件同步机制 是操作系统设计中非常重要的一部分，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个信号量结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;  <span class="comment">// 用一个自旋锁来保护信号量的操作，确保对信号量的访问是同步的</span></span><br><span class="line">    <span class="type">int</span> count;             <span class="comment">// 信号量的计数器，表示可用资源的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V 操作（signal），用于增加信号量，唤醒等待的进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);    <span class="comment">// 获取自旋锁，保护对信号量的操作，确保线程安全</span></span><br><span class="line">    s-&gt;count += <span class="number">1</span>;        <span class="comment">// 增加信号量的计数，表示一个资源已经被释放（可用资源数量加一）</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);    <span class="comment">// 释放自旋锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P 操作（wait），用于等待信号量，表示线程请求一个资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果信号量的计数为 0，表示没有可用资源，进入空循环等待</span></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        ;   <span class="comment">// 自旋等待，直到信号量的计数不为 0（有可用资源）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);    <span class="comment">// 获取自旋锁，进入临界区，操作信号量的计数</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;        <span class="comment">// 减少信号量的计数，表示一个资源已经被分配（可用资源数量减一）</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);    <span class="comment">// 释放自旋锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为了节省cpu资源</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">wakeup</span>(s);  <span class="comment">// !pay attention</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sleep</span>(s);  <span class="comment">// !pay attention</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出现问题 如果已经睡觉了 在改变就起不来了：</span></span><br><span class="line">丢失唤醒 问题发生的原因是：当 P 操作判断信号量为零后，它进入休眠状态，并在 <span class="built_in">wakeup</span>(s) 被调用后未能正确地 检测到信号量的变化。此时，P 进程被唤醒，但是它仍然没有及时执行后续逻辑，造成它 永远等待，即便信号量已经变为非零。</span><br><span class="line">这个问题的根本原因是 P 操作中的休眠机制与 V 操作的唤醒机制并未完全同步，</span><br><span class="line">这个锁和程序一起睡着了无法被修改了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决问题</span></span><br><span class="line">引入条件锁：修改后的 sleep 接口要求调用者将条件锁（condition lock）传递给 sleep。这意味着消费者在调用 sleep 进入休眠时，必须将信号量的锁传递给 sleep，确保信号量的操作在整个过程中保持同步。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);   <span class="comment">// 获取信号量的锁，保护信号量操作的原子性</span></span><br><span class="line">    s-&gt;count += <span class="number">1</span>;        <span class="comment">// 增加信号量的计数，表示释放了一个资源</span></span><br><span class="line">    <span class="built_in">wakeup</span>(s);            <span class="comment">// 唤醒在信号量 s 上休眠的进程（如果有）</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);    <span class="comment">// 释放信号量的锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);    <span class="comment">// 获取信号量的锁，保护信号量操作的原子性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)  <span class="comment">// 如果信号量计数为 0，表示没有资源可用</span></span><br><span class="line">        <span class="built_in">sleep</span>(s, &amp;s-&gt;lock); <span class="comment">// 进入休眠 释放信号量锁</span></span><br><span class="line"></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;         <span class="comment">// 资源可用，减少信号量的计数，表示消费了一个资源</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);     <span class="comment">// 释放信号量的锁，允许其他线程访问信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个函数的内部实现"><a href="#两个函数的内部实现" class="headerlink" title="两个函数的内部实现"></a>两个函数的内部实现</h2><p>sleep：将当前进程标记为 SLEEPING 状态，然后调用 sched 函数释放 CPU，等待其他进程运行。当前进程将进入睡眠状态，直到被唤醒。<br>wakeup：查找在特定等待通道（chan）上休眠的进程，并将其标记为 RUNNABLE，使其可以重新加入就绪队列，等待调度执行。</p>
<p>sleep 和 wakeup 之间存在 竞争条件，如果没有正确的同步机制，可能会导致进程在等待唤醒时错过信号或者唤醒不及时。因此，xv6 通过 锁 和 条件变量 机制来确保这两个操作正确执行。</p>
<p>sleep获得p-&gt;lock（kernel&#x2F;proc.c:559）。要进入睡眠的进程现在同时持有p-&gt;lock和lk。在调用者（示例中为P）中持有lk是必要的：它确保没有其他进程（在示例中指一个运行的V）可以启动wakeup(chan)调用。既然sleep持有p-&gt;lock，那么释放lk是安全的：其他进程可能会启动对wakeup(chan)的调用，但是wakeup将等待获取p-&gt;lock，因此将等待sleep把进程置于睡眠状态的完成，以防止wakeup错过sleep。</p>
<p>锁的获取和释放：</p>
<p>在 sleep 中，进程获取了 p-&gt;lock 和 lk，这是为了确保当前进程的状态能够在休眠时得到正确更新。这样做的目的是，确保在进程状态变为 SLEEPING 之前，没有其他进程能调用 wakeup(chan)。</p>
<p>在 wakeup 中，wakeup 在获取 p-&gt;lock 后执行，它可以安全地修改休眠进程的状态。由于 wakeup 会在进程休眠之前等待获取 p-&gt;lock，它保证了 sleep 完成并将进程标记为 SLEEPING 之前，不会错误地唤醒进程。</p>
<p>确保同步：</p>
<p>sleep 持有 p-&gt;lock 时释放其他锁（例如信号量锁 lk），而 wakeup 则通过 等待 p-&gt;lock，确保它不会错过 sleep 的休眠状态更新。因此，wakeup 在执行时不会干扰正在休眠的进程，避免了竞争条件。</p>
<p>有种例外情况<br>：如果 lk 和 p-&gt;lock 是同一个锁，在 sleep 函数中会导致死锁。避免死锁的办法是确保在调用 sleep 时，进程已经持有了 p-&gt;lock，而不需要再次获取锁。<br>在 sleep 中，进程必须保持 p-&gt;lock 直到它将自己标记为 SLEEPING，以确保 wakeup 能够正确地唤醒它。<br>如果 sleep 提前释放了 p-&gt;lock，就可能错过唤醒操作，因为 wakeup 会遍历进程表并依赖于 p-&gt;lock 来修改进程状态。</p>
<h2 id="这两个函数的锁规则"><a href="#这两个函数的锁规则" class="headerlink" title="这两个函数的锁规则"></a>这两个函数的锁规则</h2><p>进程会在休眠之前 检查条件，并在条件满足时进入睡眠。通过获取和释放锁的机制，进程 在标记为 SLEEPING 之前保持锁的持有，确保唤醒器进程（例如生产者进程）不会错过唤醒。<br>通过确保唤醒器持有锁，进程在休眠时进入睡眠通道，并且确保 wakeup 正确执行。<br>如果多个进程在同一个通道上休眠（例如多个消费者线程在等待同一个管道数据），一个 wakeup 调用会将它们都唤醒。<br>唤醒后，其中一个进程会读取管道中的数据，继续执行并获取它的锁。而其他被唤醒的进程会发现管道中没有数据，因此它们会 虚假唤醒（它们没有得到任何数据），于是它们再次进入休眠。<br>这个行为是 正常的，并且由 sleep 和 wakeup 的 循环机制 自动处理。唤醒后的进程会重新检查条件，并在条件不满足时再次调用 sleep，进入休眠状态。</p>
<h2 id="设计优势"><a href="#设计优势" class="headerlink" title="设计优势"></a>设计优势</h2><p>如果多个进程在同一个通道上休眠（例如多个消费者线程在等待同一个管道数据），一个 wakeup 调用会将它们都唤醒。<br>唤醒后，其中一个进程会读取管道中的数据，继续执行并获取它的锁。而其他被唤醒的进程会发现管道中没有数据，因此它们会 虚假唤醒（它们没有得到任何数据），于是它们再次进入休眠。<br>这个行为是 正常的，并且由 sleep 和 wakeup 的 循环机制 自动处理。唤醒后的进程会重新检查条件，并在条件不满足时再次调用 sleep，进入休眠状态。</p>
<h2 id="睡眠唤醒的管道实现"><a href="#睡眠唤醒的管道实现" class="headerlink" title="睡眠唤醒的管道实现"></a>睡眠唤醒的管道实现</h2><p>管道通过 struct pipe 来表示，其中包含几个关键字段：</p>
<p>lock：用于保护管道的访问，防止多个进程同时访问管道时发生竞争条件。<br>data：缓冲区，用于存储管道的数据，实际上是一个环形缓冲区（circular buffer）。<br>nread 和 nwrite：分别表示从管道中读取和写入的字节数。它们用于管理数据的流动和同步。</p>
<p>管道的 缓冲区是环形的，即数据写入缓冲区时，当到达缓冲区的末尾时，会重新写入到缓冲区的开始位置。这样，管道缓冲区可以充分利用空间。<br>索引是通过 nread % PIPESIZE 和 nwrite % PIPESIZE 来计算的，而不是直接使用 nread 或 nwrite。这是因为 nread 和 nwrite 只是计数器，并不代表环形缓冲区的实际索引位置。</p>
<p>管道中的 缓冲区满 的条件是 nwrite &#x3D;&#x3D; nread + PIPESIZE，这意味着生产者不能再写入更多数据，直到消费者读取一些数据</p>
<p>缓冲区为空 的条件是 nwrite &#x3D;&#x3D; nread，这意味着消费者不能再读取更多数据，直到生产者写入数据</p>
<p>管道实现生产者 消费者同步机制<br>ipewrite（生产者）<br>pipewrite 函数首先 获取管道锁，以确保对管道数据的修改是同步的。<br>然后，pipewrite 循环将数据写入管道，直到缓冲区被填满（pi-&gt;nwrite &#x3D;&#x3D; pi-&gt;nread + PIPESIZE）。<br>当缓冲区满时，pipewrite 会 调用 wakeup，唤醒可能正在等待的数据的消费者进程（piperead）。然后，pipewrite 进入休眠，等待消费者从管道中读取一些数据，这样生产者才可以继续写入。<br>睡眠机制：</p>
<p>当缓冲区满时，pipewrite 调用 sleep 进入休眠，释放 pi-&gt;lock，使得其他进程（如 piperead）可以获得锁并继续执行。<br>2. piperead（消费者）<br>piperead 在 获取管道锁 后，检查是否有数据可以读取。若管道为空（pi-&gt;nread &#x3D;&#x3D; pi-&gt;nwrite），则 调用 sleep 进入休眠，直到有数据可用。<br>当管道不为空时，piperead 会进入 for 循环，从管道中读取数据，并更新 nread。读取的数据可以被生产者再次写入。<br>唤醒生产者：读取完数据后，piperead 会 调用 wakeup，唤醒生产者进程（pipewrite），通知它可以继续写入数据。<br>睡眠机制：</p>
<p>piperead 在等待数据时调用 sleep 进入休眠，释放 pi-&gt;lock，使得生产者可以继续写入数据。<br>3. 唤醒机制<br>wakeup(p)：当一个进程调用 wakeup 时，它会唤醒在特定条件上休眠的进程。在管道的实现中，pipewrite 和 piperead 使用不同的休眠通道来避免互相干扰。生产者和消费者通过 wakeup 和 sleep 机制协调：<br>当缓冲区满时，生产者通过 wakeup 唤醒消费者，消费者读取数据后，生产者可以继续写入数据。<br>当缓冲区为空时，消费者通过 wakeup 唤醒生产者，生产者写入数据后，消费者可以继续读取数据。</p>
<h2 id="设计优势-1"><a href="#设计优势-1" class="headerlink" title="设计优势"></a>设计优势</h2><p>通过 sleep 和 wakeup 实现同步：</p>
<p>管道利用 sleep 和 wakeup 实现了 生产者-消费者同步，避免了繁忙等待（busy-waiting）和死锁。进程会在条件不满足时进入休眠，并在条件满足时唤醒。<br>分离的通道：</p>
<p>管道使用 不同的睡眠通道 来区分生产者和消费者，避免了它们之间的干扰。在一个通道上休眠的进程只会在该通道的条件满足时被唤醒，这提高了效率并减少了不必要的唤醒。<br>虚假唤醒的容忍：</p>
<p>由于条件检查是在循环中进行的，虚假唤醒不会导致程序错误。每次被唤醒的进程都会重新检查条件，确保它们只有在条件真正满足时才继续执行。</p>
<h2 id="wait-exit-kill"><a href="#wait-exit-kill" class="headerlink" title="wait exit kill"></a>wait exit kill</h2><p>exit 和 wait 之间的竞争：</p>
<p>父子进程之间的 wait 和 exit 调用可能会导致竞争条件和死锁，尤其是在多核系统中。<br>xv6 通过在 wait 中使用进程锁和条件锁（sleep 和 wakeup）来确保父进程能够安全地等待子进程退出，并避免死锁。<br>wait 中的锁管理：</p>
<p>父进程在获取其自身的进程锁（p-&gt;lock）后，通过检查子进程状态来决定是否需要进入休眠。如果没有子进程退出，父进程会进入休眠，直到一个子进程退出。<br>无锁检查 np-&gt;parent：</p>
<p>np-&gt;parent 是父进程的指针，在 wait 中用于查找子进程。由于只有父进程可以修改这个字段，所以在特定情况下，wait 可以安全地 无锁检查 np-&gt;parent。</p>
<h3 id="无锁检查"><a href="#无锁检查" class="headerlink" title="无锁检查"></a>无锁检查</h3><p>wait 在扫描进程表时，需要查看每个进程的 parent 字段，以便找到其子进程。<br>通常来说，共享变量（如 np-&gt;parent）应该由锁保护。然而，np-&gt;parent 在 xv6 中是 由父进程更改的，因此只有父进程能够修改 parent 字段，其他进程不能更改它。因此，在某些情况下，wait 可以 无锁检查 np-&gt;parent。<br>无锁检查的安全性：如果 np-&gt;parent 指向当前进程（p），那么它的值就不会被其他进程修改，除非当前进程自己更改它。因此，在这种情况下，无锁访问是安全的。</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>exit 系统调用用于让进程退出时执行一些必要的清理工作，包括：<br>记录退出状态码。<br>释放进程占用的资源。<br>将进程的子进程交给 init 进程（如果父进程不再存在）。<br>如果父进程在 wait 状态中，它会被唤醒，以便它可以清理子进程（从僵尸进程转为 UNUSED 状态）。<br>将退出的进程标记为 僵尸进程（ZOMBIE），并永久地让出 CPU。<br>当进程调用 exit 时，它并不是立刻完全消失，而是进入 ZOMBIE 状态，保留一些信息（如退出状态码），直到父进程调用 wait 来清理它。<br>在 ZOMBIE 状态下，进程的资源没有完全释放，它会保持存在，直到父进程通过 wait 处理它。</p>
<p>wait 调用：父进程调用 wait 等待子进程退出。如果子进程已退出，它会清理资源并返回子进程的退出状态。如果没有子进程退出，父进程会进入休眠，直到子进程退出。<br>锁的管理：exit 和 wait 必须遵循 相同的锁获取顺序 来避免死锁。父进程的锁和子进程的锁需要按照正确的顺序获取。<br>唤醒机制：通过 wakeup1 函数，exit 在将进程标记为 ZOMBIE 之前唤醒父进程，确保父进程能够在子进程退出时被唤醒并进行清理。</p>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>exit：</p>
<p>允许一个进程自己终止。当进程调用 exit 时，它会释放所有资源，将自己标记为 ZOMBIE 状态，并最终由父进程通过 wait 进行清理。<br>kill：</p>
<p>允许一个进程请求 终止 另一个进程。与 exit 不同，kill 使得一个进程能够请求其他进程终止。直接销毁进程的实现是复杂且风险较大的，特别是当进程正在做敏感操作时，例如在更新内核数据结构的过程中。<br>因此，kill 只会设置受害进程的 p-&gt;killed 标志，并在受害进程正在休眠时唤醒它。</p>
<p>kill 设置 p-&gt;killed：</p>
<p>kill 调用通过设置目标进程（受害进程）结构体中的 p-&gt;killed 标志来标记该进程需要被终止。<br>如果受害进程正在 休眠，kill 会调用 wakeup 唤醒受害进程。受害进程会在进入或离开内核时检查是否设置了 p-&gt;killed，如果是，它会调用 exit 来终止自己。<br>受害进程的行为：</p>
<p>如果受害进程处于用户空间，它很可能会在 系统调用 或 中断（例如定时器中断）时进入内核。当它进入内核时，usertrap 会检查 p-&gt;killed 标志，如果设置了该标志，进程将调用 exit 终止自己。<br>kill 并不立即终止受害进程，而是等待受害进程在某个时刻进入内核并检查 p-&gt;killed 标志。只有当进程进入内核时（例如通过系统调用或中断），它才会检查 p-&gt;killed，并决定是否终止自己。</p>
<h3 id="例-子"><a href="#例-子" class="headerlink" title="例 子"></a>例 子</h3><p>例如，在 virtio 驱动程序 中，进程可能在进行磁盘 I&#x2F;O 操作时被杀死。在这种情况下，磁盘操作是一个 原子操作，它可能需要一组 写入操作 来确保文件系统的正确状态。因此，尽管进程可能被标记为 killed，它会在磁盘 I&#x2F;O 操作完成后再进行检查，只有在完成操作后，它才会真正退出。<br>这意味着，尽管进程可能已经设置了 p-&gt;killed，但是它不会立刻退出，而是等到当前的系统调用（例如磁盘 I&#x2F;O）完成后，再由 usertrap 检查 p-&gt;killed 并最终终止进程。</p>
<h2 id="真实应用"><a href="#真实应用" class="headerlink" title="真实应用"></a>真实应用</h2><p>xv6本身用到的是轮询 一次运行每个进程<br>先级反转（priority inversion）和航队（convoys）。当低优先级进程和高优先级进程共享一个锁时，可能会发生优先级反转，当低优先级进程持有该锁时，可能会阻止高优先级进程前进。当许多高优先级进程正在等待一个获得共享锁的低优先级进程时，可能会形成一个长的等待进程航队；一旦航队形成，它可以持续很长时间。为了避免此类问题，在复杂的调度器中需要额外的机制。</p>
<p>在早期的实现中（如 Unix 和某些早期操作系统中），wakeup 函数需要扫描整个进程表，查找所有等待特定通道（chan）的进程。这个过程的时间复杂度较高，尤其是在进程数量增多时，扫描整个进程表会导致 性能瓶颈。<br>一个更好的解决方案是 使用数据结构 来替代 chan，该数据结构维护了在上面等待的所有进程列表。例如，现代操作系统（如 Linux）使用 等待队列（Wait Queue） 来高效地管理这些等待的进程。<br>Plan 9 操作系统使用 rendezvous point（集结点），它是一种同步机制，用来替代传统的 chan，并使得进程能高效地等待和唤醒。<br>在许多现代 线程库 中，类似的机制被称为 条件变量（Condition Variables），它们用于在多线程编程中协调线程的同步。<br>在这种机制下，sleep 被称为 wait，wakeup 被称为 signal 或 broadcast，</p>
<h3 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h3><p>在多进程或多线程环境中，当一个进程（或线程）在等待某个条件时被唤醒，wakeup 操作会唤醒所有在该条件下等待的进程或线程。如果条件已经满足，所有被唤醒的进程会 争先恐后 地执行，导致 大量进程 无效地检查条件，浪费 CPU 资源。<br>这种现象叫做 惊群效应（Thundering Herd Effect）。它的典型表现是多个进程或线程都竞争同一资源，但只有一个能获得资源，其他进程可能会再次进入 等待状态。<br>了避免惊群效应，现代的条件变量和进程同步机制通常提供两种唤醒操作：<br>signal：唤醒一个等待中的进程或线程。<br>broadcast：唤醒所有等待的进程或线程。<br>这里说一下定义<br> xv6 和大多数操作系统中，进程表通常是一个 数组 或 链表，每个 数组元素 或 链表节点 都表示一个 进程控制块（PCB，Process Control Block）。进程控制块包含了一个进程的关键状态信息，内核通过访问这个信息来管理和调度进程。</p>
<p>进程表的结构：<br>每个进程控制块（PCB）包含的内容：</p>
<p>进程的状态：如 RUNNING（运行中）、SLEEPING（睡眠中）、ZOMBIE（僵尸状态）等。<br>进程 ID（PID）：每个进程都有一个唯一的标识符。<br>父进程 ID：每个进程通常有一个父进程，记录父进程的 ID。<br>调度信息：如程序计数器（PC）、堆栈指针、寄存器的保存值等。<br>内存管理信息：如进程的页表、段表、堆栈和堆内存的基址等。<br>进程的资源信息：如文件描述符、打开的文件等。<br>同步信息：如与其他进程同步的条件变量、锁等。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量（Semaphore）通常用于 同步，它通过 计数 来控制进程之间的访问，确保不会发生竞争条件。信号量中的 count 通常表示某种资源的 数量，例如：</p>
<p>管道缓冲区中可用的字节数，或者<br>进程拥有的僵尸子进程数。<br>信号量的作用：<br>显式计数：使用显式的计数来表示等待的资源或条件，可以避免 “丢失唤醒” 问题。也就是说，计数会帮助追踪已经发生的 wakeup 次数，确保每个进程都被唤醒。<br>避免虚假唤醒和惊群效应：显式计数还可以有效避免虚假唤醒（即进程被唤醒后检查条件仍不满足）和 惊群效应（Thundering Herd Effect）（即大量进程被唤醒后竞相检查同一个条件的情况）。</p>
<h2 id="延迟死亡"><a href="#延迟死亡" class="headerlink" title="延迟死亡"></a>延迟死亡</h2><p>如果一个进程正在 sleep 循环中等待某个条件（例如等待磁盘 I&#x2F;O 或用户输入），而 kill 在这期间设置了 p-&gt;killed，则 sleep 循环 可能无法及时检查到这个标志。<br>kill 可能会在受害进程的 sleep 循环检查 p-&gt;killed 之后，但在调用 sleep 之前，试图 唤醒受害进程。在这种情况下，受害进程可能不会立刻注意到 p-&gt;killed 标志，直到它等待的条件（如磁盘块返回或控制台输入）发生。<br>如果在进程检查 p-&gt;killed 标志之后，kill 已经设置了 p-&gt;killed 标志并唤醒了它，那么接下来执行的 sleep 操作会使进程进入 阻塞状态，无法立即进入内核。<br>进程无法在 usertrap 中退出，因为 sleep 阻塞了它的执行，进程只有在所需的事件（如磁盘 I&#x2F;O 完成、用户输入等）再次发生时，才会被唤醒并检查 p-&gt;killed 标志，进而决定是否退出。<br>xv6 的设计避免了复杂的 信号机制，因此没有像 Unix 那样的 EINTR（中断错误） 错误。当进程在 sleep 中被 杀死（kill） 时，xv6 不会像 Unix 一样通过 signal 中断系统调用，而是简单地通过检查 p-&gt;killed 标志来决定是否退出。<br>由于 xv6 不支持信号，很多因信号导致的复杂性（例如在等待输入时受害进程被杀死）在 xv6 中并不会发生。</p>
<h2 id="XV6进程管理"><a href="#XV6进程管理" class="headerlink" title="XV6进程管理"></a>XV6进程管理</h2><p>在 xv6 中，proc 结构体（即进程控制块）的分配方式是 线性扫描，这意味着每次分配新的进程时，xv6 会遍历整个进程表来找到空闲的 proc 结构体。</p>
<p>线性扫描：xv6 使用简单的线性扫描来查找空闲的进程结构体（proc），这种实现方式虽然简单，但在处理大量进程时效率较低。<br>实际操作系统的优化：在实际的操作系统中，通常会使用 空闲列表（Free List） 或其他数据结构来高效地管理和分配进程控制块。这样，操作系统能够在 常数时间 内找到空闲的 proc 结构体，而不是每次都进行线性搜索</p>
<h2 id="第7个lab"><a href="#第7个lab" class="headerlink" title="第7个lab"></a>第7个lab</h2><h2 id="8文件"><a href="#8文件" class="headerlink" title="8文件"></a>8文件</h2><h2 id="8-1文件概述"><a href="#8-1文件概述" class="headerlink" title="8.1文件概述"></a>8.1文件概述</h2><p>文件描述符（File descriptor）<br>路径名（Pathname）<br>目录（Directory）<br>索引结点（Inode）<br>日志（Logging）<br>缓冲区高速缓存（Buffer cache）<br>磁盘（Disk）</p>
<p>磁盘层读取和写入virtio硬盘上的块。缓冲区高速缓存层缓存磁盘块并同步对它们的访问，确保每次只有一个内核进程可以修改存储在任何特定块中的数据。日志记录层允许更高层在一次事务（transaction）中将更新包装到多个块，并确保在遇到崩溃时自动更新这些块（即，所有块都已更新或无更新）。索引结点层提供单独的文件，每个文件表示为一个索引结点，其中包含唯一的索引号（i-number）和一些保存文件数据的块。目录层将每个目录实现为一种特殊的索引结点，其内容是一系列目录项，每个目录项包含一个文件名和索引号。路径名层提供了分层路径名，如&#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c，并通过递归查找来解析它们。文件描述符层使用文件系统接口抽象了许多Unix资源（例如，管道、设备、文件等）</p>
<h2 id="8-2-Buffer-cache层"><a href="#8-2-Buffer-cache层" class="headerlink" title="8.2 Buffer cache层"></a>8.2 Buffer cache层</h2><p>确保每个磁盘块在内存中只有一个副本，并且 一次只有一个内核线程使用该副本。这就意味着对于同一个磁盘块，缓存中只有一个副本，并且每次只有一个线程可以访问该副本，从而避免了并发访问时的数据冲突问题。<br>缓存常用块：<br>为了提高磁盘访问的效率，缓存常用的磁盘块，避免每次需要从较慢的磁盘重新读取相同的数据。磁盘的访问速度远低于内存，所以通过缓存一些常用的磁盘块，可以显著减少磁盘的读写次数，提高整体性能。</p>
<p>bread：用于从缓存中获取一个缓冲区，其中包含磁盘块的副本，供线程进行读取或修改。这会锁住该缓冲区，确保没有其他线程同时访问同一个缓冲区。<br>bread 调用 bget 来查找和返回缓冲区。如果缓冲区尚未加载，bread 会触发 磁盘读取，即调用 virtio_disk_rw（kernel&#x2F;bio.c）来从磁盘中读取数据。<br>bget：<br>bget 函数（kernel&#x2F;bio.c:59）负责从缓存中查找是否已有一个缓冲区对应某个特定的设备和扇区号（通过设备和扇区号来定位）。具体的操作步骤如下：</p>
<p>扫描缓冲区链表：<br>bget 扫描当前的缓冲区链表，检查是否存在与目标设备和扇区号匹配的缓冲区（通过 b-&gt;device 和 b-&gt;sector 字段）。</p>
<p>已有缓冲区：<br>如果发现已有相同设备和扇区号的缓冲区，bget 会获取该缓冲区的睡眠锁（确保线程安全），然后返回这个缓冲区。</p>
<p>没有匹配的缓冲区：<br>如果找不到对应的缓冲区，bget 需要创建一个新的缓冲区：</p>
<p>bget 会扫描链表，查找 未在使用中的缓冲区，即那些 b-&gt;refcnt &#x3D; 0 的缓冲区。这些缓冲区没有被引用，可以被重新利用。<br>一旦找到可用的缓冲区，bget 会修改缓冲区的元数据，记录新的设备和扇区号。<br>最后，bget 获取该缓冲区的睡眠锁，并将 valid 字段设置为 0，这样可以确保下次调用 bread 时会从磁盘读取数据，而不是使用该缓冲区之前的内容。<br>如果 bget 创建了一个新的缓冲区，并且该缓冲区没有有效的数据（即 valid &#x3D; 0），bread 会在返回该缓冲区之前，从磁盘读取数据并填充缓冲区。这是通过调用 virtio_disk_rw 来完成的。</p>
<p>bwrite：将修改后的缓冲区内容写回磁盘上的相应块。<br>每个缓冲区都使用了 睡眠锁，即每个缓冲区在访问时都会被上锁，确保同一时刻只有一个线程可以访问该缓冲区。</p>
<h3 id="缓存回收机制"><a href="#缓存回收机制" class="headerlink" title="缓存回收机制"></a>缓存回收机制</h3><p>Buffer Cache的回收机制：</p>
<p>缓存中的缓冲区数量是固定的，因此当文件系统需要一个未存放在缓存中的块时，必须回收现有的某些缓冲区来为新块腾出空间。为了高效利用缓存，Buffer Cache使用了一种 LRU（Least Recently Used） 策略，即 回收最近最少使用的缓冲区，因为这些缓冲区在近期再次使用的可能性较低。</p>
<p>这种回收机制保证了 缓存区的空间使用最优化，尽量避免频繁地从磁盘读取相同的数据，提高了磁盘和内存之间的数据流通效率</p>
<h3 id="对应代码实现"><a href="#对应代码实现" class="headerlink" title="对应代码实现"></a>对应代码实现</h3><p>双链表： Buffer Cache 使用 双链表 来表示缓冲区（buffer）。在初始化时，main（kernel&#x2F;main.c）调用 binit，并使用静态数组 buf（位于 kernel&#x2F;bio.c）中的 NBUF 个缓冲区初始化双链表。这些缓冲区的链表头通过 bcache.head 来访问，因此对缓存的所有其他访问都是通过这个链表而不是直接操作 buf 数组。<br>缓冲区的状态字段：<br>+————+    +————+    +————+    +————+<br>| Buffer 1   |&lt;–&gt;| Buffer 2   |&lt;–&gt;| Buffer 3   |&lt;–&gt;| Buffer N   |<br>+————+    +————+    +————+    +————+<br>   ^  |                ^  |               ^  |               ^  |<br>   |  |—————-|  |—————|  |—————|  |<br>   |                  |                    |                   |<br>   |                  +——————–+——————-+<br>   |<br>   v<br> bcache.head</p>
<p>每个缓冲区（buffer）有两个关键的状态字段：</p>
<p>valid：</p>
<p>这个字段表示缓冲区是否包含有效的块副本。如果 valid 为 0，则说明缓冲区没有有效的数据，可能需要从磁盘读取数据。<br>disk：</p>
<p>这个字段表示缓冲区中的数据是否已经写回磁盘。如果缓冲区内容已写回磁盘，disk 的状态会被设置为相应的标志，表示数据已经完成了磁盘写入。</p>
<h2 id="8-4-日志层"><a href="#8-4-日志层" class="headerlink" title="8.4 日志层"></a>8.4 日志层</h2><p>xv6 文件系统的崩溃恢复机制，主要是通过 日志记录（logging） 来保证崩溃后的一致性。核心思想是 Write-Ahead Logging (WAL)，即在执行文件系统操作之前，先将其所有修改记录到日志中，只有在日志完整写入后，才正式应用到文件系统中。</p>
<p>文件系统崩溃问题</p>
<p>文件系统操作通常涉及 多个磁盘写入，崩溃可能导致数据不一致。<br>例如，文件截断（truncation） 过程中崩溃，可能导致：<br>已释放但仍被 inode 引用的块（可能导致数据泄露）。<br>已分配但未被引用的块（只是空间浪费）。<br>xv6 采用日志记录解决崩溃问题</p>
<p>系统调用不会直接写入磁盘，而是先将所有写入操作存入 日志（log）。<br>提交（commit） 机制：<br>只有当所有修改被正确记录到日志中，才会写入实际的文件系统数据结构。<br>确保崩溃恢复时，日志能提供完整的写入信息。<br>清除日志（擦除 log）：防止崩溃后重复应用日志。<br>崩溃恢复机制</p>
<p>重启时，如果日志完整，文件系统会按日志内容执行写入恢复数据。<br>如果日志不完整（崩溃发生在 commit 之前），则忽略日志，保证数据一致性。<br>恢复完成后，清除日志。</p>
<p>保证文件系统一致性：即使崩溃，也能保证不会出现错误的 inode 指向已释放块的情况。<br>数据安全性：防止多个文件意外共享同一数据块，避免数据泄露问题。<br>提高磁盘操作效率：一次写入多个修改，而不是多次随机写入磁盘</p>
<p>日志（log）在写入磁盘之前，所有更改都会先记录在<strong>事务（transaction）</strong>中，而事务的设计保证了：</p>
<p>事务要么完整地写入磁盘，要么完全被丢弃。<br>不会出现日志里只包含部分操作的情况，即日志不会保留半个事务。<br>具体例子<br>假设系统在 commit 记录写入前崩溃：</p>
<p>markdown<br>复制<br>编辑<br>log:</p>
<ul>
<li>修改 inode</li>
<li>修改 free list<br>  （崩溃，commit 记录未写入）<br>恢复时检查日志，没有 commit 记录，忽略日志：</li>
</ul>
<p>markdown<br>复制<br>编辑<br>恢复：</p>
<ul>
<li>直接丢弃日志内容<br>结果：truncate 没有执行，磁盘状态和崩溃前一样，不会有一半执行一半丢失的情况。</li>
</ul>
<h2 id="日志设计"><a href="#日志设计" class="headerlink" title="日志设计"></a>日志设计</h2><p>在 xv6 中，日志驻留在磁盘的一个固定区域，这个区域由超级块（superblock） 指定：</p>
<p>日志包含两个部分：<br>头块（header block）：<br>记录当前事务的状态，包括已写入的 logged block 数量和对应的磁盘扇区号。<br>事务提交（commit）时才会更新头块。<br>日志块（logged blocks）：<br>这些是事务中涉及的磁盘数据块的副本（也就是日志记录的所有更改）。<br>在事务提交之前，所有的磁盘写入操作都会先存入这些日志块中，而不会直接修改文件系统数据结构。<br>日志的组织结构<br>磁盘上的日志区大致如下： 日志快不是记录动作而是副本 会保存对应的修改<br>[超级块] [inode 表] [数据块] … [日志区]<br>                             ├── 头块（Header Block）<br>                             ├── 日志块 1（Logged Block 1）<br>                             ├── 日志块 2（Logged Block 2）<br>                             ├── 日志块 3（Logged Block 3）<br>                             ├── …<br>如果日志只存储在 内存 中，而不存入 磁盘，那么：</p>
<p>如果系统崩溃，内存中的日志会丢失，导致文件系统无法恢复事务，可能出现数据损坏或不一致。<br>存入磁盘的日志在崩溃后依然可用，重启时可以用于恢复未完成的事务。<br>因此，日志必须存储在磁盘上，以确保崩溃恢复的可靠性。</p>
<p>未提交事务（崩溃前）	0	事务未完成，恢复时会忽略日志<br>已提交事务（崩溃后）	非零	事务已提交但未应用，恢复时需要重放日志</p>
<p> xv6 的日志系统 中，日志头块（header block）的 count 值是 在提交（commit）之后才变成非零，如果事务未提交（即没有 commit），count 仍然为 0。</p>
<h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><p>组提交的核心思想：</p>
<p>合并多个系统调用的磁盘写入，然后一次性提交（commit）。<br>减少磁盘 I&#x2F;O 次数，提高写入效率，特别是在机械硬盘（HDD）上效果明显，因为批量写入可以减少磁盘旋转时间的等待。<br>允许多个进程的系统调用共享一个事务，避免频繁的 commit 开销。</p>
<h4 id="大小限制"><a href="#大小限制" class="headerlink" title="大小限制"></a>大小限制</h4><p>假设文件 file1.txt 需要新增 1KB 数据<br>假设文件系统的块大小为 512B（标准的 xv6 块大小）。<br>写入 1KB 需要 2 个数据块，并且会修改：<br>数据块 1（写入前 512B 的数据）<br>数据块 2（写入后 512B 的数据）<br>inode 块（因为文件大小改变）<br>位图块（因为新分配了数据块）<br>日志块内容<br>在日志区（Log Area）中，整个磁盘块的副本会被存储，而不是只记录“修改的内容”：</p>
<p>css<br>复制<br>编辑<br>[ 头块 (Header Block) ]  →  记录事务中的块数量及其位置<br>[ 日志块 1 ] → <strong>完整的数据块 1 的副本</strong><br>[ 日志块 2 ] → <strong>完整的数据块 2 的副本</strong><br>[ 日志块 3 ] → <strong>完整的 inode 块的副本</strong><br>[ 日志块 4 ] → <strong>完整的位图块的副本</strong><br>当 commit 发生时：</p>
<p>日志系统会将日志区中的数据块复制回磁盘的真正位置。<br>只有在所有块都成功写入后，日志才会被清空。</p>
<p>问题 v6在磁盘上留出固定的空间来保存日志。事务中系统调用写入的块总数必须可容纳于该空间。这导致两个后果：任何单个系统调用都不允许写入超过日志空间的不同块。这对于大多数系统调用来说都不是问题，但其中两个可能会写入许多块：write和unlink。一个大文件的write可以写入多个数据块和多个位图块以及一个inode块；unlink大文件可能会写入许多位图块和inode。Xv6的write系统调用将大的写入分解为适合日志的多个较小的写入，unlink不会导致此问题，因为实际上Xv6文件系统只使用一个位图块。日志空间有限的另一个后果是，除非确定系统调用的写入将可容纳于日志中剩余的空间，否则日志系统无法允许启动系统调用。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>块缓存在内存中不在磁盘上2进行存储<br>Block Cache（块缓存）在 xv6 中的作用<br>在 xv6 文件系统 中，Block Cache（块缓存） 是 磁盘块（disk blocks）的内存缓存，它的作用是：</p>
<p>减少磁盘 I&#x2F;O：<br>直接从缓存读取数据，而不是每次都访问磁盘，提高效率。<br>支持多个进程并发访问文件系统：<br>允许多个进程同时读写文件系统，而不会出现冲突。<br>配合日志系统，确保数据一致性：<br>log_write() 先将数据写入缓存，而不是立即写入磁盘。</p>
<h2 id="磁盘上的文件系统结构-内存中的块缓存"><a href="#磁盘上的文件系统结构-内存中的块缓存" class="headerlink" title="[ 磁盘上的文件系统结构 ]                  [ 内存中的块缓存 ]"></a>[ 磁盘上的文件系统结构 ]                  [ 内存中的块缓存 ]</h2><p>[超级块]                                ┌──────────────────────┐<br>[inode 表]                              │ Block Cache (RAM)   │<br>[数据块]                                │ ┌────────────────┐  │<br>[日志区]                                │ │ 磁盘块副本 1    │  │<br>  ├── 头块（Header Block）               │ │ 磁盘块副本 2    │  │<br>  ├── 日志块 1（Logged Block 1）         │ │ …            │  │<br>  ├── 日志块 2（Logged Block 2）         │ └────────────────┘  │<br>  ├── …                                └──────────────────────┘</p>
<h2 id="日志代码函数"><a href="#日志代码函数" class="headerlink" title="日志代码函数"></a>日志代码函数</h2><h3 id="begin-op-负责日志空间管理"><a href="#begin-op-负责日志空间管理" class="headerlink" title="begin_op() 负责日志空间管理"></a>begin_op() 负责日志空间管理</h3><p>在 每个文件系统调用开始时，begin_op() 会执行两项关键操作：</p>
<p>等待日志系统没有处于提交状态（避免日志提交与新操作并发进行）。<br>检查日志空间是否足够，如果不足，就阻塞，直到空间可用。<br>代码流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin_op</span>();  <span class="comment">// 开始一个文件系统操作</span></span><br><span class="line">...</span><br><span class="line">bp = <span class="built_in">bread</span>(...);   <span class="comment">// 读取磁盘块</span></span><br><span class="line">bp-&gt;data[...] = ...;   <span class="comment">// 修改数据</span></span><br><span class="line"><span class="built_in">log_write</span>(bp);  <span class="comment">// 记录日志</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">end_op</span>();  <span class="comment">// 结束操作，可能触发日志提交</span></span><br></pre></td></tr></table></figure>
<p>log.outstanding 统计 当前占用日志空间的系统调用数。<br>每个系统调用最多可以写 MAXOPBLOCKS 个磁盘块。<br>预留日志空间 &#x3D; log.outstanding * MAXOPBLOCKS。<br>增加 log.outstanding 的值，确保不会在这个系统调用过程中触发提交。</p>
<h3 id="log-write-负责日志写入"><a href="#log-write-负责日志写入" class="headerlink" title="log_write() 负责日志写入"></a>log_write() 负责日志写入</h3><p>log_write() 是 bwrite()（block write）的代理，确保：</p>
<p>记录即将写入的块的扇区号，以便崩溃恢复时知道哪些块被修改。<br>在日志区中预留一个日志块槽位，用于存储该数据块的副本。<br>调用 bpin() 将该块固定在 block cache 中，防止缓存系统在事务提交前将其逐出。<br>log_write() 的核心操作</p>
<p>log_write(bp);<br>执行以下步骤：</p>
<p>记录该块的扇区号（确保提交时知道修改了哪些块）。<br>预留日志块（确保日志区有空间存放这个块）。<br>防止 block cache 将该块逐出：<br>为什么？<br>如果缓存系统淘汰了这个块，而提交事务时仍然需要它，就会导致数据不一致。<br>怎么做？<br>通过 bpin() 将该块标记为 “不可被逐出”。<br>对比 bwrite()<br>bwrite(bp) 直接将 缓存中的块写入磁盘，而不会额外记录日志。<br>log_write(bp) 先将块写入日志区，然后稍后再应用到磁盘的真正数据块（保证崩溃恢复时可以重做修改）。</p>
<h3 id="end-op-负责事务提交"><a href="#end-op-负责事务提交" class="headerlink" title="end_op() 负责事务提交"></a>end_op() 负责事务提交</h3><p>每个系统调用完成后，都会调用 end_op()：<br>减少 log.outstanding，释放日志空间预留。这个是每次系统调用的时候++<br>如果 log.outstanding &#x3D;&#x3D; 0，触发日志提交：<br>将日志区的修改写入文件系统的真实数据块。<br>清空日志区（将日志头块的 count &#x3D; 0），释放日志空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">整体代码</span><br><span class="line"><span class="built_in">begin_op</span>();  <span class="comment">// 开始事务，确保日志空间足够</span></span><br><span class="line"></span><br><span class="line">bp1 = <span class="built_in">bread</span>(data_block_1);  <span class="comment">// 读取数据块 1</span></span><br><span class="line">bp1-&gt;data = new_data;</span><br><span class="line"><span class="built_in">log_write</span>(bp1);  <span class="comment">// 记录日志</span></span><br><span class="line"></span><br><span class="line">bp2 = <span class="built_in">bread</span>(data_block_2);  <span class="comment">// 读取数据块 2</span></span><br><span class="line">bp2-&gt;data = new_data;</span><br><span class="line"><span class="built_in">log_write</span>(bp2);  <span class="comment">// 记录日志</span></span><br><span class="line"></span><br><span class="line">bp3 = <span class="built_in">bread</span>(inode_block);  <span class="comment">// 读取 inode 块</span></span><br><span class="line">bp3-&gt;data = updated_inode;</span><br><span class="line"><span class="built_in">log_write</span>(bp3);  <span class="comment">// 记录日志</span></span><br><span class="line"></span><br><span class="line">bp4 = <span class="built_in">bread</span>(bitmap_block);  <span class="comment">// 读取位图块</span></span><br><span class="line">bp4-&gt;data = updated_bitmap;</span><br><span class="line"><span class="built_in">log_write</span>(bp4);  <span class="comment">// 记录日志</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">end_op</span>();  <span class="comment">// 结束事务，可能触发日志提交</span></span><br></pre></td></tr></table></figure>
<h3 id="commit-的四个阶段"><a href="#commit-的四个阶段" class="headerlink" title="commit() 的四个阶段"></a>commit() 的四个阶段</h3><p>将事务中的修改存入日志区（Log Area），但此时文件系统的实际数据块尚未修改。</p>
<p>2 写入日志头块（Header Block） 日志头块（Header Block）是事务的提交点，它记录了日志区包含哪些块的修改信息。<br>如果系统崩溃，恢复机制会根据日志头块，确定是否需要重放日志。</p>
<p>3 nstall_trans()：应用事务，将日志区的块写入文件系统<br>日志区的数据被复制到真正的文件系统块中，此时文件系统才真正更新。<br>如果 commit() 过程崩溃，恢复机制仍然可以从日志区恢复数据，保证一致性。</p>
<p>4清除日志头<br>日志提交后，日志头块 count&#x3D;0，表明日志已清空。<br>这确保了下一个事务不会错误地使用旧的日志数据。</p>
<h3 id="启动的时候日志恢复"><a href="#启动的时候日志恢复" class="headerlink" title="启动的时候日志恢复"></a>启动的时候日志恢复</h3><p>recover_from_log() 由 initlog() 调用，而 initlog() 又由 fsinit() 在 第一个用户进程运行之前 执行。<br>如果日志头块表明上次崩溃前有已提交但未安装的事务，则 recover_from_log() 会重放日志区的写入操作，确保文件系统完整性。</p>
<h2 id="8-7块分配器"><a href="#8-7块分配器" class="headerlink" title="8.7块分配器"></a>8.7块分配器</h2><p>在 xv6 的文件系统中，所有文件和目录的数据都存储在磁盘块（Disk Blocks）中。这些磁盘块是有限的，因此必须通过<strong>块分配器（Block Allocator）</strong>进行管理。<br>一个抽象概念 位图<br>位图是一个连续的二进制数组：</p>
<p>每一位（bit）表示一个磁盘块的状态：<br>0：空闲（可以分配）。<br>1：已占用（正在使用）。<br>位图存储在多个磁盘块中，每个块存储多个比特（8 bits &#x3D; 1 byte）。</p>
<p>特性	inode（索引节点）	位图块（bitmap block）<br>作用	记录文件的元数据（大小、权限、数据块位置等）	记录磁盘块的使用状态（空闲&#x2F;已占用）<br>存储内容	文件类型、大小、所有者、权限、数据块指针	每个比特位表示一个磁盘块的状态（0&#x3D;空闲, 1&#x3D;已占用）<br>管理对象	管理 文件，文件由 inode 结构体表示	管理 磁盘块，用于块分配和回收<br>是否直接管理数据块	✅ 通过 数据块指针 关联数据块	❌ 仅表示块是否空闲，并不指向文件数据<br>数据结构	struct dinode（存储在 inode 块）	位图数组（存储在 bitmap block）<br>存储位置	inode block（文件系统中的一个区域）	bitmap block（在 inode block 之后，数据块之前）</p>
<p>分配<br>引导扇区（boot block）	启动代码<br>超级块（super block）	记录文件系统的基本信息，如大小、inode 数量等<br>日志块（log blocks）	用于文件系统的日志记录<br>inode 块（inode blocks）	存储文件的 inode（元数据）<br>位图块（bitmap blocks）	记录哪些磁盘块是空闲的<br>数据块（data blocks）	存储文件和目录的实际内容</p>
<p>为什么 balloc() 块分配和 bfree()块释放 必须在事务内调用？<br>保证崩溃恢复<br>事务 &#x3D; 先写入日志，再修改文件系统。<br>如果事务失败，系统可以回滚，防止分配不完整的块进入文件系统。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin_op</span>();</span><br><span class="line">uint blockno = <span class="built_in">balloc</span>(dev);</span><br><span class="line"><span class="built_in">end_op</span>();  <span class="comment">// 只有当事务成功，块才真正被分配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="inode-索引节点层"><a href="#inode-索引节点层" class="headerlink" title="inode 索引节点层"></a>inode 索引节点层</h2><p>在 xv6 中，inode（索引结点）有两种表示：</p>
<p>磁盘上的 inode（struct dinode）：</p>
<p>记录文件的 元数据（文件大小、数据块指针等）。<br>存储在 inode 块（inode blocks） 里，所有 inode 大小相同，连续存储。<br>通过 inode number（i-number） 进行索引。<br>内存中的 inode（struct inode）：</p>
<p>磁盘 inode 的副本，并包含 内核管理的额外信息（如引用计数 ref）。<br>只有 被进程访问 时才会加载到内存。<br>iget() 负责获取 inode，iput() 负责释放 inode。</p>
<ol>
<li>磁盘上的 inode<br>磁盘上的 inode 结构由 struct dinode 定义：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h:32</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dinode</span> &#123;</span><br><span class="line">    <span class="type">short</span> type;         <span class="comment">// 文件类型（T_FILE, T_DIR, T_DEV），0表示空闲</span></span><br><span class="line">    <span class="type">short</span> major;        <span class="comment">// 设备主编号（如果是设备文件）</span></span><br><span class="line">    <span class="type">short</span> minor;        <span class="comment">// 设备次编号</span></span><br><span class="line">    <span class="type">short</span> nlink;        <span class="comment">// 目录项引用计数</span></span><br><span class="line">    uint size;          <span class="comment">// 文件大小（字节）</span></span><br><span class="line">    uint addrs[NDIRECT<span class="number">+1</span>]; <span class="comment">// 数据块地址（指向存储文件内容的磁盘块）</span></span><br><span class="line">&#125;;</span><br><span class="line">| Boot Block | Super Block | Log Blocks | Inode Blocks | Bitmap Blocks | Data Blocks |</span><br><span class="line">每个 inode 大小相同，因此 可以直接计算 <span class="function">inode <span class="title">number</span> <span class="params">(i-number)</span>：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">define</span> IBLOCK(i, sb) ((i) / IPB + sb.inodestart)</span></span></span><br></pre></td></tr></table></figure></li>
<li>内存中的 inode<br>磁盘上的 inode 只存储基本信息，但内核管理 inode 需要额外信息，所以在内存中用 struct inode 表示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h:17</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> &#123;</span><br><span class="line">    uint dev;           <span class="comment">// 设备号</span></span><br><span class="line">    uint inum;          <span class="comment">// inode 号（磁盘上的编号）</span></span><br><span class="line">    <span class="type">int</span> ref;            <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sleeplock</span> lock; <span class="comment">// 锁，防止并发访问</span></span><br><span class="line">    <span class="type">int</span> valid;          <span class="comment">// 是否已从磁盘加载</span></span><br><span class="line">    <span class="type">short</span> type;         <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">short</span> major;</span><br><span class="line">    <span class="type">short</span> minor;</span><br><span class="line">    <span class="type">short</span> nlink;</span><br><span class="line">    uint size;</span><br><span class="line">    uint addrs[NDIRECT<span class="number">+1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
内存 inode 只在需要时加载（iget()），当 ref &#x3D;&#x3D; 0 时释放（iput()）。<br> 文件系统通过 inode 组织文件，但 inode 不存储文件名，文件名在目录项里。</li>
</ol>
<p>当进程执行 open()、read()、write() 等文件操作时，内核会：</p>
<p>查找 inode 是否已经在 icache（inode cache）中</p>
<p>如果在缓存中（命中） → 直接返回 inode。<br>如果不在缓存中（未命中） → 从磁盘读取 inode，复制到 icache。<br>iget() 函数负责从 icache 或磁盘获取 inode</p>
<p>如果 inode 在 icache，增加 ref 计数。<br>如果 inode 不在 icache：<br>从 inode blocks 读取 dinode。<br>在 icache 中创建 inode，复制 dinode 内容。</p>
<h3 id="inode锁"><a href="#inode锁" class="headerlink" title="inode锁"></a>inode锁</h3><p>深入解析 xv6 inode 代码中的四种锁机制<br>在 xv6 的文件系统实现中，inode 代码包含 四种锁或类似锁的机制，用于 同步并发访问、保证一致性、避免死锁：</p>
<p>icache.lock 保护 inode 缓存，防止重复缓存同一 inode。<br>inode-&gt;lock（睡眠锁） 确保 inode 访问的独占性，防止多个进程同时修改 inode 数据。<br>inode-&gt;ref（引用计数） 确保 inode 在 ref&gt;0 时不会被释放或重用。<br>inode-&gt;nlink（链接计数） 确保 inode 只在 nlink&#x3D;&#x3D;0 时才真正删<br>删除的两个区别<br>inode-&gt;ref 影响 inode 是否还被进程引用（内存中的 inode）。<br>如果 ref &#x3D;&#x3D; 0，inode 可以从 icache 释放（但仍可能存在于磁盘）。<br>inode-&gt;nlink 影响 inode 是否还被目录项引用（磁盘上的 inode）。<br>如果 nlink &#x3D;&#x3D; 0 且 ref &#x3D;&#x3D; 0，才会真正删除 inode 并释放磁盘块。</p>
<p>unlink()<br>作用：unlink() 删除文件的目录项，但不一定会立刻删除 inode。<br>减少 inode-&gt;nlink（目录项引用数）。<br>如果 nlink &#x3D;&#x3D; 0 且 ref &#x3D;&#x3D; 0，则 inode 彻底删除，磁盘上的数据块被释放。</p>
<p> unlink() 且 nlink &#x3D;&#x3D; 0<br>作用：当 unlink() 使 nlink &#x3D;&#x3D; 0 时，inode 不再有目录项引用，但如果进程仍然打开文件，它不会立即删除。</p>
<p>进程 close() 且 ref &#x3D;&#x3D; 0<br>作用：如果 inode-&gt;ref &#x3D;&#x3D; 0，说明没有进程使用 inode，它可以被释放（但是否删除取决于 nlink）。</p>
<p>unlink() + close()：彻底删除 inode</p>
<h3 id="iget使用inode"><a href="#iget使用inode" class="headerlink" title="iget使用inode"></a>iget使用inode</h3><ol>
<li>iget() 确保 inode 不会被删除<br>作用<br>iget() 负责在 inode cache（icache）中 查找或加载 inode，并确保 inode 在 iput() 之前不会被删除或重用。<br>多个进程可以同时持有 iget() 返回的 inode 指针，但只有 iput() 释放它之后，inode 才可能被删除。</li>
</ol>
<p>2.ilock() 和 iunlock() 保护 inode 的一致性<br>作用<br>ilock() 独占锁定 inode，防止多个进程同时修改 inode 数据（如 size、addrs[]）。<br>如果 inode-&gt;valid &#x3D;&#x3D; 0，则从磁盘加载 inode（防止访问无效数据）。<br>iunlock() 释放 inode 锁。<br>iget() 只是获取 inode，并不锁定它。<br>ilock() 负责独占锁定 inode，防止修改冲突。</p>
<p>3<br>inode cache 主要用于同步，而非性能优化<br>作用<br>inode cache（icache）的主要作用是防止并发竞争，而不是为了提高访问速度。<br>inode 不一定一直缓存，buffer cache 可能会缓存它的磁盘数据。</p>
<p>4<br>inode 直写（Write-Through）<br>作用<br>inode cache 不会延迟写入，而是立刻更新磁盘，确保 inode 结构的一致性。<br>iupdate() 负责将修改后的 inode 写入磁盘。</p>
<h3 id="ialloc"><a href="#ialloc" class="headerlink" title="ialloc()"></a>ialloc()</h3><p>ialloc() 用于分配一个新的 inode，通常发生在创建新文件或目录时（create()）。<br>类似于 balloc()（分配数据块），它遍历磁盘上的 inode，找到一个空闲 inode 并分配给新文件。</p>
<p> ialloc() 在 inode blocks 里查找空闲 inode，分配给新文件。<br>✔ iget() 从 inode cache 获取 inode，保证 inode 在 iput() 之前不会被删除。<br>✔ ilock() 独占 inode，并从磁盘加载 inode（如果 valid &#x3D;&#x3D; 0）。<br>✔ iput() 释放 inode，如果 ref &#x3D;&#x3D; 0 且 nlink &#x3D;&#x3D; 0，调用 itrunc() 删除数据块。</p>
<h3 id="input-释放"><a href="#input-释放" class="headerlink" title="input()释放"></a>input()释放</h3><p>如果 iput() 在释放 inode 期间，其他进程正在 ilock()（如 read() 或 ls），可能会导致未定义行为。<br>如何防止 ilock() 获取已经释放的 inode？</p>
<p>释放 inode 不是一瞬间的过程，它需要确保 inode 的一致性。<br>如果 inode 还在被其他进程引用（ref &gt; 0），它仍然是有效的，不能立即重新分配。<br>即使 ref &#x3D;&#x3D; 0，ialloc() 也不能立即复用 inode，因为 inode 需要经过 iupdate() 写入磁盘，并被正确标记为空闲（type &#x3D; 0）。</p>
<p>减少 inode-&gt;ref 计数（表示进程不再使用 inode）。<br>检查 inode-&gt;nlink<br>如果 nlink &gt; 0，说明仍有目录项指向 inode，不能释放。<br>如果 nlink &#x3D;&#x3D; 0，则 inode 没有目录项，进入可删除状态。<br>如果 ref &#x3D;&#x3D; 0 &amp;&amp; nlink &#x3D;&#x3D; 0<br>调用 itrunc() 释放 inode 关联的数据块。<br>调用 iupdate() 把 inode 标记为空闲（type &#x3D; 0），并写入磁盘。</p>
<p>解决这个问题</p>
<p>如果 inode-&gt;nlink &#x3D;&#x3D; 0 且 inode-&gt;ref &#x3D;&#x3D; 1，则不会有其他线程使用该 inode</p>
<p>唯一持有 inode 引用的线程是调用 iput() 的线程。<br>因此，不可能有其他线程尝试 ilock() 这个 inode。<br>为什么 iput() 在 icache.lock 外部检查 ref &#x3D;&#x3D; 1？</p>
<p>防止 icache.lock 持有太久，影响其他进程获取 inode。<br>由于 inode-&gt;nlink &#x3D;&#x3D; 0，不会有新线程尝试 iget() 获取这个 inode，所以 iput() 释放后不会导致数据竞争。 为什么<br>在 xv6 文件系统中，如果 inode-&gt;nlink &#x3D;&#x3D; 0，说明已经没有目录项指向这个 inode，所以不会有进程能通过路径名（如 open(“file”)）找到这个 inode，进而不会有新进程调用 iget() 来获取它。<br>iget() 只能通过 inode number 获取 inode<br>在 xv6 中，iget() 通常由路径名解析（如 namei()）调用，它的核心逻辑是：</p>
<p>先通过目录项（dirlookup()）找到 inode number (inum)。<br>再调用 iget(dev, inum) 获取 inode。<br>📌 unlink() 之后，目录项已经删除<br>当 nlink &#x3D;&#x3D; 0 时：</p>
<p>所有目录项都已经删除（unlink()）。<br>namei() 无法找到 inode number，进程无法调用 iget() 获取 inode。<br>因此，没有新进程能获取这个 inode！</p>
<h3 id="input第二个问题"><a href="#input第二个问题" class="headerlink" title="input第二个问题"></a>input第二个问题</h3><p> 另一个潜在竞争问题：两个线程同时释放 inode<br>假设：<br>线程 A 执行 iput(ip)，准备释放 inode。<br>线程 B 在 ialloc() 分配新的 inode 时，可能会复用这个 inode。</p>
<p>解决<br>ialloc() 只能在 iupdate() 写入 inode 并将 type &#x3D; 0 之后才会复用 inode<br>即使 ialloc() 发现 inode 可用，也必须等待 iput() 释放 inode 锁后才能访问。<br>确保 inode 在 ialloc() 期间不会被并发修改。</p>
<h3 id="input崩溃情况"><a href="#input崩溃情况" class="headerlink" title="input崩溃情况"></a>input崩溃情况</h3><p>问题：如果崩溃发生在 iput() 释放 inode 之前？<br>文件的 nlink &#x3D;&#x3D; 0，但 inode 仍然在磁盘上（没有释放）。<br>可能导致“已分配但不可达”的 inode（磁盘泄漏）。<br>📌 什么时候 iput() 释放 inode？<br>只有当 inode-&gt;ref &#x3D;&#x3D; 0 &amp;&amp; inode-&gt;nlink &#x3D;&#x3D; 0，才会调用 itrunc() 释放 inode。<br>如果 ref &gt; 0，说明进程仍然打开文件，inode 不能删除。<br>如果 nlink &#x3D;&#x3D; 0，但 ref &gt; 0，文件仍然可以使用，但目录中不会再有指向它的路径（文件名消失，但数据仍在）。<br>如果崩溃发生在 ref &gt; 0 期间，文件系统可能会有“孤立 inode”（无目录项指向的 inode）。<br>📌 崩溃恢复<br>文件系统检查 inode 是否被 nlink &#x3D;&#x3D; 0 但仍然存在，并回收它们。<br>这通常通过 fsck 或 log recovery（日志恢复）来解决。<br>如果 inode 仍然被打开的文件引用，文件系统不会立即释放它（称为 orphan inode）。</p>
<p>解决崩溃问题<br>孤立 inode 指的是：<br>nlink &#x3D;&#x3D; 0（没有目录项指向它）。<br>ref &gt; 0（仍然有进程打开它，正在使用）。<br>当 ref &#x3D;&#x3D; 0 但 nlink &#x3D;&#x3D; 0 时，inode 本应被释放，但如果崩溃发生，可能导致 inode 在磁盘上仍然被标记为“已分配”，但实际上无法被访问。<br>这些 inode 占用了磁盘空间，但无法被正常文件系统操作释放，导致磁盘空间泄漏。</p>
<p>解决方法1<br>方法 1：重启时扫描整个文件系统<br>📌 思路</p>
<p>在文件系统恢复时，扫描所有 inode，找出 nlink &#x3D;&#x3D; 0 但仍然标记为已分配的 inode，并释放它们。<br>这是 fsck（文件系统一致性检查）工具的工作方式，例如 EXT 文件系统的 fsck.ext4。<br>📌 具体操作</p>
<p>遍历所有 inode（从 inode blocks 读取）。<br>检查 nlink &#x3D;&#x3D; 0 且 inode 仍然被标记为分配状态。<br>如果 ref &#x3D;&#x3D; 0，释放 inode 并回收磁盘空间。</p>
<p>解决方法2<br> 方法 2：使用“待删除 inode”列表<br>📌 思路</p>
<p>文件系统在磁盘的某个位置（如超级块）维护一个列表，记录所有 nlink &#x3D;&#x3D; 0 但 ref &gt; 0 的 inode。<br>当 ref &#x3D;&#x3D; 0 时，真正释放 inode，并从列表中移除。<br>恢复时，扫描列表，删除其中的 inode。<br>📌 具体操作</p>
<p>当 nlink &#x3D;&#x3D; 0 且 ref &gt; 0 时，把 inode 记录在磁盘的特殊区域（如超级块）。<br>当 ref &#x3D;&#x3D; 0，进程关闭 inode，真正释放 inode，并从列表中移除。<br>如果系统崩溃，恢复时扫描列表，释放其中的 inode，确保磁盘空间不被浪费。</p>
<h3 id="注意这里的删除都是删除磁盘里面的inode-缓存的inode只是标志位置零了"><a href="#注意这里的删除都是删除磁盘里面的inode-缓存的inode只是标志位置零了" class="headerlink" title="注意这里的删除都是删除磁盘里面的inode 缓存的inode只是标志位置零了"></a>注意这里的删除都是删除磁盘里面的inode 缓存的inode只是标志位置零了</h3><p>当一个 inode 没有进程引用 (ref &#x3D;&#x3D; 0)，同时没有目录项 (nlink &#x3D;&#x3D; 0)，iput() 需要释放这个 inode，但它仍然留在 inode cache，等待未来可能的复用。<br>✔ iput() 会调用 iupdate() 和 itrunc()，它们会先写入日志，记录 inode 变更（type &#x3D; 0）以及 inode 关联的数据块释放。<br>✔ 日志提交 (commit()) 之后，install_trans() 会真正删除 inode 并释放磁盘上的 inode 结构和数据块。<br>✔ 日志提交 (commit()) 之后，任务才算完全结束。<br>✔ 缓存中的 inode 仍然保留（但 valid &#x3D;&#x3D; 0），等待 iget() 可能的复用。</p>
<p>状态	缓存中的 inode	磁盘上的 inode	数据块<br>事务提交前	仍然在 inode cache，valid &#x3D;&#x3D; 0	type &#x3D; 0，标记为空闲	数据块仍然存在<br>事务提交后	仍然在 inode cache，等待复用	inode 被释放，可复用	数据块被 bfree() 释放、</p>
<h3 id="inode包含的内容"><a href="#inode包含的内容" class="headerlink" title="inode包含的内容"></a>inode包含的内容</h3><p>dinode（磁盘上的 inode）存储了文件元数据，包括：<br>type：文件类型（普通文件、目录、设备等）。<br>major、minor：设备信息（仅适用于设备文件）。<br>nlink：硬链接数量。<br>size：文件大小（字节数）。<br>addrs[]：文件数据块地址。</p>
<p>addrs[] 数据块地址数组<br>addrs[] 存储文件数据块的地址。<br>前 12 个条目（address 1 ~ address 12）是直接块（direct blocks）。<br>第 13 个条目是间接块（indirect block），用于存储更多数据块的地址。</p>
<ol start="2">
<li>直接块（Direct Blocks）<br>dinode 的前 12 个 addrs[] 存储直接块地址，每个块大小 BSIZE（通常是 1 KB）。<br>这意味着前 12 KB（12 x BSIZE）的数据可以直接通过 inode 访问。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dinode</span> &#123;</span><br><span class="line">    uint size;       <span class="comment">// 文件大小</span></span><br><span class="line">    uint addrs[NDIRECT<span class="number">+1</span>];  <span class="comment">// 直接块 + 1 个间接块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3 间接块<br>如果文件超过 12 KB，直接块不够用，就要使用间接块。<br>间接块本身是一个磁盘数据块，其中存储的是 256 个数据块地址（一个块 BSIZE &#x3D; 1 KB，可以存 256 个 4 字节的地址）。<br>通过间接块，文件最多可以增加 256 KB（256 x BSIZE）的数据。<br>addrs[12]（最后一个 addrs[] 元素）存储的是间接块的地址。</p>
<p>addrs[12] 指向 间接块，间接块存储 256 个数据块地址。<br>这样，文件最大可以占用：<br>直接块：12 KB<br>间接块：256 KB<br>总共可存储 268 KB（12 KB + 256 KB）。</p>
<h3 id="bmap"><a href="#bmap" class="headerlink" title="bmap()"></a>bmap()</h3><p>bmap() 负责管理 inode 中的数据块映射。<br>它返回 inode 第 bn 个数据块的磁盘块号。<br>如果 bn 还没有分配块，bmap() 会分配一个新的块。<br>bn &lt; 12	数据块在直接块中	直接返回 addrs[bn]<br>bn &gt;&#x3D; 12 且 bn &lt; 268	数据块在间接块	先读取 addrs[12]（指向间接块），然后找到具体的数据块地址<br>bn &gt;&#x3D; 268	超出文件系统限制	panic(“bmap: out of range”)</p>
<p>bmap() 返回的是磁盘块号（block number），而不是内存地址。<br>磁盘块号（block number）	代表文件存储在磁盘上的块索引，用于读取磁盘	bmap(ip, 5) -&gt; 105</p>
<p>是的，操作系统可以通过磁盘块号（Block Number）计算出数据在磁盘上的具体位置。但是，磁盘存储通常不是栈（Stack）方式，而是基于扇区（Sector）和块（Block）的线性寻址方式进行存储。</p>
<p>磁盘通常是按照 扇区（Sector）+ 块（Block） 的方式存储数据，而不是栈（Stack）结构。</p>
<p>磁盘块号如何映射到磁盘的物理位置？</p>
<p>每个磁盘块号 代表磁盘上的一个固定大小的存储单元（通常是 512 字节或 4096 字节）。<br>块号 × 块大小（Block Size）&#x3D; 磁盘上的偏移量（Offset），可以计算出数据在磁盘上的具体位置。</p>
<h3 id="bmap-readi-writei"><a href="#bmap-readi-writei" class="headerlink" title="bmap readi writei"></a>bmap readi writei</h3><p>bmap() 使得 readi() 和 writei() 可以轻松找到 inode 存储的数据块，而不需要关心数据块是 直接块（Direct Blocks） 还是 间接块（Indirect Blocks），只需要调用 bmap() 即可得到磁盘块号，然后读取或写入数据。</p>
<p>📌 readi() 主要流程<br>确保 offset（偏移量）和 n（读取字节数）不超过文件大小。<br>如果 offset 超过文件大小，返回错误。<br>如果 offset + n 超过文件大小，则最多读取到文件末尾。<br>循环处理每个数据块：<br>通过 bmap() 找到磁盘块号。<br>读取磁盘块（bread()）。<br>复制数据到 dst。<br>最终返回实际读取的字节数。</p>
<p>off &gt; ip-&gt;size	直接返回 0，表示读取超出文件末尾<br>off + n &gt; ip-&gt;size	只读取到文件末尾（调整 n）<br>bmap()	计算 blockno，找到数据块位置<br>bread()	读取 blockno 号磁盘块<br>memmove(dst, bp-&gt;data + (off % BSIZE), m)	从磁盘块拷贝数据到 dst<br>brelse(bp)	释放 buffer，避免缓存占用</p>
<p><br>2️⃣ writei() 写入 inode 的数据<br>📌 writei() 主要流程<br>确保 offset + n 不超过文件最大大小。<br>循环处理每个数据块：<br>通过 bmap() 找到磁盘块号（如果未分配，则 bmap() 负责分配）。<br>读取磁盘块（bread()）。<br>将 src 数据复制到 bp-&gt;data 中。<br>如果写入扩展了文件，更新 inode-&gt;size。<br>最终返回实际写入的字节数。</p>
<p>off + n &gt; MAXFILE * BSIZE	返回 -1，防止文件超出最大大小<br>bmap()	计算 blockno，找到或分配数据块<br>bread()	读取 blockno 号磁盘块<br>memmove(bp-&gt;data + (off % BSIZE), src, m)	写入数据到 bp-&gt;data<br>log_write(bp)	记录写入日志，保证崩溃恢复<br>if (off &gt; ip-&gt;size) ip-&gt;size &#x3D; off;	扩展 inode 大小<br>iupdate(ip);	写入 inode 变更</p>
<p>疑问<br>memmove(dst, bp-&gt;data, m)（从磁盘读取到内存）	memmove(bp-&gt;data, src, m)（从内存写入磁盘）<br>memmove(dst, bp-&gt;data, m) 表示 从磁盘（buffer cache）读取数据到内存。<br>memmove(bp-&gt;data, src, m) 表示 将内存数据写入磁盘（buffer cache）。</p>
<p>参数	含义<br>dst	目标地址，通常是 内存（用户空间或内核缓冲区），数据存放在这里<br>bp-&gt;data + (off % BSIZE)	数据来源，表示 当前磁盘块中数据的起始位置<br>m	复制的字节数</p>
<p>bp-&gt;data + (off % BSIZE)	目标地址，表示 当前磁盘块中的写入位置<br>src	数据来源，通常是 用户缓冲区或内核缓冲区<br>m	复制的字节数</p>
<h2 id="8-11-目录层"><a href="#8-11-目录层" class="headerlink" title="8.11 目录层"></a>8.11 目录层</h2><p>在 xv6 文件系统中：<br>目录也是一种文件，它的 inode-&gt;type &#x3D; T_DIR。、<br>inode-&gt;type 是 inode 结构中的一个字段<br>c<br>复制<br>编辑<br>struct inode {<br>    uint dev;         &#x2F;&#x2F; 设备号<br>    uint inum;        &#x2F;&#x2F; inode 号<br>    int ref;          &#x2F;&#x2F; 引用计数<br>    int valid;        &#x2F;&#x2F; 是否有效<br>    short type;       &#x2F;&#x2F; <strong>文件类型（T_FILE &#x2F; T_DIR &#x2F; T_DEV）</strong><br>    short nlink;      &#x2F;&#x2F; 硬链接计数<br>    uint size;        &#x2F;&#x2F; 文件大小（字节）<br>    uint addrs[NDIRECT+1];  &#x2F;&#x2F; 直接块 + 间接块<br>};<br>type 决定了 inode 代表的文件类型：<br>T_FILE（普通文件）<br>T_DIR（目录）<br>T_DEV（设备文件）<br>目录的 inode-&gt;type &#x3D; T_DIR，意味着它的数据存储的是目录项，而不是普通文件数据。</p>
<p>目录的数据块存储 struct dirent（目录项）。<br>每个 dirent 关联一个文件名（name）和 inode 号（inum）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span> &#123;</span><br><span class="line">    ushort inum;      <span class="comment">// **文件的 inode 号**</span></span><br><span class="line">    <span class="type">char</span> name[DIRSIZ]; <span class="comment">// **文件名，最多 14 个字符**</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目录的 data 部分存储多个 struct dirent（目录项）。<br>每个 dirent 代表一个文件或子目录，记录：<br>inum：文件&#x2F;目录对应的 inode 号。<br>name[14]：文件&#x2F;目录名（最多 14 字符）</p>
<p>dirlookup()：查找目录项<br>📌 dirlookup(dp, name, &amp;off) 作用<br>在目录 dp 内查找 name 文件。<br>如果找到，则返回对应 inode 指针，并存储 off（偏移量）。<br>如果未找到，则返回 0（NULL）。</p>
<p>dirlink(dp, name, inum) 作用<br>在目录 dp 内添加 name 对应的 inode 号 inum。<br>如果 name 已存在，返回错误。<br>如果 name 不存在，则查找一个空闲 dirent 进行写入</p>
<p>目录结构<br>&#x2F;home<br> ├── file1.txt (inode 10)<br> ├── file2.txt (inode 11)<br> ├── docs (inode 12)</p>
<p>inode 编号（inum）是全局唯一的，不是局部编号。<br>所有文件和目录的 inode 号都来自整个文件系统的 inode 表（inode table），而不是按目录单独编号。<br>不同目录下的文件不会重新从 0 开始编号，而是共享全局 inode 号。</p>
<p>&#x2F; (inode 1)<br> ├── bin (inode 2)<br> │   ├── ls (inode 10)<br> │   ├── cat (inode 11)<br> │   ├── grep (inode 12)<br> │<br> ├── home (inode 3)<br> │   ├── user (inode 4)<br> │       ├── file1.txt (inode 13)<br> │       ├── file2.txt (inode 14)</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>数据类型	存储在磁盘？	存储在缓存？	如何同步？<br>inode	存储在 inode table	inode cache 缓存最近访问的 inode  iupdate() 写回磁盘<br>dirent（目录项）	存储在目录的 data block	buffer cache 缓存目录块	log_write() + bwrite()<br>文件数据	存储在 data block	buffer cache 缓存文件块	log_write() + bwrite()</p>
<h2 id="8-12-路径名"><a href="#8-12-路径名" class="headerlink" title="8.12 路径名"></a>8.12 路径名</h2><p>在 xv6 文件系统中，路径名查找 主要依赖 namei() 和 namex()，它们通过一系列 dirlookup() 调用，逐级解析路径，最终找到目标 inode。<br>🌟 目标：<br>namei()：查找路径对应的 inode（如 &#x2F;home&#x2F;user&#x2F;file.txt）。<br>nameiparent()：查找路径的 父目录 inode（如 &#x2F;home&#x2F;user，返回 file.txt 作为 name）。<br>namex()：执行具体的路径解析逻辑（namei() 和 nameiparent() 都调用它）。</p>
<p>namei() 作用<br>输入路径（如 &#x2F;home&#x2F;user&#x2F;file.txt）。<br>解析路径的每个目录名（home → user → file.txt）。<br>返回 file.txt 对应的 inode。</p>
<p> nameiparent() 作用<br>输入路径（如 &#x2F;home&#x2F;user&#x2F;file.txt）。<br>查找到 file.txt 的父目录 &#x2F;home&#x2F;user。<br>返回 inode，同时将 file.txt 存入 name。</p>
<p>namex() 处理逻辑<br>步骤	操作<br>1	检查路径是否以 &#x2F; 开头，决定是从 ROOT 目录还是 cwd 开始查找<br>2	调用 skipelem() 解析路径的下一级目录名<br>3	锁定 inode，确保不会并发修改<br>4	检查 inode-&gt;type &#x3D;&#x3D; T_DIR，确保当前 inode 是目录<br>5	如果是 nameiparent() 且路径到达最后一个元素，则返回父目录 inode<br>6	调用 dirlookup() 查找下一级 inode<br>7	释放当前 inode，移动到下一级目录，重复步骤 2-6，直到路径解析完毕</p>
<h3 id="查找路径的并发与同步"><a href="#查找路径的并发与同步" class="headerlink" title="查找路径的并发与同步"></a>查找路径的并发与同步</h3><p>namex() 需要在多个进程同时访问文件系统时 防止数据竞争 和 避免死锁。</p>
<p>📌 并发问题<br>假设：</p>
<p>线程 A 正在查找 &#x2F;home&#x2F;user&#x2F;file.txt。<br>线程 B 删除了 &#x2F;home&#x2F;user 并分配给新文件。<br>🔹 风险：</p>
<p>线程 A 可能在 dirlookup() 解析 &#x2F;home&#x2F;user 时，发现 inode 已被删除或更改。<br>如果 inode 号被回收用于新文件，线程 A 可能错误访问新文件的数据。<br>📌 xv6 解决方法<br>dirlookup() 持有目录 inode 的锁，防止并发修改目录结构。<br>iget() 增加 inode 引用计数，确保 inode 在使用期间不会被删除。<br>iunlockput(ip) 只有在拿到 next 的 inode 后才释放 ip，避免空指针问题。</p>
<p>解决场景<br>进程 A 在 &#x2F;home&#x2F;user&#x2F;file.txt 进行 namei() 查找。<br>进程 B 同时删除 &#x2F;home&#x2F;user&#x2F;file.txt（unlink()）。<br>如果进程 A 查找 dirlookup() 期间，file.txt 的 inode 被释放，A 可能访问已被回收的 inode，导致错误。<br>📌 iget() 如何解决？<br>iget() 先检查 inode 是否已在 inode cache 中：<br>如果已存在，增加 ip-&gt;ref，确保 inode 不会被 unlink() 释放。<br>如果不存在，分配新 inode，初始化 ref &#x3D; 1。<br>这样，即使 unlink() 试图删除 inode，它的 ref &gt; 0，不会被回收。</p>
<p>解决场景<br>问题：路径解析时，inode 释放顺序错误<br>假设：</p>
<p>进程 A 在 namex() 解析 &#x2F;home&#x2F;user&#x2F;file.txt。<br>namex() 先锁定 &#x2F;home，然后查找 user，再查找 file.txt。<br>如果 namex() 先释放 &#x2F;home，再查找 user，user 可能已被删除，导致 ip &#x3D; NULL。<br>iunlockput(ip) 只有在 拿到 next 目录的 inode 后才释放 ip：<br>确保 ip 仍然有效，避免 ip &#x3D; NULL。<br>防止 next 为空，导致 inode 释放顺序错误。<br>这样，路径解析时，不会访问已经释放的 inode。</p>
<p>解决场景<br>在 xv6，如果一个 inode 被多次锁定，可能导致死锁。</p>
<p>📌 示例：查找 .（当前目录）<br>cd .<br>namex() 解析 .，dirlookup() 返回当前 inode。<br>next &#x3D;&#x3D; ip，如果 ip 没解锁就锁定 next，会导致死锁。</p>
<h3 id="inode锁-1"><a href="#inode锁-1" class="headerlink" title="inode锁"></a>inode锁</h3><p>在 xv6：</p>
<p>ilock(ip) 锁定 inode，防止并发修改。<br>iunlock(ip) 解锁 inode，允许其他进程访问。<br>路径查找 (namex()) 需要逐级锁定 inode，但必须按顺序解锁，否则可能死锁。</p>
<p>核心策略：<br>在锁定 next 之前，一定要解锁 ip。<br>确保 ip 的锁不会在获取 next 时仍然持有。</p>
<p>当前目录的 inode（user 目录的 inode 4）和 .（当前目录的 inode）是相同的！<br>因此，在 namex() 解析 . 时，dirlookup(ip, “.”) 返回 inode 4 本身。<br>但 namex() 没有意识到 next &#x3D;&#x3D; ip，仍然尝试对 next 进行 ilock(next)，导致死锁！</p>
<h2 id="8-13-文件描述符"><a href="#8-13-文件描述符" class="headerlink" title="8.13 文件描述符"></a>8.13 文件描述符</h2><p>在 xv6 和 Unix 体系中，“一切皆文件”：</p>
<p>文件、管道（pipe）、设备（如终端 tty）、套接字（socket） 都可以通过 文件描述符（File Descriptor, FD） 进行访问。<br>这层抽象允许进程使用 相同的系统调用（如 read()、write()）操作不同的资源，保持一致性。<br> xv6 为每个进程维护一个 文件描述符表，存储在 proc-&gt;ofile[]：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// **进程的打开文件表**</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个 ofile[i] 都指向一个 struct file，表示进程打开的文件。<br>多个进程可以共享 struct file（例如 dup() 或 fork()）。<br>每个 struct file 记录文件的 inode 或 pipe，以及 I&#x2F;O 偏移量（offset）。</p>
<p> struct file 结构<br>🔹 xv6 中所有打开的文件都用 struct file 表示：<br>struct file {<br>    enum { FD_NONE, FD_PIPE, FD_INODE } type;  &#x2F;&#x2F; <strong>文件类型</strong><br>    int ref;     &#x2F;&#x2F; <strong>引用计数</strong><br>    char readable;  &#x2F;&#x2F; <strong>是否可读</strong><br>    char writable;  &#x2F;&#x2F; <strong>是否可写</strong><br>    struct pipe *pipe;  &#x2F;&#x2F; <strong>如果是管道，指向 <code>pipe</code> 结构</strong><br>    struct inode *ip;   &#x2F;&#x2F; <strong>如果是普通文件，指向 <code>inode</code></strong><br>    uint off;     &#x2F;&#x2F; <strong>I&#x2F;O 偏移量（仅对 <code>inode</code> 文件有效）</strong><br>};<br>✔ ref：引用计数，防止文件被误关闭。<br>✔ type：标识文件类型（普通文件 or 管道）。<br>✔ off：表示 lseek() 读取或写入的位置（对 inode 有效）。<br>✔ readable &#x2F; writable：记录当前文件的访问模式。</p>
<p>ftable：全局文件表<br>🔹 xv6 维护了一个全局文件表 ftable，存储所有打开的 struct file：<br>struct {<br>    struct spinlock lock;<br>    struct file file[NFILE];  &#x2F;&#x2F; <strong>系统中所有打开的文件</strong><br>} ftable;<br>每个进程的 ofile[] 只是 ftable 的指针。<br>多个进程可以共享 struct file（比如 dup() 或 fork()）。<br>ftable 负责文件的分配、复制、关闭等管理。</p>
<p>ftable 提供的核心函数<br>📌 filealloc() – 分配一个新的 struct file<br>🔹 在 ftable 中查找 ref &#x3D;&#x3D; 0 的空文件项：<br>✔ filealloc() 用于 open()，为新打开的文件分配 struct file。</p>
<p>filedup() – 复制 file（增加引用计数）<br>用于 dup()，fork() 继承文件时，确保 file 不会被过早关闭。</p>
<p> fileclose() – 关闭 file<br>  如果 ref &#x3D;&#x3D; 0，真正关闭文件，释放 inode 或 pipe 资源。</p>
<p>fileread() &#x2F; filewrite() 实现文件 I&#x2F;O<br>📌 fileread() – 读取文件<br>如果是普通文件（FD_INODE），调用 readi() 读取 inode 数据。<br>✔ 文件偏移量 off 自动增加，保证下一次 read() 读取下一个字节。</p>
<p>📌 filewrite() – 写入文件<br>写入 inode，并增加 off 偏移量，保证下次写入不会覆盖前面的数据。<br>✔ 多个 write() 可能交错执行，但不会覆盖彼此的数据（因为 ilock() 保护 off ）。</p>
<p>程如何打开&#x2F;读写&#x2F;关闭文件<br>操作	函数	作用<br>open()	filealloc()	分配 struct file 并添加到进程 ofile[]<br>dup()	filedup()	增加 file-&gt;ref，共享 file<br>read(fd)	fileread()	从 inode 读取数据，更新 file-&gt;off<br>write(fd)	filewrite()	向 inode 写入数据，更新 file-&gt;off<br>close(fd)	fileclose()	减少 file-&gt;ref，若 ref &#x3D;&#x3D; 0 释放 inode</p>
<p>当 read(fd, buf, n) 被调用：</p>
<p> 文件系统会按照如下步骤读取数据：</p>
<p>找到文件的 struct file 结构（通过 fd 在进程 ofile[] 表中查找）。<br>找到 inode，检查文件大小、数据块位置。<br>通过 bmap() 计算数据块号（如果 off 对应的是直接块，就直接返回块号）。<br>调用 bread() 读取磁盘块（如果缓存中已有，则直接返回缓存数据）。<br>从 buffer cache 复制数据到用户进程的 buf。。</p>
<p> 要读取一个文件，xv6 需要找到以下信息：</p>
<p>数据结构	作用	read(fd) 需要吗？<br>目录项 (dirent)	记录文件名 → inode 号	❌ 只在 open() 解析路径时用到<br>inode (struct inode)	记录文件大小、数据块地址	✅ 需要，找到数据块位置<br>struct file	进程打开的文件信息（inode + 偏移量）	✅ 需要，维护 fd 的偏移量<br>数据块 (data block)	存储实际的文件内容	✅ 需要，真正读取的内容</p>
<p>录项 (dirent) 只在 open() 时使用<br>🔹 在 read(fd) 过程中，目录项 (dirent) 不会被访问，因为：</p>
<p>目录项（dirent）只存储文件名和 inode 号，read() 已经通过 fd 找到了 inode。<br>目录项在 open(path) 解析路径时使用，一旦文件被打开，就不再需要 dirent 了。</p>
<h3 id="filestat-、fileread-和-filewrite-在-xv6-文件系统中的作用"><a href="#filestat-、fileread-和-filewrite-在-xv6-文件系统中的作用" class="headerlink" title="filestat()、fileread() 和 filewrite() 在 xv6 文件系统中的作用"></a>filestat()、fileread() 和 filewrite() 在 xv6 文件系统中的作用</h3><p>在 xv6 中，filestat()、fileread() 和 filewrite() 分别用于：</p>
<p>filestat() 获取文件的 stat 信息（文件大小、inode 号等）。<br>fileread() 读取文件数据（支持普通文件 &amp; 管道）。<br>filewrite() 写入文件数据（支持普通文件 &amp; 管道）。<br>这些函数主要处理 inode 和 pipe，但只有 inode 文件有 I&#x2F;O 偏移量（file-&gt;off），管道 (pipe) 没有偏移概念。</p>
<p> 为什么 inode 需要锁定？<br>🔹 inode 读&#x2F;写操作必须加锁（ilock()），否则可能会产生数据竞争。</p>
<p>多个进程同时 write(fd, buf, n)，可能修改 file-&gt;off，导致数据错乱。<br>多个进程同时 read(fd, buf, n)，可能导致读取错位。<br>📌 竞争示例（不加锁会出错）<br>假设：</p>
<p>进程 A 执行 write(fd, “ABC”, 3)。<br>进程 B 执行 write(fd, “DEF”, 3)。<br>如果 file-&gt;off 不是原子更新：</p>
<p>进程 A 读取 file-&gt;off &#x3D; 0。<br>进程 B 读取 file-&gt;off &#x3D; 0（同时进行）。<br>进程 A 写入 ABC，并更新 file-&gt;off &#x3D; 3。<br>进程 B 也写入 DEF，但仍然认为 file-&gt;off &#x3D; 0。<br>最终，文件内容可能变成 DEF，丢失 ABC！</p>
<p>特性	普通文件（inode）	管道（pipe）<br>存储位置	数据块（磁盘）	内存缓冲区<br>偏移量 (file-&gt;off)	✅ 需要，控制 read&#x2F;write 位置	❌ 没有偏移量，数据按 FIFO 方式传输<br>锁定 (ilock)	✅ 需要，防止 file-&gt;off 竞争	❌ 不需要，管道是顺序操作<br>适用场景	磁盘文件 read(fd)、write(fd)	pipe(fd[0], fd[1]) 进行进程间通信</p>
<h2 id="8-14-系统调用"><a href="#8-14-系统调用" class="headerlink" title="8.14 系统调用"></a>8.14 系统调用</h2><h3 id="sys-link-sys-unlink-以及-create-的作用"><a href="#sys-link-sys-unlink-以及-create-的作用" class="headerlink" title="sys_link() &amp; sys_unlink() 以及 create() 的作用"></a>sys_link() &amp; sys_unlink() 以及 create() 的作用</h3><p>在 xv6 文件系统中：</p>
<p>sys_link()：创建一个新的目录项，使其指向已有的 inode（类似 ln 命令）。<br>sys_unlink()：删除目录项，减少 inode 的 nlink 计数（类似 rm 命令）。<br>create()：为新 inode 创建一个目录项（如 open(O_CREATE)、mkdir()、mknod()）。</p>
<p>ys_link()：创建新的硬链接<br>🔹 作用：</p>
<p>创建一个新的目录项，使其指向已有的 inode（即增加 inode 的 nlink 计数）。<br>如果 old 文件被删除，新 new 仍然能访问相同的数据。</p>
<p>1	namei(old) 找到 old 的 inode	inode<br>2	增加 ip-&gt;nlink++，表示多了一个目录项指向它	inode<br>3	nameiparent(new) 找到 new 的父目录 dp	inode<br>4	dirlink(dp, name, ip-&gt;inum) 创建目录项，使其指向 ip	dirent<br>5	如果失败，回滚 nlink–	inode<br>6	提交事务，确保 inode &amp; dirent 同步写入磁盘	事务日志</p>
<p>&#x2F; (inode 1)<br> ├── home (inode 3)<br> │   ├── user (inode 4)<br> │       ├── file.txt (inode 5)  &lt;– <code>inode</code> 5<br> sys_link() 先查找 file.txt：<br>通过 namei(“file.txt”) 找到 inode 5。<br>inode 5 的 nlink++，从 1 增加到 2。<br>sys_link() 在当前目录 &#x2F;home&#x2F;user&#x2F; 创建 link.txt：<br>dirlink(dp, “link.txt”, 5) 在 &#x2F;home&#x2F;user&#x2F; 添加 dirent：</p>
<p>&#x2F;home&#x2F;user&#x2F;<br>├── file.txt (inode 5)<br>├── link.txt (inode 5)  &lt;– 共享 inode 5<br> link.txt 和 file.txt 共享 inode 5，即同一文件的两个名字！</p>
<p>3️⃣ sys_unlink()：删除目录项<br>🔹 作用：</p>
<p>删除 dirent，减少 inode 的 nlink 计数。<br>如果 nlink &#x3D;&#x3D; 0，释放 inode 数据块。</p>
<p>4️⃣ create()：创建新文件<br>🔹 作用：</p>
<p>open(O_CREATE) 创建新文件。<br>mkdir() 创建新目录。<br>mknod() 创建新设备文件。<br>✔ ialloc() 分配新的 inode。<br>✔ 如果 type &#x3D;&#x3D; T_DIR，创建 . 和 .. 目录项。<br>✔ dirlink() 在 dp 目录下创建新目录项，使其指向 ip。<br>✔ 事务 begin_op() &amp; end_op() 确保 inode &amp; dirent 同步更新，防止崩溃导致文件系统不一致。</p>
<p>同步更新<br> 事务 begin_op() &amp; end_op() 确保 inode &amp; dirent 同步更新，防止崩溃导致文件系统不一致。</p>
<p> 修改 inode 的 nlink 计数。<br>创建新的 dirent（目录项）。<br>🔹 如果在两个操作之间崩溃，文件系统可能变得不一致！</p>
<p>例如：<br>inode-&gt;nlink++ 已执行，但 dirent 还没写入，导致 inode 永远不会被释放（nlink 变成幽灵值！）。<br>dirent 已写入，但 inode-&gt;nlink++ 失败，导致 unlink() 可能错误删除仍然被引用的 inode。<br>✅ xv6 通过事务 (begin_op() &amp; end_op()) 确保 inode 和 dirent 同步更新，要么 所有修改生效，要么 什么都不做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin_op</span>();  <span class="comment">// **开始事务**</span></span><br><span class="line"></span><br><span class="line">dp = <span class="built_in">nameiparent</span>(<span class="string">&quot;file.txt&quot;</span>, name);  <span class="comment">// **找到父目录 inode**</span></span><br><span class="line"><span class="built_in">ilock</span>(dp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ip = <span class="built_in">dirlookup</span>(dp, name, <span class="number">0</span>)) != <span class="number">0</span>) &#123;  <span class="comment">// **文件已存在**</span></span><br><span class="line">    <span class="built_in">iunlockput</span>(dp);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ip = <span class="built_in">ialloc</span>(dp-&gt;dev, T_FILE);  <span class="comment">// **分配新的 `inode`**</span></span><br><span class="line"><span class="built_in">ilock</span>(ip);</span><br><span class="line"></span><br><span class="line">ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">iupdate</span>(ip);  <span class="comment">// **更新 `inode`，写入磁盘**</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dirlink</span>(dp, name, ip-&gt;inum);  <span class="comment">// **创建 `dirent`**</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">iunlockput</span>(dp);</span><br><span class="line"><span class="built_in">end_op</span>();  <span class="comment">// **提交事务**</span></span><br><span class="line"><span class="keyword">return</span> ip;</span><br></pre></td></tr></table></figure>
<p>1	ialloc() 分配 inode	inode 还没写入磁盘，事务保护<br>2	ip-&gt;nlink &#x3D; 1，iupdate(ip)	inode 被标记为 “已用”，但 dirent 还没写入<br>3	dirlink(dp, “file.txt”, ip-&gt;inum)	创建 dirent，目录项指向 inode<br>4	end_op() 提交事务	确保 inode &amp; dirent 同时写入磁盘</p>
<p>📌 事务未完成时，缓存的数据会改变吗？<br>✅ 是的，事务未完成时，buffer cache（缓存）中的数据会被修改，但不会立刻写入磁盘！<br>✅ 只有在 end_op() 提交事务后，缓存数据才会同步到磁盘文件系统。<br>✅ 如果崩溃发生在 end_op() 之前，buffer cache 中的未提交修改可能会丢失，但磁盘数据不会受到影响。<br>在事务 (begin_op() &amp; end_op()) 内，所有 inode &amp; dirent 修改都会先存入 buffer cache（缓存），但不会立刻写入磁盘。<br>✅ 事务提交 (end_op()) 时，buffer cache 的数据才会同步到磁盘文件系统。<br>✅ 如果 end_op() 之前崩溃，所有缓存修改都会丢失，磁盘不会受到影响。<br>✅ 如果 end_op() 之后崩溃，xv6 在重启时会自动从日志恢复事务，确保 inode 和 dirent 一起写入磁盘，防止文件系统不一致。<br>✅ 最终，事务机制确保：”要么所有修改都生效，要么什么都不做”，防止部分更新导致磁盘损坏！</p>
<p>📌 问题：磁盘里的数据 ID 和缓存 (buffer cache) 里的数据 ID 一样吗？<br>✅ 是的，磁盘中的数据 ID（如 block number、inode number）和缓存 (buffer cache) 里的数据 ID 是一样的，操作系统可以完成同等替换。<br>✅ 缓存中的数据是磁盘块的一个副本，操作系统可以在缓存和磁盘之间同步数据。</p>
<h2 id="8-15-真实应用"><a href="#8-15-真实应用" class="headerlink" title="8.15 真实应用"></a>8.15 真实应用</h2><p>📌 xv6 作为教学操作系统，文件系统 (FS) 设计较为简单。<br>📌 现代 FS（如 ext4、NTFS、ZFS）在缓存、日志、目录查找、崩溃恢复等方面有很多改进。</p>
<p>1️⃣ buffer cache 的改进<br>🔹 xv6 使用 buffer cache，但仍然有局限性<br>xv6 的 buffer cache 主要用于缓存磁盘块，减少 I&#x2F;O。<br>使用最近最少使用（LRU）策略，但只基于 链表，效率较低：<br>需要 线性扫描 查找缓存块。<br>不能高效管理大量缓存块。</p>
<p>🔹 现代操作系统如何优化 buffer cache？<br>✔ 改进 LRU 机制</p>
<p>xv6 采用 简单 LRU（链表管理）。<br>现代 OS 采用 LRU-K &#x2F; CLOCK &#x2F; ARC 等更复杂的策略，提高缓存命中率。<br>例如 Linux 采用 “双队列 LRU”（Active 和 Inactive 列表）。</p>
<p>✔ 哈希表加速 block 查找<br>xv6 使用 链表查找，查找缓存块时效率低。<br>现代 FS 使用 哈希表（Hash Table） 进行 O(1) 时间复杂度 查找。</p>
<p>✔ 与虚拟内存（VM）系统集成</p>
<p>现代 OS 的 buffer cache 可以支持内存映射文件（mmap），避免不必要的磁盘 I&#x2F;O。 了解下这个<br>xv6 没有支持 mmap()，只能通过 read&#x2F;write 进行 I&#x2F;O。<br>先说说I&#x2F;O<br>在操作系统中，I&#x2F;O 资源 指的是 所有用于数据输入（Input）和输出（Output）的硬件与软件资源，主要包括：</p>
<p>CPU 处理 I&#x2F;O 相关的任务<br>磁盘 I&#x2F;O（文件读写）<br>网络 I&#x2F;O（网络数据传输）<br>内存 I&#x2F;O（数据在内存中的传输）<br>设备 I&#x2F;O（如键盘、鼠标、显示器等）<br>📌 在 mmap() vs read()&#x2F;write() 的讨论中，I&#x2F;O 主要指：</p>
<p>磁盘 I&#x2F;O（disk I&#x2F;O）：文件系统访问数据的磁盘读取和写入<br>CPU 处理 I&#x2F;O 请求（CPU I&#x2F;O）：执行 syscall 处理 read()&#x2F;write() 操作<br>内存 I&#x2F;O（memory I&#x2F;O）：数据在 buffer cache 和用户进程之间的拷贝<br>传统 read() &#x2F; write() 方式会 多次拷贝数据，增加 CPU 和磁盘 I&#x2F;O 负担，导致 I&#x2F;O 资源浪费。</p>
<p>🔹 read() 过程：多次数据拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="built_in">read</span>(fd, buffer, size);  <span class="comment">// **从磁盘读入 buffer**</span></span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line">📌 <span class="built_in">read</span>() 发生了 <span class="number">3</span> 次数据拷贝</span><br></pre></td></tr></table></figure>
<p>磁盘 I&#x2F;O（Disk I&#x2F;O）：操作系统从磁盘读取 file.txt 到 buffer cache（一次 I&#x2F;O 操作）<br>内存拷贝（Memory I&#x2F;O）：copy_to_user() 把 buffer cache 数据拷贝到用户进程的 buffer<br>CPU 处理 syscall（CPU I&#x2F;O）：每次 read() 需要执行 syscall，导致 CPU 开销<br>📌 mmap() 让进程直接访问 buffer cache，消除了 read() 的额外拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">char</span> *addr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, addr[<span class="number">0</span>]);  <span class="comment">// **直接访问文件数据**</span></span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line">✅ 优化点：</span><br></pre></td></tr></table></figure>
<p>减少一次 copy_to_user()：进程可以直接访问 buffer cache，数据 零拷贝（Zero-copy）<br>减少 syscall 负担：只需要一次 mmap()，后续访问 addr[i] 不需要 syscall<br>降低 CPU 和磁盘 I&#x2F;O 开销</p>
<p>示例：Linux buffer cache 改进</p>
<p>优化点	xv6	Linux &#x2F; BSD<br>LRU 机制	仅链表 LRU	LRU-K &#x2F; CLOCK &#x2F; ARC<br>块查找	线性扫描	哈希表 (O(1))<br>内存管理	独立 buffer cache	与虚拟内存 (VM) 共享<br>内存映射	不支持 mmap()	支持 mmap()</p>
<h3 id="日志改进"><a href="#日志改进" class="headerlink" title="日志改进"></a>日志改进</h3><p>2️⃣ xv6 日志系统的局限性<br>🔹 xv6 日志系统 (journaling) 存在的问题<br>✅ 事务不能与其他文件系统调用并行提交<br>✅ 即使只修改 1 字节，仍然会记录整个 block<br>✅ 日志写入是同步的，影响性能</p>
<p>xv6 每次 提交一个事务时，写入整个日志块，可能会导致每次写入都等待整个磁盘旋转时间（影响 I&#x2F;O 性能）。<br>真正的日志系统（如 ext4 的 journal）可以 合并多个事务，减少磁盘 I&#x2F;O。<br>🔹 现代 FS 如何改进？<br>✔ 支持 group commit（批量提交）</p>
<p>xv6 不能并行执行多个事务，而 ext4 等现代文件系统允许多个事务合并，减少磁盘 I&#x2F;O。<br>✔ 支持 metadata journaling</p>
<p>xv6 所有数据变更都写入日志，影响性能。<br>现代文件系统（如 ext3）使用 “仅日志记录元数据” 的方式，提高效率。<br>✔ 支持 asynchronous commit（异步提交）</p>
<p>xv6 每次 commit 必须同步写入磁盘。<br>现代 FS 可以 批量提交事务，提高吞吐量。</p>
<p>优化点	    xv6	      ext4 &#x2F; ZFS<br>并行事务	❌ 不能	✅ 可以<br>事务合并	❌ 不能	✅ group commit<br>日志记录	数据 + 元数据	仅元数据 (metadata journaling)<br>日志模式	同步提交	异步提交 (delayed commit)</p>
<h3 id="日志恢复及其磁盘检查"><a href="#日志恢复及其磁盘检查" class="headerlink" title="日志恢复及其磁盘检查"></a>日志恢复及其磁盘检查</h3><p>🔹 xv6 使用日志（journaling）来恢复崩溃<br>xv6 事务失败时，不会影响磁盘文件系统的完整性。<br>早期 UNIX 使用 fsck（文件系统检查工具）扫描磁盘，但速度慢：<br>fsck 需要 遍历整个 inode、目录项、空闲块列表，检查一致性。<br>如果文件系统大（如 100GB+），fsck 可能需要几个小时。<br>🔹 现代 FS（如 ext4）采用 journaling（日志恢复）<br>日志系统 (journaling FS) 只需重放日志，快速恢复崩溃。<br>比 fsck 快得多，避免文件系统在崩溃后无法使用。</p>
<p>方法	xv6	UNIX fsck	ext3&#x2F;ext4 Journaling<br>崩溃恢复方式	日志重放	遍历所有 inode	日志重放<br>恢复速度	快（只需重放日志）	慢（扫描整个 FS）	快（只需重放日志）</p>
<h3 id="目录查找优化"><a href="#目录查找优化" class="headerlink" title="目录查找优化"></a>目录查找优化</h3><p>🔹 xv6 目录查找性能低<br>✅ xv6 目录采用 线性扫描，如果目录有 1000+ 个文件，查找一个文件需要 O(n) 时间。<br>✅ 当目录项较少时（如 10-20 个文件），O(n) 查找仍然可以接受，但在大目录中性能很差！</p>
<p>🔹 现代 FS（如 ext4、NTFS、ZFS）采用 B+树 加速目录查找<br>ext4 使用 htree（哈希索引），目录查找为 O(log n)。<br>NTFS 和 ZFS 采用 B+树 结构，查找效率更高。</p>
<p>方法	xv6	ext4 (htree)	NTFS &#x2F; ZFS (B+树)<br>查找方式	线性扫描 (O(n))	哈希索引 (O(log n))	B+树 (O(log n))<br>适用于小目录？	✅ 是	✅ 是	✅ 是<br>适用于大目录？	❌ 否	✅ 是	✅ 是</p>
<h3 id="处理磁盘故障"><a href="#处理磁盘故障" class="headerlink" title="处理磁盘故障"></a>处理磁盘故障</h3><p>🔹 xv6 对磁盘故障处理很初级<br>如果磁盘 I&#x2F;O 失败，直接 panic，导致整个系统崩溃：<br>c<br>复制<br>编辑<br>panic(“disk error”);<br>如果 OS 运行在 RAID（冗余磁盘）上，问题不大，因为 RAID 可以屏蔽故障。<br>但如果 OS 运行在单块磁盘上，文件系统应该更优雅地处理磁盘坏块，而不是直接 panic！<br>🔹 现代 FS 如何处理磁盘错误？<br>✔ RAID + 冗余数据（ext4、ZFS、Btrfs）<br>✔ 坏块管理（Bad Block Remapping），自动跳过故障扇区<br>✔ 快照 (Snapshot) 保护数据，防止磁盘损坏影响所有数据</p>
<h3 id="现代文件系统的扩展性-vs-xv6-的局限性"><a href="#现代文件系统的扩展性-vs-xv6-的局限性" class="headerlink" title="现代文件系统的扩展性 vs. xv6 的局限性"></a>现代文件系统的扩展性 vs. xv6 的局限性</h3><p> xv6 的文件系统是静态的，每个文件系统只能安装在一个固定大小的磁盘上。<br>📌 现代操作系统通过 RAID、ZFS、NFS、procfs 等技术实现更灵活的存储管理。</p>
<p>1️⃣ xv6 文件系统的局限性<br>xv6 文件系统的设计非常简单，仅支持单个磁盘，且磁盘大小固定：</p>
<p>所有数据存储在一个磁盘设备上，不能跨多个磁盘存储。<br>磁盘空间是固定的，不能动态扩展文件系统。<br>inode 的数量也是固定的，无法动态增长 inode。<br>📌 问题：</p>
<p>现代应用（如 数据库、多媒体存储）需要 TB 级存储，单个磁盘可能无法满足需求。<br>磁盘容量有限，不能动态扩展，当磁盘满了，文件系统无法再存储数据。<br>现代系统需要 数据冗余、快照、备份、分布式存储，而 xv6 没有这些功能。</p>
<p>2️⃣ 现代操作系统如何扩展文件系统？<br>为了突破 xv6 的 “单文件系统 &#x3D; 单磁盘” 限制，现代操作系统采用 存储虚拟化技术：</p>
<p>🔹 1. RAID（Redundant Array of Independent Disks，磁盘阵列）<br>📌 RAID 通过硬件或软件把多个物理磁盘组合成一个逻辑磁盘，提高性能和可靠性：<br>下面都是一种模式 不是分批次起名<br>RAID 0（条带化 Striping）：提高磁盘 I&#x2F;O 速度，但无冗余（适合高速存储）。<br>RAID 1（镜像 Mirroring）：两个磁盘存相同数据，提高可靠性。<br>RAID 5&#x2F;6（带奇偶校验）：允许磁盘故障时数据不丢失。<br>💡 示例：Linux mdadm 组 RAID</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mdadm --create --verbose /dev/md0 --level=<span class="number">5</span> --raid-devices=<span class="number">3</span> /dev/sda /dev/sdb /dev/sdc</span><br><span class="line">mkfs.ext4 /dev/md0</span><br><span class="line">mount /dev/md0 /mnt/raid</span><br><span class="line">✅ 多个磁盘合并成 /dev/md0，文件系统可以跨多个磁盘扩展！</span><br></pre></td></tr></table></figure>

<p>🔹 2. LVM（Logical Volume Manager，逻辑卷管理）<br>📌 LVM 允许动态添加、扩展、缩小磁盘，而不影响已有数据。</p>
<p>比 RAID 更灵活，LVM 可以动态扩展文件系统，而 RAID 不能。<br>支持快照，可用于备份和恢复。<br>💡 示例：Linux LVM</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e /dev/sda /dev/sdb  # 创建物理卷</span><br><span class="line">vgcreate my_vg /dev/sda /dev/sdb  # 创建卷组</span><br><span class="line">lvcreate -L <span class="number">100</span>G -n my_lv my_vg  # 创建逻辑卷</span><br><span class="line">mkfs.ext4 /dev/my_vg/my_lv</span><br><span class="line">mount /dev/my_vg/my_lv /mnt/lvm</span><br><span class="line">✅ 可以随时扩展 my_vg 卷组，不受单个磁盘容量限制！</span><br></pre></td></tr></table></figure>
<p> RAID 和 LVM 是什么关系？<br>📌 RAID 和 LVM 不是并列关系，而是可以相互结合的两种存储管理方式：</p>
<p>RAID（Redundant Array of Independent Disks）：通过多个物理磁盘 组合成一个逻辑磁盘，提供 数据冗余 和 性能提升。<br>LVM（Logical Volume Manager）：在 逻辑层 管理存储，允许 动态扩展&#x2F;缩小磁盘，提高存储灵活性。</p>
<p>多个磁盘（PV）  ─&gt;  组成存储池（VG）  ─&gt;  逻辑分区（LV）  ─&gt;  挂载成文件系统<br>&#x2F;dev&#x2F;sda  ─┐<br>           ├─&gt;  [my_vg]  ─&gt;  &#x2F;dev&#x2F;my_vg&#x2F;my_lv1  (root分区)<br>&#x2F;dev&#x2F;sdb  ─┘                   &#x2F;dev&#x2F;my_vg&#x2F;my_lv2  (home分区)</p>
<p>🔹 3. ZFS（Zettabyte File System）<br>📌 ZFS 是 Sun Microsystems（Oracle）开发的高级文件系统，集成存储管理和文件系统。</p>
<p>支持 RAID（替代传统 LVM + RAID 组合）。<br>支持快照、自动修复、压缩等特性。<br>动态存储池（Storage Pool），磁盘可以随时加入、删除。<br>💡 示例：创建 ZFS 存储池</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zpool create tank mirror /dev/sda /dev/sdb</span><br><span class="line">zfs create tank/home</span><br><span class="line">zfs set compression=on tank/home</span><br><span class="line">✅ 多个磁盘 sda 和 sdb 组成 tank，可以随时扩展！</span><br></pre></td></tr></table></figure>
<p>🔹 4. 网络文件系统（NFS、SMB）<br>📌 现代 OS 支持远程存储，把文件存放在网络上的服务器，而不是本地磁盘。</p>
<p>NFS（Network File System）：Unix&#x2F;Linux 共享文件系统。<br>SMB（Server Message Block）：Windows 共享文件系统。<br>💡 示例：挂载 NFS 远程文件系统</p>
<p>mount -t nfs 192.168.1.100:&#x2F;data &#x2F;mnt&#x2F;nfs<br>✅ 客户端可以把远程存储 &#x2F;data 当成本地磁盘使用！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/13/xv6/" data-id="cm4pqjdw6000004vqgfe1gzrn" data-title="xv6" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字符串
        
      </div>
    </a>
  
  
    <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">图论-总结</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hot100/" rel="tag">hot100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hot100/" style="font-size: 10px;">hot100</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 10px;">八股文</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 12.5px;">图论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">算法，图论</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">语法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/">高频八股</a>
          </li>
        
          <li>
            <a href="/2024/12/25/hot100/">hot100</a>
          </li>
        
          <li>
            <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2024/12/13/xv6/">xv6</a>
          </li>
        
          <li>
            <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>