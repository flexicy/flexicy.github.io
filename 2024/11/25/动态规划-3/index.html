<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>动态规划-3 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。示">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划-3">
<meta property="og:url" content="http://example.com/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。示">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-25T09:06:24.000Z">
<meta property="article:modified_time" content="2024-11-28T03:23:41.552Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法，动态规划">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-动态规划-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/" class="article-date">
  <time class="dt-published" datetime="2024-11-25T09:06:24.000Z" itemprop="datePublished">2024-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      动态规划-3
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1<br>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这个竟然可以用动态规划解决？离谱<br>从原理上来说就是回溯问题 回溯可以修改成dp<br>我看一下标准解答<br>看了解答了 非常的劲爆<br>设定dp[i]为以[i]为结尾的最长字串个数<br>递推公式<br>if(nums[i] &gt;nums[j]){<br>    dp[i] &#x3D;max(dp[j]+1,dp[i])这里的max单纯是更新dp[i]的最大值 这外面套了两层循环<br>}<br>初始化<br>dp[0] &#x3D; 1 表示长度为1的字串<br>遍历顺序<br>都按照从头开始遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">1</span>);<span class="comment">//每个最少都是1</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();<span class="comment">//起始节点单独判断</span></span><br><span class="line">   <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">           dp[i] = <span class="built_in">max</span>(dp[j]<span class="number">+1</span>,dp[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       result =<span class="built_in">max</span>(result,dp[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。<br>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>多了个连续 感觉回溯更能做了 但是会超时<br>那么继续用上面的dp？ 递推公式需要修改 数组设置倒是不需要修改<br>在递推的时候就不需要考虑在前面循环去找最大的了 只需要考虑前一个和当前这个比较大小</p>
<p>没想到贪心这么好做：比前面大 ++ 不如前面就 &#x3D;1</p>
<p>用dp做一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() ,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 连续记录</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例：</p>
<p>输入：</p>
<p>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3, 2, 1] 。<br>提示：</p>
<p>1 &lt;&#x3D; len(A), len(B) &lt;&#x3D; 1000<br>0 &lt;&#x3D; A[i], B[i] &lt; 100</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这个从解法上来说使用了dp[i][j]<br>因为不想初始化<br>就设置dp[i][j]是前一个作为结尾相等的个数<br>这样递推公式<br>dp[i][j] &#x3D; dp[i-1]dp[j-1] +1;<br>从二维数组的角度来想<br>如果dp[i][j]表示当前这个为结尾的相等个数<br>那么第一行和第一列都需要初始化才行 这样才能递推后面的<br>这样-1的情况我就全变成0 可以当作起始位置<br>遍历条件二维数组怎么遍历顺序都可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(nums<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=nums<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=nums<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123; <span class="comment">//主要是-1</span></span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="number">+1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(dp[i][j],result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">变成一维数组:</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;(B.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = B.<span class="built_in">size</span>(); j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> dp[j] = <span class="number">0</span>; <span class="comment">// 注意这里不相等的时候要有赋0的操作</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; result) result = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//一维数组的情况具体来说就是二维数组的变形 这么使用需要从后往前遍历防止覆盖前一个不能得到后一个  同时因为当前如果不是相等的情况那么 需要重置为0 这样让后面续不上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:</p>
<p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。<br>提示:</p>
<p>1 &lt;&#x3D; text1.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; text2.length &lt;&#x3D; 1000 输入的字符串只含有小写英文字符。</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这个看来是加了可以断连的情况<br>离谱啊离谱 太难想了离谱中的离谱<br>在判定完dp[i][j]之后（相等的情况）还要判定一下dp[i-1][j] dp[i][j-1]；<br>多了两种判定是因为原有的[i-1][j-1]判定被否决了 同时[i-2][j-2]的判定已经完成了<br>到了[i-1][j-1]这种范围限制的时候分别用[i-2][j-1]  [i-1][j-2]尝试进行看看哪一种比较大<br>适合[i-1][j-1]同时[i-2][j-1]  [i-1][j-2]的两个值在进行当前判定的时候都已经求完了 而且默认比[i-2][j-2]等于大于看能不能多捞着一个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span>  </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(text<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;text<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;text<span class="number">2.</span><span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] =  dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text<span class="number">1.</span><span class="built_in">size</span>()][text<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h2><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>从题目分析这个题求得就是最长公共子序列所以代码是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()][B.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>贪心就是求和之后如果等于0直接从下一个开始<br>dp的话<br>dp[i]表示一直到i为结尾的这个连续和的最大值&#x2F;&#x2F;这样递推公式好写<br>那么dp[i]有两种选择 加入之前的和放弃之前的用现在的<br>递推公式<br>dp[i] &#x3D; max(nums[i],dp[i-1]+nums[i])<br>初始化<br>dp[0] &#x3D; nums[0]<br>遍历顺序<br>从前向后遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> result = dp[<span class="number">0</span>];<span class="comment">//注意这个初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i] =<span class="built_in">max</span>(nums[i].dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        result =<span class="built_in">max</span>(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “abc”, t &#x3D; “ahbgdc”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “axc”, t &#x3D; “ahbgdc”<br>输出：false<br>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 100<br>0 &lt;&#x3D; t.length &lt;&#x3D; 10^4<br>两个字符串都只由小写字符组成</p>
<h3 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h3><p>最简单的就是双指针解法了</p>
<p>到手里可以用回溯去处理<br>那么dp的话开始设置也是只有两种状态<br>为了递推公式好些需要想好我这个dp的定义<br>题解的递推公式表示的含义是dp[i][j]以i-1 j-1结尾的两个数组所含有的最多公共子串有多少个<br>那么递推公式就得修改了<br>在nums[i-1] &#x3D;&#x3D; nums[j-1]的时候<br>dp[i][j] &#x3D;dp[i-1][j-1]<br>在不相等的时候<br>dp[i][j] &#x3D; dp[i-1][j]  这个时候不能j-1 因为我们要求得是s是否是t的字串所以s不能节省去和t匹配 一旦节省匹配上了 那么后续可能省略s中的一个<br>但是 但是 我发现只要最后判断是否数量上相等就可以了 所以省略不省略无所谓了 所以还是上文的代码最后进行一个判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围</p>
<h3 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h3><p>这道题的解法就是可以有重复的 那么对于当前的dp[i][j]它的个数既可以采用当前的i-1和j-1这两个特定数对应的数量dp[i-1][j-1] 同时dp[i][j]的个数还有不采用这个当前s这个对应的数量dp[i-1][j1]<br>这样就是分成两种情况对于当前的这个t序列采用不采用当前s来进行t的匹配 把情况占满了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置dp数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">szie</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//还有第一排和第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=t.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][j.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<p>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
<h3 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h3><p>理论上来说可以用相同的子序列算法 之后用所有的大小减去一下 等一下试试 本身肯定不难 但是为了铺垫距离计算只能用这个特殊方法了<br>现在用正常思路的dp<br>确定dp数组（dp table）以及下标的含义<br>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。<br>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] &#x3D; dp[i - 1][j - 1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] &#x3D; min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p>
<p>因为 dp[i][j - 1] + 1 &#x3D; dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] &#x3D; min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</p>
<p>需要注意的是dp[i - 1][j - 1] + 2 相当于不考虑一个的同时还删去了另一个 相当于不考虑两个所以<br>dp[i - 1][j - 1] + 2 &#x3D;另外两种方式 + 1 所以比较大小比较两个就可以了</p>
<p>遍历公式<br>从左到右<br>从上到下</p>
<p>初始化<br>dp[0][0] &#x3D; 0;<br>dp[i][0] &#x3D; i;i-1为结尾的字符删除多少个才能是空的字符串 0到i-1一共有i个<br>dp[0][j] &#x3D; j;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>，<span class="number">0</span>))；</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>]<span class="number">+1</span>,dp[i<span class="number">-1</span>][j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>()][word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符</p>
<p>删除一个字符</p>
<p>替换一个字符</p>
<p>示例 1：</p>
<p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</p>
<p>输出：3</p>
<p>解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：</p>
<p>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”</p>
<p>输出：5</p>
<p>解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’)</p>
<p>提示：</p>
<p>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500<br>word1 和 word2 由小写英文字母组成</p>
<h3 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h3><p>顶级了属于 增删查改<br>删除和上面一样<br>dp[i][j] &#x3D; min(dp[i-1][j]+1,dp[i][j-1]+1);<br>添加<br>dp[i][j] &#x3D; min(dp[i-1][j]+1,dp[i][j-1]+1);<br>添加也是有一个不同之后按照多出来的的一个的dp基础上进行添加操作 最后比大小<br>替换<br>当前的不对应 所以替换后对应了 这是1次操作 之前的操作是dp[i-1][j-1]<br>dp[i][j] &#x3D;dp[i-1][j-1]+1 &#x2F;&#x2F;这里想了想其他操作 如果按照顺序替换逻辑来说这么写没毛病</p>
<p>当我们不管是添加还是删除操作的时候因为当前两个元素不相等 那么多出来的那一个和没多出来的那一行本身匹配的次数再加上当前没多出来的那一行未被包含的那一个被删除的次数（+1）<br>添加操作也是如此本身也搭配不上多出来的那一个 那么就用原有的上一个状态加上添加这个操作<br>删除和添加都是为了尽量匹配 为不是一下就能匹配上</p>
<p>那么替换这个操作表示的则是当前两个i和j直接进行替换就能匹配上 那么就是原有的个数+1个 要是向增加和删除学习的话无法替换了 因为那种情况你都匹配完了 不知道该替换成什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(word<span class="number">1.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word<span class="number">2.</span><span class="built_in">size</span>()<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化 第一列和第一行</span></span><br><span class="line">    <span class="comment">//如果一个是空字符串的话 其他的也只能全部删除了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word<span class="number">1.</span><span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word<span class="number">2.</span><span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;)<span class="number">+1</span>;<span class="comment">//起始我理解的也是没错的 因为是求最小值所以不能省略最后一个 要是求最大值直接把最后一个删去了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word<span class="number">1.</span><span class="built_in">size</span>(),word<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<p>输入：”abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”<br>示例 2：</p>
<p>输入：”aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”<br>提示：输入的字符串长度不会超过 1000 。</p>
<h3 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h3><p>回溯能做到分割回文子串 为此我可以最后结果存在set里面<br>暴力可以做到两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文<br>我之前回溯的时候写过判断回文子串的函数等会粘一下<br>哈哈 我构建的函数原来就是dp数组求解方式哈哈</p>
<p>这道题dp的话<br>首先构建数组dp[i][j]表示i到j这个字符串可以判定是否是回文字符串<br>递推三种情况<br>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串<br>情况二：下标i 与 j相差为1，例如aa，也是回文子串<br>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。<br>初始化<br>都为false<br>遍历顺序 一个是从+1推出来的 一个是从-1推导出来的 那么就是从下到上 从左到右</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> result =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 只包含小写英文字母</p>
<h3 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h3><p>那就dp的时候加个距离最大判断呗<br>这就错了 子序列不要求连续<br>不能连续的话dp怎么判定数组呢 设置一个dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。</p>
<p>递推公式&#x2F;&#x2F;这里递推公式也有个不同的地方在于不能同时出发了 最少差了一个的遍历环境<br>如果s[i]与s[j]相同，那么dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;<br>不相等的话应该比较一下最大值<br>加入s[j]的回文子序列长度为dp[i + 1][j]。</p>
<p>加入s[i]的回文子序列长度为dp[i][j - 1]。<br>dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</p>
<p>初始化可能有些费劲了从下到上遍历 从左到右遍历 那么就是最下面那一行和最左面那一列<br>从表格来看可以设定对角线来设置最开始的数<br>从另外一个角度考虑就是这dp数组无法得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        dp[i][i] =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递推公式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =i<span class="number">+1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">+1</span>][j<span class="number">-1</span>] <span class="number">+2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="交替组2"><a href="#交替组2" class="headerlink" title="交替组2"></a>交替组2</h2><p>给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：</p>
<p>colors[i] &#x3D;&#x3D; 0 表示第 i 块瓷砖的颜色是 红色 。<br>colors[i] &#x3D;&#x3D; 1 表示第 i 块瓷砖的颜色是 蓝色 。<br>环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。</p>
<p>请你返回 交替 组的数目。</p>
<p>注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的</p>
<h3 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h3><p>之前是用的k为固定所以很好解决 但是这一次k不固定了<br>那么拼接数组或者 取余数之后滑动窗口进行判定呢？<br>10101010<br>怎么用滑动窗口判定这个窗口是否符合呢 这类似与暴力了 会超时是的<br>拼接数组加枚举右端点解决 记住枚举右侧端点 下面这代码逻辑也改不了确实就是右侧端点逻辑<br>开始用第二个数组进行罗列的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfAlternatingGroups</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; colors, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//环的问题可以用%去解决 但是数这个问题  </span></span><br><span class="line">        <span class="type">int</span> n = colors.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; colors[i % n] == colors[(i - <span class="number">1</span>) % n]) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            ans += i &gt;= n &amp;&amp; cnt &gt;= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/" data-id="cm4ckzpeh00004gvq2eed6ll8" data-title="动态规划-3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          单调栈
        
      </div>
    </a>
  
  
    <a href="/2024/11/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">动态规划-2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/">每日一题</a>
          </li>
        
          <li>
            <a href="/2024/12/01/%E5%9B%BE%E8%AE%BA/">图论</a>
          </li>
        
          <li>
            <a href="/2024/11/28/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>
          </li>
        
          <li>
            <a href="/2024/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3/">动态规划-3</a>
          </li>
        
          <li>
            <a href="/2024/11/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2/">动态规划-2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>