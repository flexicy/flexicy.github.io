<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>高频八股 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="HTTPS和HTTP有哪些区别HTTP（HyperText Transfer Protocol）：超文本传输协议，负责在客户端（浏览器）和服务器之间传输数据，明文传输，安全性低。HTTPS（HTTP Secure）：安全超文本传输协议，在 HTTP 基础上加入 SSL&#x2F;TLS 加密层，确保数据传输的安全性。HTTP：TCP 三次握手后即可传输数据。HTTPS：TCP 三次握手后，还需进行">
<meta property="og:type" content="article">
<meta property="og:title" content="高频八股">
<meta property="og:url" content="http://example.com/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HTTPS和HTTP有哪些区别HTTP（HyperText Transfer Protocol）：超文本传输协议，负责在客户端（浏览器）和服务器之间传输数据，明文传输，安全性低。HTTPS（HTTP Secure）：安全超文本传输协议，在 HTTP 基础上加入 SSL&#x2F;TLS 加密层，确保数据传输的安全性。HTTP：TCP 三次握手后即可传输数据。HTTPS：TCP 三次握手后，还需进行">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-10T12:34:41.000Z">
<meta property="article:modified_time" content="2025-03-27T06:57:46.825Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-高频八股" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/" class="article-date">
  <time class="dt-published" datetime="2025-03-10T12:34:41.000Z" itemprop="datePublished">2025-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      高频八股
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HTTPS和HTTP有哪些区别"><a href="#HTTPS和HTTP有哪些区别" class="headerlink" title="HTTPS和HTTP有哪些区别"></a>HTTPS和HTTP有哪些区别</h2><p>HTTP（HyperText Transfer Protocol）：超文本传输协议，负责在客户端（浏览器）和服务器之间传输数据，明文传输，安全性低。<br>HTTPS（HTTP Secure）：安全超文本传输协议，在 HTTP 基础上加入 SSL&#x2F;TLS 加密层，确保数据传输的安全性。<br>HTTP：TCP 三次握手后即可传输数据。<br>HTTPS：TCP 三次握手后，还需进行 SSL&#x2F;TLS 握手，建立安全连接后才可传输加密数据。<br>HTTP 使用 80 端口，HTTPS 使用 443 端口。<br>HTTP 不需要证书。<br>HTTPS 需要向 CA（Certificate Authority） 申请 SSL 证书，以确保服务器身份可信。</p>
<p>背诵版本<br>两者的主要区别在于安全性和数据加密：<br>HTTP 是明文传输协议，安全性低，而 HTTPS 在 HTTP 基础上增加了 SSL&#x2F;TLS 加密层，确保数据安全。<br>HTTP 直接使用 TCP 三次握手传输数据，而 HTTPS 需额外进行 SSL&#x2F;TLS 握手。<br>端口方面，HTTP 使用 80，HTTPS 使用 443。<br>另外，HTTPS 需要向 CA 申请数字证书，确保服务器身份可信，而 HTTP 无需证书</p>
<h2 id="HTTPS的工作原理-HTTPS建立连接的过程）"><a href="#HTTPS的工作原理-HTTPS建立连接的过程）" class="headerlink" title="HTTPS的工作原理(HTTPS建立连接的过程）"></a>HTTPS的工作原理(HTTPS建立连接的过程）</h2><p>HTTPS 主要基于 SSL&#x2F;TLS，核心目标是：</p>
<p>身份认证（验证服务器是否可信）<br>数据加密（防止被窃听）<br>完整性校验（防止数据被篡改）<br>连接建立过程（握手流程）：</p>
<p>客户端发起请求，服务器发送公钥证书<br>客户端向服务器发起 HTTPS 请求，服务器返回自己的 SSL 证书（包含公钥）。<br>证书验证<br>客户端检查该证书是否由可信的 CA（证书颁发机构） 签发，是否过期。<br>密钥协商<br>如果证书可信，客户端生成一个 随机对称密钥，用服务器的公钥加密后发送给服务器。<br>建立安全连接<br>服务器用 私钥解密，得到对称密钥。此时，客户端和服务器共享相同的对称密钥。<br>加密通信<br>双方使用对称密钥进行数据加密，确保数据传输的机密性。<br>完整性校验<br>SSL&#x2F;TLS 使用 消息认证码（MAC） 校验数据，防止篡改。<br>连接关闭<br>传输结束后，双方销毁会话密钥，避免安全风险。</p>
<p>背诵<br>HTTPS 主要基于SSL&#x2F;TLS 协议，确保了数据传输的安全性和完整性, 其建立连接并传输数据的过程如下：</p>
<p>密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端。<br>证书验证：客户端会验证服务器的证书是否由受信任的证书颁发机构（CA ）签发，并检查证书的有效性。<br>加密通信：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。<br>建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。<br>数据传输：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。<br>完整性校验：SSL&#x2F;TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。<br>结束连接：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。</p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP是面向连接的协议，需要在数据传输前建立连接；UDP是无连接的，不需要建立连接。<br>TCP提供可靠的数据传输，保证数据包的顺序和完整性；UDP不保证数据包的顺序或完整性。<br>TCP具有拥塞控制机制，可以根据网络状况调整数据传输速率；UDP没有拥塞控制，发送速率通常固定。<br>TCP通过滑动窗口机制进行流量控制，避免接收方处理不过来；UDP没有流量控制。<br>TCP能够检测并重传丢失或损坏的数据包；UDP不提供错误恢复机制。<br>TCP有复杂的报文头部，包含序列号、确认号等信息，头部复杂（20 字节+）；UDP的报文头部相对简单。（8 字节）。 端口号、长度、校验和<br>由于TCP的连接建立、数据校验和重传机制，其性能开销通常比UDP大；UDP由于简单，性能开销小。<br>适用场景：TCP适用于需要可靠传输的应用，如网页浏览、文件传输等；UDP适用于对实时性要求高的应用，如语音通话、视频会议等。</p>
<h2 id="TCP连接如何确保可靠性"><a href="#TCP连接如何确保可靠性" class="headerlink" title="TCP连接如何确保可靠性"></a>TCP连接如何确保可靠性</h2><p>TCP 通过以下机制确保数据可靠传输：</p>
<p>序列号（Sequence Number）</p>
<p>每个 TCP 段都有 唯一序列号，确保接收方按序重组数据，防止乱序问题。<br>数据校验（Checksum）</p>
<p>TCP 使用 校验和 检测数据是否损坏，若出错，接收方会丢弃数据包，并等待重传。<br>确认应答（ACK, Acknowledgment）</p>
<p>接收方收到数据后发送 ACK 确认，若发送方未在超时时间内收到 ACK，会重传数据。<br>超时重传（Timeout &amp; Retransmission）</p>
<p>发送方设置 超时定时器，如果超时仍未收到 ACK，则重传数据，确保数据不会丢失。<br>流量控制（Flow Control）</p>
<p>采用 滑动窗口（Sliding Window） 机制，调整发送数据的速率，防止接收方处理不过来。<br>拥塞控制（Congestion Control）</p>
<p>采用 慢启动、拥塞避免、快重传、快恢复 等算法，防止因发送速率过快导致网络拥塞。</p>
<p>背诵版本<br>TCP通过差错控制（序列号、确认应答、数据校验）、超时重传、流量控制、拥塞控制等机制，确保了数据传输的可靠性和效率。</p>
<p>序列号：每个TCP段都有一个序列号，确保数据包的顺序正确。<br>数据校验：TCP使用校验和来检测数据在传输过程中是否出现错误，如果检测到错误，接收方会丢弃该数据包，并等待重传。<br>确认应答：接收方发送ACK确认收到的数据，如果发送方在一定时间内没有收到确认，会重新发送数据。<br>超时重传：发送方设置一个定时器，如果在定时器超时之前没有收到确认，发送方会重传数据。<br>流量控制：TCP通过滑动窗口机制进行流量控制，确保接收方能够处理发送方的数据量。<br>拥塞控制：TCP通过算法如慢启动、拥塞避免、快重传和快恢复等，来控制数据的发送速率，防止网络拥塞。</p>
<h2 id="拥塞控制机制"><a href="#拥塞控制机制" class="headerlink" title="拥塞控制机制"></a>拥塞控制机制</h2><p>TCP 拥塞控制的核心目标是防止网络过载，保证数据高效传输。主要通过 四大机制 动态调整发送速率：</p>
<p>慢启动（Slow Start）</p>
<p>初始阶段，TCP 发送窗口（cwnd） 设为较小值（通常为 1 个 MSS）。<br>每次收到 ACK，cwnd 指数级增长（每次 ACK cwnd 翻倍）。<br>当 cwnd 达到 慢启动阈值（ssthresh） 时，进入拥塞避免阶段。<br>拥塞避免（Congestion Avoidance）</p>
<p>cwnd 线性增长（每个 RTT 只增加 1 个 MSS），避免增长过快导致拥塞。<br>目的：控制流量增长，防止网络过载。<br>快速重传（Fast Retransmit）</p>
<p>当收到 3 个重复 ACK，认为数据包丢失，不等超时，直接重传丢失的数据包。<br>快速恢复（Fast Recovery）</p>
<p>快速重传后，不进入慢启动，而是：<br>ssthresh 设为当前 cwnd 一半，减少发送速率。<br>cwnd 设为 ssthresh + 3（补偿未确认但仍在传输中的数据）。<br>恢复后继续拥塞避免阶段，线性增长。</p>
<p>背诵版本<br>TCP拥塞控制可以在网络出现拥塞时动态地调整数据传输的速率，以防止网络过载。TCP拥塞控制的主要机制包括以下几个方面：</p>
<p>慢启动（Slow Start）： 初始阶段，TCP发送方会以较小的发送窗口开始传输数据。随着每次成功收到确认的数据，发送方逐渐增加发送窗口的大小，实现指数级的增长，这称为慢启动。这有助于在网络刚开始传输时谨慎地逐步增加速率，以避免引发拥塞。<br>拥塞避免（Congestion Avoidance）： 一旦达到一定的阈值（通常是慢启动阈值），TCP发送方就会进入拥塞避免阶段。在拥塞避免阶段，发送方以线性增加的方式增加发送窗口的大小，而不再是指数级的增长。这有助于控制发送速率，以避免引起网络拥塞。<br>快速重传（Fast Retransmit）： 如果发送方连续收到相同的确认，它会认为发生了数据包的丢失，并会快速重传未确认的数据包，而不必等待超时。这有助于更快地恢复由于拥塞引起的数据包丢失。<br>快速恢复（Fast Recovery）： 在发生快速重传后，TCP进入快速恢复阶段。在这个阶段，发送方不会回到慢启动阶段，而是将慢启动阈值设置为当前窗口的一半，并将拥塞窗口大小设置为慢启动阈值加上已确认但未被快速重传的数据块的数量。这有助于更快地从拥塞中恢复。</p>
<h2 id="TCP流量控制是怎么实现的"><a href="#TCP流量控制是怎么实现的" class="headerlink" title="TCP流量控制是怎么实现的"></a>TCP流量控制是怎么实现的</h2><p>滑动窗口的作用<br>滑动窗口（Window Size）决定发送方最多可以发送多少数据，而无需等待 ACK。<br>窗口大小由接收方动态调整，保证不会超出自身的缓冲区容量。<br>📌 滑动窗口的组成<br>接收窗口（Receiver Window，rwnd）</p>
<p>由 接收方 通过 TCP 报文的 窗口字段 指定。<br>表示接收方 当前还可以接收多少字节的数据。<br>发送方必须遵守 rwnd 约束，不能超出接收方缓冲区容量。<br>发送窗口（Sender Window）</p>
<p>发送方维护一个滑动窗口，决定可以发送的数据量。<br>其大小取决于 min(rwnd, cwnd)，其中：<br>rwnd：接收方的接收窗口（流量控制）。<br>cwnd：拥塞窗口（拥塞控制，防止网络拥塞）。<br>3. 流量控制的工作流程<br>✅ 1. 发送方发送数据<br>发送方检查 rwnd（接收方可接收的数据大小）。<br>只发送不超过 rwnd 限制的数据量。<br>✅ 2. 接收方返回 ACK，并更新窗口大小<br>接收方在 ACK 报文中包含新的 rwnd 值，通知发送方当前剩余的接收缓冲区空间。<br>✅ 3. 发送方根据 rwnd 调整发送速率<br>如果 rwnd 增大（缓冲区有空闲），发送方加快发送速率。<br>如果 rwnd 变小（缓冲区接近满），发送方减慢发送速率，甚至暂停发送。<br>4. 流量控制的特殊情况<br>📌 1. 接收窗口变为 0<br>如果 rwnd &#x3D; 0（接收方缓冲区已满），发送方必须暂停发送，直到接收方通知新的窗口大小。<br>TCP 采用“窗口探测（Zero Window Probe）”机制，定期发送小包测试 rwnd 是否恢复。<br>📌 2. 发送方“傻等”问题<br>发送方可能会一直等待 rwnd 变大，但如果接收方一直不更新 rwnd，会导致死锁。<br>解决方案：<br>TCP 发送窗口探测数据包（Zero Window Probe）。<br>接收方定期发送 ACK，更新 rwnd 值。<br>5. 流量控制 vs 拥塞控制<br>机制	目的	受谁控制	依据	影响因素<br>流量控制	防止接收方缓冲区溢出	接收方	rwnd（接收窗口）	接收方处理能力<br>拥塞控制	防止网络拥塞	发送方	cwnd（拥塞窗口）	网络状况</p>
<p>背诵版本<br>流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制，主要方法就是动态调整发送方和接收方之间数据传输速率。<br>滑动窗口大小： 在TCP通信中，每个TCP报文段都包含一个窗口字段，该字段指示发送方可以发送多少字节的数据而不等待确认。这个窗口大小是动态调整的。<br>接收方窗口大小： 接收方通过TCP报文中的窗口字段告诉发送方自己当前的可接收窗口大小。这是接收方缓冲区中还有多少可用空间。<br>流量控制的目标： 流量控制的目标是确保发送方不要发送超过接收方缓冲区容量的数据。如果接收方的缓冲区快满了，它会减小窗口大小，通知发送方暂停发送，以防止溢出。<br>动态调整： 发送方会根据接收方的窗口大小动态调整发送数据的速率。如果接收方的窗口大小增加，发送方可以加速发送数据。如果窗口大小减小，发送方将减缓发送数据的速率。<br>确认机制： 接收方会定期发送确认（ACK）报文，告知发送方已成功接收数据。这也与流量控制密切相关，因为接收方可以通过ACK报文中的窗口字段来通知发送方它的当前窗口大小。</p>
<h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><p>UDP（User Datagram Protocol）是无连接、不可靠的协议，它的优点是资源消耗低、处理速度快，常用于音视频流、在线游戏等对实时性要求高的应用。<br>然而，UDP 本身不提供可靠性保证，如果应用层需要可靠传输，就必须自行实现类似 TCP 的机制。</p>
<ol>
<li>可靠 UDP（Reliable UDP, RUDP） 的关键技术<br>为了在 UDP 上实现可靠传输，应用层通常借鉴 TCP 机制，包括：</li>
</ol>
<p>超时重传（Timeout &amp; Retransmission）：避免数据丢失。<br>确认应答（ACK, Acknowledgment）：确保数据正确接收。<br>序列号（Sequence Number）：确保数据包有序到达，避免丢失或重复。<br>流量控制（Flow Control）：防止发送方过快发送，导致接收方缓冲区溢出。<br>拥塞控制（Congestion Control）（可选）：防止网络过载。<br>2. UDP 可靠传输的实现方式<br>📌 发送方（Sender）<br>在 UDP 数据报中自定义首部，包含：<br>序列号（确保数据包按序接收）。<br>时间戳（用于计算 RTT 和超时时间 RTO）。<br>发送数据报，进入等待状态：<br>采用 “停-等协议（Stop-and-Wait）”，即发送一个数据包后等待 ACK，收到确认后才发送下一个。<br>如果超时仍未收到 ACK，执行重传，同时 RTO（重传超时时间）扩大 2 倍，重新计时（类似 TCP 超时重传机制）。<br>📌 接收方（Receiver）<br>收到 UDP 数据报后，解析首部：<br>提取 序列号，确保数据包按序排列。<br>提取 时间戳，用于测量 RTT 并优化 RTO 计算。<br>发送 ACK 确认：<br>在 ACK 中包含 确认的序列号，告知发送方已经正确收到的数据包。<br>若发现数据包 重复，则丢弃（防止重复接收）。<br>若数据包 乱序，可缓存等待重排序。</p>
<p>背诵版本<br>UDP怎么实现可靠传输<br>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：</p>
<p>（1）提供超时重传，能避免数据报丢失。</p>
<p>（2）提供确认序列号，可以对数据报进行确认和排序。</p>
<p>本端：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。</p>
<p>对端：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，添加自己的 UDP 自定义首部（包括新的时间戳和确认序列号）。<br>发送给发送方，通知“这个数据包已经成功接收”。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p>
<h2 id="tcp为什么需要三次握手"><a href="#tcp为什么需要三次握手" class="headerlink" title="tcp为什么需要三次握手"></a>tcp为什么需要三次握手</h2><p>(1) 三次握手的过程</p>
<p>第一次握手：客户端向服务器发送一个SYN （同步序列编号）报文，请求建立连接，客户端进入SYN_SENT 状态。<br>第二次握手：服务器收到SYN 报文后，如果同意建立连接，则会发送一个SYN-ACK （同步确认）报文作为响应，同时进入SYN_RCVD 状态。<br>第三次握手：客户端收到服务器的SYN-ACK 报文后，会发送一个ACK （确认）报文作为最终响应，之后客户端和服务器都进入ESTABLISHED 状态，连接建立成功。<br>(2)为什么需要三次握手</p>
<p>通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。</p>
<p>而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。而四次握手可以优化为三次。</p>
<h2 id="TCP为什么需要四次挥手"><a href="#TCP为什么需要四次挥手" class="headerlink" title="TCP为什么需要四次挥手"></a>TCP为什么需要四次挥手</h2><p>（1）四次挥手的过程</p>
<p>第一次挥手：客户端发送一个FIN报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号 (seq&#x3D;x)。然后,客户端进入FIN-WAIT-1 状态。<br>第二次挥手：服务端收到FIN报文后，回复ACK报文给客户端，且把客户端的序列号值+1，作为ACK报文的序列号(seq&#x3D;x+1)。然后，服务端进入CLOSE-WAIT(seq&#x3D;x+1)状态，客户端进入FIN-WAIT-2状态。<br>第三次挥手：服务端也要断开连接时，发送FIN报文给客户端，且指定一个序列号(seq&#x3D;y+1)，随后服务端进入LAST-ACK状态。<br>第四次挥手：客户端收到FIN报文后，发出ACK报文进行应答，并把服务端的序列号值+1作为ACK报文序列号(seq&#x3D;y+2)。此时客户端进入TIME-WAIT状态。服务端在收到客户端的ACK 报文后进入CLOSE 状态。如果客户端等待2MSL没有收到回复，才关闭连接。<br>（2）为什么需要四次挥手</p>
<p>TCP 是全双工通信协议，允许数据在两个方向上传输。因此，任何一方在数据传输完成后，都可以主动发起连接释放请求。当对方确认该请求后，连接进入半关闭状态，即一方不再发送数据，但仍可接收来自对方的数据。只有当另一方也发送连接释放请求，并得到确认后，TCP 连接才会完全关闭。因此，完整的连接释放过程需要四次挥手。</p>
<p>四次挥手的必要性在于确保双方都能正确接收对方的最后一个数据包，并进行确认。具体来说：</p>
<p>主动关闭方 先发送 FIN（终止连接请求）报文，表示不再发送数据，但仍可接收数据。<br>被动关闭方 收到 FIN 后，发送 ACK 确认，但此时连接仍然保持开放，可能还有未发送完的数据。<br>被动关闭方 在数据传输完成后，再发送 FIN，通知主动关闭方可以完全断开连接。<br>主动关闭方 发送 ACK 确认后，进入 TIME-WAIT 状态，等待一段时间，以确保被动关闭方成功接收到 ACK，然后才真正释放连接。<br>如果省略第四次挥手（即仅用三次挥手关闭连接），可能会导致被动关闭方在发送最后一个数据包后立即关闭连接，而主动关闭方还未接收到该数据包的确认，从而造成数据丢失或连接异常。因此，四次挥手是为了确保双方数据传输的完整性和可靠性。</p>
<h2 id="HTTP-的-Keep-Alive-是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？、"><a href="#HTTP-的-Keep-Alive-是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？、" class="headerlink" title="HTTP 的 Keep-Alive 是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？、"></a>HTTP 的 Keep-Alive 是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？、</h2><ol>
<li>HTTP 的 Keep-Alive（HTTP 长连接）<br>HTTP 的 Keep-Alive 是应用层实现的长连接机制，用于减少频繁建立和释放 TCP 连接的开销。</li>
</ol>
<p>通常，HTTP 请求的基本流程如下：</p>
<p>建立 TCP 连接<br>发送 HTTP 请求<br>服务器响应请求<br>释放 TCP 连接<br>这种方式称为 HTTP 短连接，每次请求都需要重新建立 TCP 连接。而 HTTP Keep-Alive 允许在同一个 TCP 连接上复用多个 HTTP 请求和响应，从而避免重复建立连接带来的开销，提高性能。这种方式称为 HTTP 长连接，可以通过 HTTP 头部 Connection: keep-alive 来启用。</p>
<ol start="2">
<li>TCP 的 Keepalive（TCP 保活机制）<br>TCP 的 Keepalive 是 TCP 层（内核态） 提供的一种连接存活检测机制，用于判断 TCP 连接是否仍然有效。</li>
</ol>
<p>当 TCP 连接长时间没有数据传输时，TCP Keepalive 机制会周期性发送探测包给对方：</p>
<p>如果对方响应，则说明连接仍然有效；<br>如果对方未响应多次，TCP 可能会认为连接已断开，并终止该连接。<br>TCP Keepalive 适用于多种协议，不仅限于 HTTP，还包括 FTP、SMTP 等网络协议。它的作用类似于垃圾回收机制（GC），用于清理长期不活动但未正式关闭的连接。</p>
<p>3.3. HTTP Keep-Alive 与 TCP Keepalive 的关系<br>虽然 HTTP Keep-Alive 和 TCP Keepalive 听起来相似，但它们是完全不同的机制：</p>
<p>HTTP Keep-Alive：由应用层（HTTP 协议）控制，主要用于在同一 TCP 连接上复用多个 HTTP 请求，减少 TCP 连接的建立与释放。<br>TCP Keepalive：由 TCP 层（传输层）实现，主要用于检测连接是否仍然存活，避免死连接长时间占用资源。<br>两者的配合场景：如果 HTTP 连接开启了 Keep-Alive，但一段时间没有数据传输，而没有显式关闭连接，此时 TCP Keepalive 可能会起作用，检测连接状态并在必要时关闭连接，防止无效连接占用资源。</p>
<h2 id="什么是死锁-如何避免死锁"><a href="#什么是死锁-如何避免死锁" class="headerlink" title="什么是死锁 如何避免死锁"></a>什么是死锁 如何避免死锁</h2><p>🔹 方法 1：破坏“循环等待”条件（常见做法）<br>让进程按照固定的顺序请求资源，避免环形等待。</p>
<p>例如：规定所有进程必须先申请 R1，再申请 R2，这样不会形成环路。<br>🔹 方法 2：破坏“请求保持”条件<br>强制进程一次性申请所有资源，如果无法全部分配，则必须先释放已有资源，等所有资源可用时再重新申请。</p>
<p>优点：避免了进程在等待额外资源时持有部分资源。<br>缺点：可能会降低资源利用率。<br>🔹 方法 3：破坏“不可剥夺”条件<br>允许操作系统强行回收资源，将资源从某个进程转移给另一个进程，以解除死锁。</p>
<p>例如：当发现死锁时，系统可以暂停某些进程，并强制回收它们占用的资源。<br>🔹 方法 4：死锁检测 + 解除死锁<br>检测死锁：<br>通过 资源分配图（Resource Allocation Graph, RAG） 或 银行家算法（Banker’s Algorithm） 来判断系统是否进入死锁状态。<br>解除死锁：<br>抢占资源（从某些进程中回收资源）。<br>终止进程（强制结束部分进程，以释放资源）。<br>回滚进程（将进程恢复到安全状态）。</p>
<p>背诵版本：<br>死锁是系统中两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一定的资源并等待其他进程释放它们所需的资源时，如果这些资源都被其他进程占有且不释放，就导致了死锁。</p>
<p>死锁只有同时满足以下四个条件才会发生：</p>
<p>互斥条件：一个进程占用了某个资源时，其他进程无法同时占用该资源。<br>请求保持条件：一个进程因为请求资源而阻塞的时候，不会释放自己的资源。<br>不可剥夺条件：资源不能被强制性地从一个进程中剥夺，只能由持有者自愿释放。<br>循环等待条件：多个进程之间形成一个循环等待资源的链，每个进程都在等待下一个进程所占有的资源。<br>避免死锁：<br>通过破坏死锁的四个必要条件之一来预防死锁。比如破坏循环等待条件，让所有进程按照相同的顺序请求资源。<br>检测死锁：通过检测系统中的资源分配情况来判断是否存在死锁。例如，可以使用资源分配图或银行家算法进行检测。<br>解除死锁：一旦检测到死锁存在，可以采取一些措施来解除死锁。例如，可以通过抢占资源、终止某些进程或进行资源回收等方式来解除死锁。</p>
<h2 id="解释典型的锁"><a href="#解释典型的锁" class="headerlink" title="解释典型的锁"></a>解释典型的锁</h2><p>互斥锁：互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。<br>自旋锁：自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。<br>其他的锁都是基于这两个锁的</p>
<p>读写锁：允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读（共享）和写（排他）两种状态。<br>悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁<br>乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。</p>
<h2 id="讲一讲理解的虚拟内存"><a href="#讲一讲理解的虚拟内存" class="headerlink" title="讲一讲理解的虚拟内存"></a>讲一讲理解的虚拟内存</h2><p>虚拟内存是指在每一个进程创建加载的过程中，会分配一个连续虚拟地址空间，它不是真实存在的，而是通过映射与实际物理地址空间对应，这样就可以使每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存RAM更大的地址空间, 每个程序都可以认为它拥有足够的内存来运行。</p>
<p>需要虚拟内存的原因：</p>
<p>内存扩展： 虚拟内存使得每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据。<br>内存隔离：虚拟内存还提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。<br>物理内存管理：虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。<br>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。<br>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p>
<h2 id="进程调度算法理解多少"><a href="#进程调度算法理解多少" class="headerlink" title="进程调度算法理解多少"></a>进程调度算法理解多少</h2><p>先来先服务：按照请求的顺序进行调度。 这种调度方式简单，但是能导致较长作业阻塞较短作业。<br>最短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 但是如果一直有短作业到来，那么长作业永远得不到调度，造成长作业“饥饿”现象。<br>最短剩余时间优先：基于最短作业优先改进，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。<br>优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br>时间片轮转：为每个进程分配一个时间片，进程轮流执行，时间片用完后切换到下一个进程。<br>多级队列：时间片轮转调度算法和优先级调度算法的结合。 将进程分为不同的优先级队列，每个队列有自己的调度算法。</p>
<h2 id="进程间有哪些通信方式"><a href="#进程间有哪些通信方式" class="headerlink" title="进程间有哪些通信方式"></a>进程间有哪些通信方式</h2><p>管道：是一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。<br>命名管道： 类似管道，也是半双工的通信方式，但是它允许在不相关的进程间通信。<br>消息队列：允许进程发送和接收消息，而消息队列是消息的链表，可以设置消息优先级。<br>信号：用于发送通知到进程，告知其发生了某种事件或条件。<br>信号量：是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同一进程内不同线程之间的同步手段。<br>共享内存：就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程通信方式，<br>Socket套接字：是支持TCP&#x2F;IP 的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。</p>
<h2 id="解释一下进程同步和互斥，以及如何实现进程同步和互斥"><a href="#解释一下进程同步和互斥，以及如何实现进程同步和互斥" class="headerlink" title="解释一下进程同步和互斥，以及如何实现进程同步和互斥"></a>解释一下进程同步和互斥，以及如何实现进程同步和互斥</h2><p>进程同步 是指多个并发执行的进程之间通过一定的协调机制，保证它们按照特定顺序或规则执行，以避免由于竞争共享资源引发的冲突或不一致性。</p>
<p>互斥 是一种特殊的同步方式，强调在同一时刻只能有一个进程访问某个共享资源，确保对资源的访问具有排他性。</p>
<p>常见的实现方法包括：<br>信号量与PV操作：<br>信号量 是一种表示资源数量或状态的特殊整型变量，用于协调进程间的同步与互斥。信号量的基本操作称为 PV操作。</p>
<p>P操作（等待操作）： 尝试减少信号量的值，如果值大于0，则减1并继续执行；若为0，则进程被阻塞，直到信号量变为正数。</p>
<p>V操作（释放操作）： 增加信号量的值，若有其他进程在等待这个信号量，就唤醒其中一个等待的进程。</p>
<p>互斥 是一种特殊的同步情形，目的是确保在同一时间只有一个进程能够访问共享资源，从而避免竞态条件。实现互斥的典型机制包括：<br>临界区：<br>临界区是一段访问共享资源的代码片段。<br>每次仅允许一个进程进入临界区，通过 锁机制 来实现互斥访问。<br>进入临界区之前必须先获取锁，执行完临界区的代码后再释放锁。</p>
<p>常见的进程同步与互斥实现方法：<br>互斥锁（Mutex）<br>通常用于保护临界区，确保资源同一时刻只被一个进程占用。<br>进程进入临界区前先加锁，退出时释放锁。<br>进程间的Mutex通常借助共享内存实现。<br>信号量（Semaphore）<br>既能用于同步，也能用于互斥。是更一般的同步机制。<br>互斥：信号量初始值设置为1，实现互斥（如二值信号量）。<br>同步：初始值设置为0，用于进程等待某事件或条件满足。<br>条件变量（Condition Variable）<br>条件变量用于在进程之间传递信号，使进程能够在特定条件下等待或被唤醒。<br>一般结合互斥锁使用，确保等待与唤醒操作在合适时机发生。<br>信号（Signal）<br>进程间可以通过发送和捕获信号实现简单同步或通知（例如SIGUSR1、SIGUSR2）。<br>信号是一种异步通知机制，不适合复杂的同步场景</p>
<h2 id="你知道线程同步方式有哪些"><a href="#你知道线程同步方式有哪些" class="headerlink" title="你知道线程同步方式有哪些"></a>你知道线程同步方式有哪些</h2><p>线程同步 指的是多个线程之间协调执行顺序或访问共享资源，以保证程序的正确性，避免数据竞争和不一致的问题。<br>线程互斥 是线程同步的特例，指在同一时刻只允许一个线程访问某个共享资源或临界区。</p>
<p>常见的线程同步与互斥实现方式包括：<br>互斥锁（Mutex）<br>最基础的线程同步机制，确保某个共享资源在同一时间仅被一个线程访问。<br>条件变量（Condition Variable）<br>允许线程等待某个特定条件满足时再继续执行，通常与互斥锁一起使用。<br>读写锁（Read-Write Lock）<br>当共享资源读操作远多于写操作时更为高效。<br>允许多个线程同时读，但在写操作时只能有一个线程独占资源。<br>信号量（Semaphore）<br>常用于线程同步与互斥的通用机制，尤其适合生产者-消费者等场景。</p>
<h2 id="有哪些页面置换算法"><a href="#有哪些页面置换算法" class="headerlink" title="有哪些页面置换算法"></a>有哪些页面置换算法</h2><p>最近最久未使用算法LRU ：LRU算法基于页面的使用历史，通过选择最长时间未被使用的页面进行置换。<br>先进先出FIFO算法：也就是最先进入内存的页面最先被置换出去。<br>最不经常使用LFU ：淘汰访问次数最少的页面，考虑页面的访问频率。<br>时钟算法CLOCK：Clock算法的核心思想是通过使用一个指针(称为时钟指针)在环形链表上遍历，检查页面是否被访问过, 当需要进行页面置换时，Clock算法从时钟指针的位置开始遍历环形链表。 如果当前页面的访问位为0，表示该页面最久未被访问，可以选择进行置换。将访问位设置为1，继续遍历下一个页面。 如果当前页面的访问位为1，表示该页面最近被访问过，它仍然处于活跃状态。将访问位设置为0，并继续遍历下一个页面如果遍历过程中找到一个访问位为0的页面，那么选择该页面进行置换。<br>最佳置换算法: 该算法根据未来的页面访问情况，选择最长时间内不会被访问到的页面进行置换。那么就有一个问题了，未来要访问什么页面，操作系统怎么知道的呢?操作系统当然不会知道，所以这种算法只是一种理想情况下的置换算法，通常是无法实现的。</p>
<h2 id="LINUX常用命令有哪些"><a href="#LINUX常用命令有哪些" class="headerlink" title="LINUX常用命令有哪些"></a>LINUX常用命令有哪些</h2><ol>
<li><p>文件和目录操作<br>ls：列出目录内容。<br>常用：ls -l 详细信息，ls -a 显示隐藏文件。<br>cd：改变当前目录。<br>pwd：显示当前工作目录。<br>cp：复制文件或目录。<br>常用：cp -r 递归复制目录。<br>mv：移动或重命名文件。<br>rm：删除文件或目录。<br>常用：rm -r 删除目录及内容，rm -f 强制删除。<br>touch：创建空文件或更新文件时间戳。</p>
</li>
<li><p>文件内容查看<br>cat：查看文件内容。<br>head：查看文件前几行（默认前10行）。<br>常用：head -n 5 显示前5行。<br>tail：查看文件后几行（默认后10行），常用于查看日志文件。<br>常用：tail -f 动态监控日志变化。</p>
</li>
<li><p>文件编辑<br>vi&#x2F;vim：强大的文本编辑器，支持命令模式和插入模式。</p>
</li>
<li><p>权限管理<br>chmod：更改文件或目录的访问权限。<br>常用：chmod 755 file.sh 为文件赋予执行权限。<br>chown：更改文件或目录的所有者和所属组。<br>常用：chown user:group file</p>
</li>
<li><p>磁盘管理<br>df：查看磁盘空间使用情况。<br>常用：df -h 以人类可读的方式显示（MB&#x2F;GB）。</p>
</li>
<li><p>网络管理<br>ifconfig 或 ip addr：查看和配置网络接口。<br>ping：测试网络连通性。<br>常用：ping -c 4 ip地址 发送4个数据包。<br>netstat：查看网络连接和端口状态。<br>常用：netstat -anp 显示详细网络状态。<br>ssh：安全远程登录到主机。<br>常用：ssh user@host</p>
</li>
<li><p>进程管理<br>ps：查看当前运行的进程。<br>常用：ps aux 查看所有进程详细信息。<br>kill：终止进程或发送信号。<br>常用：kill -9 PID 强制终止进程。</p>
</li>
<li><p>软件包管理（依发行版而定）<br>apt-get（Debian&#x2F;Ubuntu）：<br>apt-get update 更新软件包索引。<br>apt-get install package_name 安装软件包。<br>apt-get remove package_name 删除软件包。</p>
</li>
</ol>
<h2 id="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"><a href="#Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用" class="headerlink" title="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"></a>Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用</h2><p>查看进程： 用 ps 命令查看当前运行的进程，比如 ps aux 可以列出所有进程及其详细信息。<br>杀死进程： 首先用 ps 或 top 命令找到进程的PID（进程ID）。 然后用 kill 命令加上进程ID来结束进程，例如 kill -9 PID。”-9” 是强制杀死进程的信号。<br>查看端口占用： 使用 lsof -i:端口号 可以查看占用特定端口的进程。 或者用 netstat -tulnp | grep 端口号，这会显示监听在该端口的服务及其进程ID。<br>-t：显示TCP连接的信息。<br>-u：显示UDP连接的信息。<br>-l：仅显示处于监听（Listening）状态的端口。<br>-n：以数字形式显示地址和端口（不解析为主机名和服务名）。<br>-p：显示使用该端口的进程PID和名称。</p>
<p>list open files（列出打开的文件）。</p>
<h2 id="说一下-select、poll、epoll"><a href="#说一下-select、poll、epoll" class="headerlink" title="说一下 select、poll、epoll"></a>说一下 select、poll、epoll</h2><p>I&#x2F;O多路复用是一种允许应用程序同时监视多个文件描述符（例如：网络套接字）的技术。程序通过单个线程或进程就可以同时等待多个I&#x2F;O事件（如数据可读、可写等），以提高并发性能。</p>
<p>Linux系统中提供的I&#x2F;O多路复用机制主要有：<br>select<br>poll<br>epoll</p>
<p>Linux 提供三种 I&#x2F;O 多路复用技术：</p>
<p>select： select是一个最古老的I&#x2F;O多路复用机制，它可以监视多个文件描述符的可读、可写和错误状态。然而，但是它的效率可能随着监视的文件描述符数量的增加而降低。有上限一般1024个<br>poll： poll是select的一种改进，它使用轮询方式来检查多个文件描述符的状态，避免了select中文件描述符数量有限的问题。但对于大量的文件描述符，poll的性能也可能变得不足够高效。<br>epoll： epoll是Linux特有的I&#x2F;O多路复用机制，相较于select和poll，它在处理大量文件描述符时更加高效。epoll使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不需要应用程序轮询。</p>
<h2 id="一条SQL查询语句是如何执行的"><a href="#一条SQL查询语句是如何执行的" class="headerlink" title="一条SQL查询语句是如何执行的"></a>一条SQL查询语句是如何执行的</h2><p>连接器:连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>查询缓存: MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value 对的形式，被直接缓存在内存中。<br>分析器:你输入的是由多个字符串和空格组成的一条SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。<br>优化器:优化器是在表里面有多个索引的时候，决定使用哪个索引; 或者在一个语句有多表关联(join )的时候，决定各个表的连接顺序。<br>执行器: MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<h2 id="事务的四大特性有哪些"><a href="#事务的四大特性有哪些" class="headerlink" title="事务的四大特性有哪些"></a>事务的四大特性有哪些</h2><p>原子性（A）	事务不可分割，成功 or 失败	失败则回滚，避免数据残留<br>一致性（C）	事务前后一致，数据完整	保证数据遵循约束，不会破坏完整性<br>隔离性（I）	并发事务互不干扰	通过不同隔离级别控制<br>持久性（D）	事务提交后永久生效	依赖数据库日志机制</p>
<p>事务的四大特性通常被称为 ACID 特性<br>原子性：确保事务的所有操作要么全部执行成功，要么全部失败回滚，不存在部分成功的情况。<br>一致性：事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。<br>隔离性：多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响其他事务的执行。<br>持久性：一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持。</p>
<h2 id="数据库的事务隔离级别有哪些"><a href="#数据库的事务隔离级别有哪些" class="headerlink" title="数据库的事务隔离级别有哪些"></a>数据库的事务隔离级别有哪些</h2><p>数据库事务的隔离性（Isolation）用于控制多个事务并发执行时的互相影响，防止数据不一致问题。SQL 标准定义了 4 种事务隔离级别，分别是 读未提交、读已提交、可重复读、序列化。</p>
<p>数据库的事务隔离级别有哪些？<br>读未提交（Read Uncommitted）：<br>允许一个事务读取另一个事务尚未提交的数据修改。<br>最低的隔离级别，存在脏读、不可重复读和幻读的问题。<br>读已提交（Read Committed）：<br>一个事务只能读取已经提交的数据。其他事务的修改在该事务提交之后才可见。<br>解决了脏读问题，但仍可能出现不可重复读和幻读。<br>可重复读（Repeatable Read）：<br>事务执行期间，多次读取同一数据会得到相同的结果，即在事务开始和结束之间，其他事务对数据的修改不可见。<br>解决了不可重复读问题，但仍可能出现幻读。<br>序列化（Serializable）：<br>最高的隔离级别，确保事务之间的并发执行效果与串行执行的效果相同，即不会出现脏读、不可重复读和幻读。</p>
<h2 id="zynq的启动流程"><a href="#zynq的启动流程" class="headerlink" title="zynq的启动流程"></a>zynq的启动流程</h2><p>Zynq 的启动方式主要有 JTAG、QSPI Flash、SD 卡启动，我们通常采用 SD 卡启动：<br>上电后，FSBL 运行，加载 FPGA Bitstream（配置 AD9361 采集数据）。<br>然后启动 ARM 端的应用程序，通过 AXI-DMA 从 FPGA 读取 AD9361 采集的信号。<br>ARM 端进一步处理数据（如滤波、解调），然后传输到上层系统。</p>
<h2 id="MYSQL使用哪些存储引擎"><a href="#MYSQL使用哪些存储引擎" class="headerlink" title="MYSQL使用哪些存储引擎"></a>MYSQL使用哪些存储引擎</h2><p>MySQL的执行引擎主要负责查询的执行和数据的存储, 其执行引擎主要有MyISAM、InnoDB、Memory 等。<br>InnoDB引擎提供了对事务ACID的支持，还提供了行级锁和外键的约束，是目前MySQL的默认存储引擎，适用于需要事务和高并发的应用。<br>MyISAM引擎是早期的默认存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景。<br>Memery就是将数据放在内存中，访问速度快，但数据在数据库服务器重启后会丢失。</p>
<h2 id="MYSQL为什么选择使用B-树作为索引"><a href="#MYSQL为什么选择使用B-树作为索引" class="headerlink" title="MYSQL为什么选择使用B+树作为索引"></a>MYSQL为什么选择使用B+树作为索引</h2><p>MySQL 主要使用 B+ 树 作为索引结构，是因为 B+ 树在 查询效率、插入删除效率以及范围查询 等方面更适合数据库场景。B+ 树是 B 树的一种变种，结构上做了一些优化：</p>
<ol>
<li>查询性能更稳定、磁盘访问更少<br>B 树的节点既存储索引也存储数据记录，有时可以在中间节点就查到结果，但也可能需要访问叶子节点，查询路径不稳定。<br>B+ 树的所有数据都存储在叶子节点，非叶子节点只存索引。这样每次查询都走到叶子节点，虽然从时间复杂度看仍是 虽然 B 树和 B+ 树的查询时间复杂度都是 O(log n)，但 B+ 树每次查找都必须走到叶子节点，路径更稳定、访问次数更可控。<br>更关键的是，B+ 树的非叶子节点只存储索引，不存储实际数据，所以每个节点可以容纳更多的关键字，同样的数据量下，B+ 树的层级更少，结构更“矮胖”，这能显著减少磁盘 I&#x2F;O 次数，从而提升查询性能。</li>
</ol>
<p>。<br>2. 插入与删除更高效，结构更稳定<br>B+ 树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。B 树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。<br>3. 范围索引更高效<br>B+ 树所有叶子节点间有一个链表进行连接，而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB。</p>
<h2 id="说一下索引失效的场景？"><a href="#说一下索引失效的场景？" class="headerlink" title="说一下索引失效的场景？"></a>说一下索引失效的场景？</h2><p>索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致性能下降，下面一些场景会发生索引失效。</p>
<p>使用OR条件：当使用OR连接多个条件，并且每个条件用到不同的索引列时，索引可能不会被使用。<br>使用非等值查询：当使用!&#x3D;或&lt;&gt;操作符时，索引可能不会被使用，特别是当非等值条件在WHERE子句的开始部分时。<br>对列进行类型转换： 如果在查询中对列进行类型转换，例如将字符列转换为数字或日期，索引可能会失效。<br>查询时发生隐式类型转换，等价于函数操作，索引失效。<br>使用LIKE语句：以通配符%开头的LIKE查询会导致索引失效。<br>函数或表达式：在列上使用函数或表达式作为查询条件，通常会导致索引失效。<br>表连接中的列类型不匹配： 如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。</p>
<p>索引失效的本质原因大多是：破坏了字段的“原始顺序或原始值”，从而使 MySQL 无法利用 B+ 树的区间定位能力。避免函数、类型转换、不连续匹配、模糊起始等操作，是保障索引生效的关键。</p>
<h2 id="什么是慢查询？原因是什么？可以怎么优化？"><a href="#什么是慢查询？原因是什么？可以怎么优化？" class="headerlink" title="什么是慢查询？原因是什么？可以怎么优化？"></a>什么是慢查询？原因是什么？可以怎么优化？</h2><p>慢查询指的是：在 MySQL 中执行时间超过设定阈值的 SQL 语句。<br>默认情况下，执行时间超过 long_query_time（如 1 秒） 的语句就会被记录到 慢查询日志（slow query log） 中，用于性能分析和优化。<br>二、慢查询的常见原因<br>查询语句复杂<br>包含多个表连接、嵌套子查询、大量计算逻辑等，执行计划复杂，耗时增加。<br>数据量过大<br>即使语句简单，扫描或处理的数据过多，也会导致查询慢。<br>缺少索引<br>没有合适的索引，MySQL 只能进行全表扫描，查询效率下降。<br>数据库设计不合理<br>表设计冗余、缺少范式、字段类型选择不当，都会影响查询效率。<br>并发冲突<br>多个查询争抢同一资源（如锁、IO），导致等待或阻塞。<br>硬件瓶颈<br>如磁盘 IO 慢、内存不足、CPU 占用高，也会造成查询响应变慢。</p>
<p>优化<br>使用慢查询日志找出慢 SQL<br>启用 slow_query_log，定位执行时间长的 SQL，结合执行计划分析。<br>使用 EXPLAIN 分析执行计划<br>查看是否命中索引、扫描行数、使用了临时表或排序等，指导优化方向。<br>优化 SQL 语句结构<br>减少子查询、避免 SELECT *、使用合适的 JOIN 顺序和 LIMIT 分页方式。<br>建立合适的索引<br>优先为查询频率高、区分度高的字段建立索引，合理利用联合索引和覆盖索引。<br>优化 ORDER BY + LIMIT<br>避免对大数据集排序后再分页，尽量通过索引排序或子查询裁剪数据量。<br>避免函数操作导致索引失效<br>比如不要写 WHERE DATE(create_time) &#x3D; …，改用范围查询方式。<br>合理设计表结构<br>分表分区、字段规范、范式设计，减小每条记录的数据体积。</p>
<h2 id="：undo-log、redo-log、binlog-有什么作用？"><a href="#：undo-log、redo-log、binlog-有什么作用？" class="headerlink" title="：undo log、redo log、binlog 有什么作用？"></a>：undo log、redo log、binlog 有什么作用？</h2><p>在 MySQL 的事务管理中，undo log、redo log 和 binlog 是三种关键的日志机制，它们作用不同，分别服务于事务的原子性、持久性和可恢复性。<br>🔹 1. Undo Log（回滚日志）<br>由 InnoDB 存储引擎生成；<br>作用是：在事务回滚时撤销已经执行的操作，保证事务的原子性（A）；<br>也用于 MVCC（多版本并发控制），帮助实现读已提交 &#x2F; 可重复读等隔离级别。<br>🔹 2. Redo Log（重做日志）<br>也是 InnoDB 层的日志，属于物理日志；<br>作用是：记录了数据页的物理修改操作，即“将什么页改成了什么内容”；<br>保证了事务的持久性（D），即使崩溃后，也可以通过 redo log 重做已提交事务的修改；<br>采用 WAL（Write Ahead Logging）预写日志机制：先写日志，再改数据页。<br>🔹 3. Binlog（归档日志 &#x2F; 二进制日志）<br>是由 MySQL Server 层生成的逻辑日志；<br>作用有两个：<br>主从复制：从库通过 binlog 同步主库数据；<br>增量备份和恢复：结合全量备份 + binlog，可以恢复数据到某个时间点；<br>binlog 是追加写入、不可修改的.</p>
<h2 id="MySQL-和-Redis-的区别是什么？"><a href="#MySQL-和-Redis-的区别是什么？" class="headerlink" title="MySQL 和 Redis 的区别是什么？"></a>MySQL 和 Redis 的区别是什么？</h2><ol>
<li>数据存储方式：<br>Redis：基于键值对，支持多种数据结构（如字符串、哈希、列表、集合、有序集合等），存储在内存中。<br>MySQL：关系型数据库，使用表来组织数据，存储在磁盘中。<br>🔹 2. 数据持久化：<br>Redis：主要存储数据在内存中，支持持久化机制（如 RDB 快照和 AOF 日志）将数据写入磁盘。<br>MySQL：数据持久化存储在磁盘中。<br>🔹 3. 查询语言：<br>Redis：使用自定义命令集，不支持 SQL 查询。<br>MySQL：使用标准的<strong>SQL（结构化查询语言）</strong>进行数据操作。<br>🔹 4. 性能和应用场景：<br>Redis：专注于高性能和低延迟，适用于高速、高并发的读写，特别是缓存系统、会话存储等场景。<br>MySQL：适用于复杂查询、事务处理和需要大规模数据存储的场景，尤其是在涉及关系数据和数据一致性时。<br>🔹 5. 使用场景：<br>Redis：适合缓存系统、实时数据处理、排行榜、消息队列等。<br>MySQL：适合需要复杂查询、多表关联、事务支持的应用，如电商系统、社交网络等。<br>🔹 6. 结合使用：<br>在实际应用中，许多系统同时使用 MySQL 和 Redis，Redis 用作缓存，加速读写性能，MySQL 用作持久化存储和处理复杂查询。</li>
</ol>
<h2 id="Redis-有什么优缺点？为什么-Redis-查询会比较快？"><a href="#Redis-有什么优缺点？为什么-Redis-查询会比较快？" class="headerlink" title="Redis 有什么优缺点？为什么 Redis 查询会比较快？"></a>Redis 有什么优缺点？为什么 Redis 查询会比较快？</h2><p>优点：<br>基于内存：读写速度非常快，适用于需要高性能的场景，如 缓存、消息队列、分布式锁 和 键值存储。<br>丰富的数据结构：支持字符串、哈希、列表、集合、有序集合等多种数据类型，方便处理不同的应用场景。<br>分布式特性：可以将数据分布在多个节点上，提高 可扩展性 和 可用性，并支持主从复制、哨兵和集群模式。<br>缺点：<br>受限于物理内存：由于数据存储在内存中，存储空间受到物理内存的限制，存储超大数据时不适合。<br>高内存成本：相比磁盘存储，内存成本较高，因此存储大量数据时需要付出较高的成本。</p>
<p>2 基于内存操作：Redis 数据完全存储在内存中，减少了磁盘 I&#x2F;O 操作，大幅提升了查询速度。<br>高效的数据结构：Redis 使用 专门设计的数据结构（如字符串、哈希、列表、集合等）优化了读写操作，提升了查询效率。<br>单线程模型：Redis 采用单线程处理请求，省去了上下文切换的开销，避免了多线程带来的资源竞争和死锁问题。<br>I&#x2F;O 多路复用：Redis 使用 I&#x2F;O 多路复用机制，可以同时监听多个请求，根据事件处理不同的客户端请求，减少了阻塞操作，提高了并发性能。</p>
<h2 id="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"><a href="#介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？" class="headerlink" title="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"></a>介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？</h2><p>缓存雪崩是指在某个时间点，大量缓存同时失效，导致请求直接访问数据库或其他后端系统，增加了系统负载。<br>对于缓存雪崩，可以通过合理设置缓存的过期时间，分散缓存失效时间点，或者采用永不过期的策略，再结合定期更新缓存。</p>
<p>缓存击穿是指一个缓存中不存在但是数据库中存在的数据，当有大量并发请求查询这个缓存不存在的数据时，导致请求直接访问数据库，增加数据库的负载。典型的场景是当一个缓存中的数据过期或被清理，而此时有大量请求访问这个缓存中不存在的数据，导致大量请求直接访问底层存储系统。<br>对于缓存击穿，可以采用<strong>互斥锁（例如分布式锁）</strong>或者在查询数据库前先检查缓存是否存在，如果不存在再允许查询数据库，并将查询结果写入缓存。</p>
<p>缓存穿透是指查询一个在缓存和数据库都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。典型的情况是攻击者可能通过构造不存在的 key 大量访问缓存，导致对数据库的频繁查询。<br>对于缓存穿透，可以采用布隆过滤器等手段来过滤掉恶意请求，或者在查询数据库前先进行参数的合法性校验。</p>
<h2 id="如何保证数据库和缓存的一致性"><a href="#如何保证数据库和缓存的一致性" class="headerlink" title="如何保证数据库和缓存的一致性"></a>如何保证数据库和缓存的一致性</h2><ol>
<li>Cache Aside（旁路缓存）<br>这是最常见的策略：<br>读操作：先查缓存，查不到再查数据库，然后回写到缓存；<br>写操作：先更新数据库，再删除缓存。<br>这样可以保证下次读取时缓存是最新的。<br>✅ 问题点： 如果并发出现一个写操作和一个读操作，可能出现：先更新数据库、还没删缓存，读操作查到旧值，之后才删缓存，这就会产生短时间的不一致。<br>✅ 解决方向：<br>加写操作锁；<br>异步延迟双删；<br>设置短期过期；<br>或者引入队列串行写。</li>
<li>Read&#x2F;Write Through（读&#x2F;写直通）<br>应用程序不直接操作数据库，而是通过缓存服务代理；<br>读操作如果缓存中没有，由缓存组件自动加载数据库并更新缓存（Read Through）；<br>写操作先更新缓存，再由缓存同步更新数据库（Write Through）。<br>✅ 特点：一致性比 Cache Aside 更强，操作对应用来说是透明的。</li>
<li>Write Behind（异步写）<br>写操作只更新缓存，不立即更新数据库；<br>缓存会异步、批量地把数据刷新到数据库。<br>✅ 优点：写操作性能非常高；<br>⚠️ 缺点：一致性较差，可能会造成数据丢失，比如系统异常崩溃还没来得及刷盘。<br>✅ 总结：<br>Cache Aside 是最常用的，适合对一致性要求没那么高的场景；<br>Read&#x2F;Write Through 一致性更强但实现复杂；<br>Write Behind 性能高但一致性最弱。<br>实际项目中，通常用 Cache Aside + 延迟双删&#x2F;分布式锁等手段 来平衡一致性与性能。</li>
</ol>
<p>✅ 金句总结版（便于快速记忆）<br>Cache Aside：查不到再查库，写完删缓存；<br>Read&#x2F;Write Through：缓存当代理，自动同步库；<br>Write Behind：先写缓存，再异步刷库，一致性差但性能高。</p>
<h2 id="静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量"><a href="#静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量" class="headerlink" title="静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量"></a>静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量</h2><p>静态变量、全局变量和局部变量的主要区别可以从三个方面来看：作用域、生命周期和内存分布。<br>局部变量的作用域只在函数或代码块内部，生命周期是随着函数的调用创建并结束后销毁，它们一般存储在栈区；<br>全局变量在整个程序中都可见，生命周期从程序启动一直到结束，存储在静态存储区；<br>静态变量和全局变量一样，生命周期是整个程序期间，但它的作用域可以是局部的（比如函数内部的静态变量），这种变量同样存储在静态区，但是只初始化一次，后续函数调用会记住它的值。<br>使用场景方面：<br>局部变量适合存储临时数据，比如循环计数器、计算结果等；<br>静态变量适合函数中需要保留上一次调用状态的场景，比如缓存某个值；<br>全局变量适合多个函数之间共享信息，但要注意封装性和可维护性。<br>总的来说，静态变量像是局部变量和全局变量的结合体：作用域是局部的，生命周期是全局的。</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>指针和引用的主要区别在于本质、初始化方式、可变性和用法。<br>指针是一个变量，存储另一个变量的地址，可以为空（比如设为 nullptr），也可以随时指向别的地址；<br>引用是变量的别名，定义时必须初始化，而且一旦绑定就不能再改为引用别的变量，也不能是空引用。<br>操作上，指针需要通过 * 解引用、通过 &amp; 取地址，而引用使用起来和变量本身一样，不需要额外操作符。<br>用途方面：<br>指针更灵活，适用于动态内存管理、数据结构操作（比如链表）；<br>引用更安全，常用于函数参数传递（特别是避免拷贝开销）或运算符重载等场景。<br>简单说，引用更像“语法糖”，更安全，但灵活性不如指针。</p>
<h2 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++内存分区"></a>C++内存分区</h2><p>栈区（Stack）：由编译器自动管理，存储局部变量和函数调用时的上下文，比如函数参数、返回地址等。特点是分配释放快，但空间较小。<br>堆区（Heap）：由程序员手动管理，用于动态分配内存，比如使用 new&#x2F;delete 或 malloc&#x2F;free。不及时释放可能造成内存泄漏。<br>全局&#x2F;静态区：用于存储全局变量和静态变量，这部分内存在程序整个生命周期内都存在。具体来说又可以细分为：<br>数据段：放初始化过的全局&#x2F;静态变量；<br>BSS 段：放未初始化的全局&#x2F;静态变量，系统会自动初始化为 0。</p>
<p>常量区：存放像字符串常量、const 修饰的全局变量等不可修改的数据，通常是只读的。<br>代码段：也叫 text segment，存放程序的机器指令，也就是代码本身，这部分一般是只读的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/" data-id="cm8mfwu1j0000eovq7428cesn" data-title="高频八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/12/25/hot100/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">hot100</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hot100/" rel="tag">hot100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hot100/" style="font-size: 10px;">hot100</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 10px;">八股文</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 12.5px;">图论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">算法，图论</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">语法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/">高频八股</a>
          </li>
        
          <li>
            <a href="/2024/12/25/hot100/">hot100</a>
          </li>
        
          <li>
            <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2024/12/13/xv6/">xv6</a>
          </li>
        
          <li>
            <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>