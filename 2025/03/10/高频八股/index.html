<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>高频八股 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="HTTPS和HTTP有哪些区别HTTP（HyperText Transfer Protocol）：超文本传输协议，负责在客户端（浏览器）和服务器之间传输数据，明文传输，安全性低。HTTPS（HTTP Secure）：安全超文本传输协议，在 HTTP 基础上加入 SSL&#x2F;TLS 加密层，确保数据传输的安全性。HTTP：TCP 三次握手后即可传输数据。HTTPS：TCP 三次握手后，还需进行">
<meta property="og:type" content="article">
<meta property="og:title" content="高频八股">
<meta property="og:url" content="http://example.com/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HTTPS和HTTP有哪些区别HTTP（HyperText Transfer Protocol）：超文本传输协议，负责在客户端（浏览器）和服务器之间传输数据，明文传输，安全性低。HTTPS（HTTP Secure）：安全超文本传输协议，在 HTTP 基础上加入 SSL&#x2F;TLS 加密层，确保数据传输的安全性。HTTP：TCP 三次握手后即可传输数据。HTTPS：TCP 三次握手后，还需进行">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-10T12:34:41.000Z">
<meta property="article:modified_time" content="2025-04-11T11:59:28.218Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-高频八股" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/" class="article-date">
  <time class="dt-published" datetime="2025-03-10T12:34:41.000Z" itemprop="datePublished">2025-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      高频八股
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HTTPS和HTTP有哪些区别"><a href="#HTTPS和HTTP有哪些区别" class="headerlink" title="HTTPS和HTTP有哪些区别"></a>HTTPS和HTTP有哪些区别</h2><p>HTTP（HyperText Transfer Protocol）：超文本传输协议，负责在客户端（浏览器）和服务器之间传输数据，明文传输，安全性低。<br>HTTPS（HTTP Secure）：安全超文本传输协议，在 HTTP 基础上加入 SSL&#x2F;TLS 加密层，确保数据传输的安全性。<br>HTTP：TCP 三次握手后即可传输数据。<br>HTTPS：TCP 三次握手后，还需进行 SSL&#x2F;TLS 握手，建立安全连接后才可传输加密数据。<br>HTTP 使用 80 端口，HTTPS 使用 443 端口。<br>HTTP 不需要证书。<br>HTTPS 需要向 CA（Certificate Authority） 申请 SSL 证书，以确保服务器身份可信。</p>
<p>背诵版本<br>两者的主要区别在于安全性和数据加密：<br>HTTP 是明文传输协议，安全性低，而 HTTPS 在 HTTP 基础上增加了 SSL&#x2F;TLS 加密层，确保数据安全。<br>HTTP 直接使用 TCP 三次握手传输数据，而 HTTPS 需额外进行 SSL&#x2F;TLS 握手。<br>端口方面，HTTP 使用 80，HTTPS 使用 443。<br>另外，HTTPS 需要向 CA 申请数字证书，确保服务器身份可信，而 HTTP 无需证书</p>
<h2 id="HTTPS的工作原理-HTTPS建立连接的过程）"><a href="#HTTPS的工作原理-HTTPS建立连接的过程）" class="headerlink" title="HTTPS的工作原理(HTTPS建立连接的过程）"></a>HTTPS的工作原理(HTTPS建立连接的过程）</h2><p>HTTPS 主要基于 SSL&#x2F;TLS，核心目标是：</p>
<p>身份认证（验证服务器是否可信）<br>数据加密（防止被窃听）<br>完整性校验（防止数据被篡改）<br>连接建立过程（握手流程）：</p>
<p>客户端发起请求，服务器发送公钥证书<br>客户端向服务器发起 HTTPS 请求，服务器返回自己的 SSL 证书（包含公钥）。<br>证书验证<br>客户端检查该证书是否由可信的 CA（证书颁发机构） 签发，是否过期。<br>密钥协商<br>如果证书可信，客户端生成一个 随机对称密钥，用服务器的公钥加密后发送给服务器。<br>建立安全连接<br>服务器用 私钥解密，得到对称密钥。此时，客户端和服务器共享相同的对称密钥。<br>加密通信<br>双方使用对称密钥进行数据加密，确保数据传输的机密性。<br>完整性校验<br>SSL&#x2F;TLS 使用 消息认证码（MAC） 校验数据，防止篡改。<br>连接关闭<br>传输结束后，双方销毁会话密钥，避免安全风险。</p>
<p>背诵<br>HTTPS 主要基于SSL&#x2F;TLS 协议，确保了数据传输的安全性和完整性, 其建立连接并传输数据的过程如下：</p>
<p>密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端。<br>证书验证：客户端会验证服务器的证书是否由受信任的证书颁发机构（CA ）签发，并检查证书的有效性。<br>加密通信：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。<br>建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。<br>数据传输：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。<br>完整性校验：SSL&#x2F;TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。<br>结束连接：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。</p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP是面向连接的协议，需要在数据传输前建立连接；UDP是无连接的，不需要建立连接。<br>TCP提供可靠的数据传输，保证数据包的顺序和完整性；UDP不保证数据包的顺序或完整性。<br>TCP具有拥塞控制机制，可以根据网络状况调整数据传输速率；UDP没有拥塞控制，发送速率通常固定。<br>TCP通过滑动窗口机制进行流量控制，避免接收方处理不过来；UDP没有流量控制。<br>TCP能够检测并重传丢失或损坏的数据包；UDP不提供错误恢复机制。<br>TCP有复杂的报文头部，包含序列号、确认号等信息，头部复杂（20 字节+）；UDP的报文头部相对简单。（8 字节）。 端口号、长度、校验和<br>由于TCP的连接建立、数据校验和重传机制，其性能开销通常比UDP大；UDP由于简单，性能开销小。<br>适用场景：TCP适用于需要可靠传输的应用，如网页浏览、文件传输等；UDP适用于对实时性要求高的应用，如语音通话、视频会议等。</p>
<h2 id="TCP连接如何确保可靠性"><a href="#TCP连接如何确保可靠性" class="headerlink" title="TCP连接如何确保可靠性"></a>TCP连接如何确保可靠性</h2><p>TCP 通过以下机制确保数据可靠传输：</p>
<p>序列号（Sequence Number）</p>
<p>每个 TCP 段都有 唯一序列号，确保接收方按序重组数据，防止乱序问题。<br>数据校验（Checksum）</p>
<p>TCP 使用 校验和 检测数据是否损坏，若出错，接收方会丢弃数据包，并等待重传。<br>确认应答（ACK, Acknowledgment）</p>
<p>接收方收到数据后发送 ACK 确认，若发送方未在超时时间内收到 ACK，会重传数据。<br>超时重传（Timeout &amp; Retransmission）</p>
<p>发送方设置 超时定时器，如果超时仍未收到 ACK，则重传数据，确保数据不会丢失。<br>流量控制（Flow Control）</p>
<p>采用 滑动窗口（Sliding Window） 机制，调整发送数据的速率，防止接收方处理不过来。<br>拥塞控制（Congestion Control）</p>
<p>采用 慢启动、拥塞避免、快重传、快恢复 等算法，防止因发送速率过快导致网络拥塞。</p>
<p>背诵版本<br>TCP通过差错控制（序列号、确认应答、数据校验）、超时重传、流量控制、拥塞控制等机制，确保了数据传输的可靠性和效率。</p>
<p>序列号：每个TCP段都有一个序列号，确保数据包的顺序正确。<br>数据校验：TCP使用校验和来检测数据在传输过程中是否出现错误，如果检测到错误，接收方会丢弃该数据包，并等待重传。<br>确认应答：接收方发送ACK确认收到的数据，如果发送方在一定时间内没有收到确认，会重新发送数据。<br>超时重传：发送方设置一个定时器，如果在定时器超时之前没有收到确认，发送方会重传数据。<br>流量控制：TCP通过滑动窗口机制进行流量控制，确保接收方能够处理发送方的数据量。<br>拥塞控制：TCP通过算法如慢启动、拥塞避免、快重传和快恢复等，来控制数据的发送速率，防止网络拥塞。</p>
<h2 id="拥塞控制机制"><a href="#拥塞控制机制" class="headerlink" title="拥塞控制机制"></a>拥塞控制机制</h2><p>TCP 拥塞控制的核心目标是防止网络过载，保证数据高效传输。主要通过 四大机制 动态调整发送速率：</p>
<p>慢启动（Slow Start）</p>
<p>初始阶段，TCP 发送窗口（cwnd） 设为较小值（通常为 1 个 MSS）。<br>每次收到 ACK，cwnd 指数级增长（每次 ACK cwnd 翻倍）。<br>当 cwnd 达到 慢启动阈值（ssthresh） 时，进入拥塞避免阶段。<br>拥塞避免（Congestion Avoidance）</p>
<p>cwnd 线性增长（每个 RTT 只增加 1 个 MSS），避免增长过快导致拥塞。<br>目的：控制流量增长，防止网络过载。<br>快速重传（Fast Retransmit）</p>
<p>当收到 3 个重复 ACK，认为数据包丢失，不等超时，直接重传丢失的数据包。<br>快速恢复（Fast Recovery）</p>
<p>快速重传后，不进入慢启动，而是：<br>ssthresh 设为当前 cwnd 一半，减少发送速率。<br>cwnd 设为 ssthresh + 3（补偿未确认但仍在传输中的数据）。<br>恢复后继续拥塞避免阶段，线性增长。</p>
<p>背诵版本<br>TCP拥塞控制可以在网络出现拥塞时动态地调整数据传输的速率，以防止网络过载。TCP拥塞控制的主要机制包括以下几个方面：</p>
<p>慢启动（Slow Start）： 初始阶段，TCP发送方会以较小的发送窗口开始传输数据。随着每次成功收到确认的数据，发送方逐渐增加发送窗口的大小，实现指数级的增长，这称为慢启动。这有助于在网络刚开始传输时谨慎地逐步增加速率，以避免引发拥塞。<br>拥塞避免（Congestion Avoidance）： 一旦达到一定的阈值（通常是慢启动阈值），TCP发送方就会进入拥塞避免阶段。在拥塞避免阶段，发送方以线性增加的方式增加发送窗口的大小，而不再是指数级的增长。这有助于控制发送速率，以避免引起网络拥塞。<br>快速重传（Fast Retransmit）： 如果发送方连续收到相同的确认，它会认为发生了数据包的丢失，并会快速重传未确认的数据包，而不必等待超时。这有助于更快地恢复由于拥塞引起的数据包丢失。<br>快速恢复（Fast Recovery）： 在发生快速重传后，TCP进入快速恢复阶段。在这个阶段，发送方不会回到慢启动阶段，而是将慢启动阈值设置为当前窗口的一半，并将拥塞窗口大小设置为慢启动阈值加上已确认但未被快速重传的数据块的数量。这有助于更快地从拥塞中恢复。</p>
<h2 id="TCP流量控制是怎么实现的"><a href="#TCP流量控制是怎么实现的" class="headerlink" title="TCP流量控制是怎么实现的"></a>TCP流量控制是怎么实现的</h2><p>滑动窗口的作用<br>滑动窗口（Window Size）决定发送方最多可以发送多少数据，而无需等待 ACK。<br>窗口大小由接收方动态调整，保证不会超出自身的缓冲区容量。<br>📌 滑动窗口的组成<br>接收窗口（Receiver Window，rwnd）</p>
<p>由 接收方 通过 TCP 报文的 窗口字段 指定。<br>表示接收方 当前还可以接收多少字节的数据。<br>发送方必须遵守 rwnd 约束，不能超出接收方缓冲区容量。<br>发送窗口（Sender Window）</p>
<p>发送方维护一个滑动窗口，决定可以发送的数据量。<br>其大小取决于 min(rwnd, cwnd)，其中：<br>rwnd：接收方的接收窗口（流量控制）。<br>cwnd：拥塞窗口（拥塞控制，防止网络拥塞）。<br>3. 流量控制的工作流程<br>✅ 1. 发送方发送数据<br>发送方检查 rwnd（接收方可接收的数据大小）。<br>只发送不超过 rwnd 限制的数据量。<br>✅ 2. 接收方返回 ACK，并更新窗口大小<br>接收方在 ACK 报文中包含新的 rwnd 值，通知发送方当前剩余的接收缓冲区空间。<br>✅ 3. 发送方根据 rwnd 调整发送速率<br>如果 rwnd 增大（缓冲区有空闲），发送方加快发送速率。<br>如果 rwnd 变小（缓冲区接近满），发送方减慢发送速率，甚至暂停发送。<br>4. 流量控制的特殊情况<br>📌 1. 接收窗口变为 0<br>如果 rwnd &#x3D; 0（接收方缓冲区已满），发送方必须暂停发送，直到接收方通知新的窗口大小。<br>TCP 采用“窗口探测（Zero Window Probe）”机制，定期发送小包测试 rwnd 是否恢复。<br>📌 2. 发送方“傻等”问题<br>发送方可能会一直等待 rwnd 变大，但如果接收方一直不更新 rwnd，会导致死锁。<br>解决方案：<br>TCP 发送窗口探测数据包（Zero Window Probe）。<br>接收方定期发送 ACK，更新 rwnd 值。<br>5. 流量控制 vs 拥塞控制<br>机制	目的	受谁控制	依据	影响因素<br>流量控制	防止接收方缓冲区溢出	接收方	rwnd（接收窗口）	接收方处理能力<br>拥塞控制	防止网络拥塞	发送方	cwnd（拥塞窗口）	网络状况</p>
<p>背诵版本<br>流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制，主要方法就是动态调整发送方和接收方之间数据传输速率。<br>滑动窗口大小： 在TCP通信中，每个TCP报文段都包含一个窗口字段，该字段指示发送方可以发送多少字节的数据而不等待确认。这个窗口大小是动态调整的。<br>接收方窗口大小： 接收方通过TCP报文中的窗口字段告诉发送方自己当前的可接收窗口大小。这是接收方缓冲区中还有多少可用空间。<br>流量控制的目标： 流量控制的目标是确保发送方不要发送超过接收方缓冲区容量的数据。如果接收方的缓冲区快满了，它会减小窗口大小，通知发送方暂停发送，以防止溢出。<br>动态调整： 发送方会根据接收方的窗口大小动态调整发送数据的速率。如果接收方的窗口大小增加，发送方可以加速发送数据。如果窗口大小减小，发送方将减缓发送数据的速率。<br>确认机制： 接收方会定期发送确认（ACK）报文，告知发送方已成功接收数据。这也与流量控制密切相关，因为接收方可以通过ACK报文中的窗口字段来通知发送方它的当前窗口大小。</p>
<h2 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h2><p>UDP（User Datagram Protocol）是无连接、不可靠的协议，它的优点是资源消耗低、处理速度快，常用于音视频流、在线游戏等对实时性要求高的应用。<br>然而，UDP 本身不提供可靠性保证，如果应用层需要可靠传输，就必须自行实现类似 TCP 的机制。</p>
<ol>
<li>可靠 UDP（Reliable UDP, RUDP） 的关键技术<br>为了在 UDP 上实现可靠传输，应用层通常借鉴 TCP 机制，包括：</li>
</ol>
<p>超时重传（Timeout &amp; Retransmission）：避免数据丢失。<br>确认应答（ACK, Acknowledgment）：确保数据正确接收。<br>序列号（Sequence Number）：确保数据包有序到达，避免丢失或重复。<br>流量控制（Flow Control）：防止发送方过快发送，导致接收方缓冲区溢出。<br>拥塞控制（Congestion Control）（可选）：防止网络过载。<br>2. UDP 可靠传输的实现方式<br>📌 发送方（Sender）<br>在 UDP 数据报中自定义首部，包含：<br>序列号（确保数据包按序接收）。<br>时间戳（用于计算 RTT 和超时时间 RTO）。<br>发送数据报，进入等待状态：<br>采用 “停-等协议（Stop-and-Wait）”，即发送一个数据包后等待 ACK，收到确认后才发送下一个。<br>如果超时仍未收到 ACK，执行重传，同时 RTO（重传超时时间）扩大 2 倍，重新计时（类似 TCP 超时重传机制）。<br>📌 接收方（Receiver）<br>收到 UDP 数据报后，解析首部：<br>提取 序列号，确保数据包按序排列。<br>提取 时间戳，用于测量 RTT 并优化 RTO 计算。<br>发送 ACK 确认：<br>在 ACK 中包含 确认的序列号，告知发送方已经正确收到的数据包。<br>若发现数据包 重复，则丢弃（防止重复接收）。<br>若数据包 乱序，可缓存等待重排序。</p>
<p>背诵版本<br>UDP怎么实现可靠传输<br>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。关键在于两点，从应用层角度考虑：</p>
<p>（1）提供超时重传，能避免数据报丢失。</p>
<p>（2）提供确认序列号，可以对数据报进行确认和排序。</p>
<p>本端：首先在UDP数据报定义一个首部，首部包含确认序列号和时间戳，时间戳是用来计算RTT(数据报传输的往返时间)，计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报，即收到对端的确认之后才发送下一个的数据报。当时间超时，本端重传数据报，同时RTO扩大为原来的两倍，重新开始计时。</p>
<p>对端：接受到一个数据报之后取下该数据报首部的时间戳和确认序列号，添加自己的 UDP 自定义首部（包括新的时间戳和确认序列号）。<br>发送给发送方，通知“这个数据包已经成功接收”。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p>
<h2 id="tcp为什么需要三次握手"><a href="#tcp为什么需要三次握手" class="headerlink" title="tcp为什么需要三次握手"></a>tcp为什么需要三次握手</h2><p>(1) 三次握手的过程</p>
<p>第一次握手：客户端向服务器发送一个SYN （同步序列编号）报文，请求建立连接，客户端进入SYN_SENT 状态。<br>第二次握手：服务器收到SYN 报文后，如果同意建立连接，则会发送一个SYN-ACK （同步确认）报文作为响应，同时进入SYN_RCVD 状态。<br>第三次握手：客户端收到服务器的SYN-ACK 报文后，会发送一个ACK （确认）报文作为最终响应，之后客户端和服务器都进入ESTABLISHED 状态，连接建立成功。<br>(2)为什么需要三次握手</p>
<p>通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。</p>
<p>而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。而四次握手可以优化为三次。</p>
<h2 id="TCP为什么需要四次挥手"><a href="#TCP为什么需要四次挥手" class="headerlink" title="TCP为什么需要四次挥手"></a>TCP为什么需要四次挥手</h2><p>（1）四次挥手的过程</p>
<p>第一次挥手：客户端发送一个FIN报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号 (seq&#x3D;x)。然后,客户端进入FIN-WAIT-1 状态。<br>第二次挥手：服务端收到FIN报文后，回复ACK报文给客户端，且把客户端的序列号值+1，作为ACK报文的序列号(seq&#x3D;x+1)。然后，服务端进入CLOSE-WAIT(seq&#x3D;x+1)状态，客户端进入FIN-WAIT-2状态。<br>第三次挥手：服务端也要断开连接时，发送FIN报文给客户端，且指定一个序列号(seq&#x3D;y+1)，随后服务端进入LAST-ACK状态。<br>第四次挥手：客户端收到FIN报文后，发出ACK报文进行应答，并把服务端的序列号值+1作为ACK报文序列号(seq&#x3D;y+2)。此时客户端进入TIME-WAIT状态。服务端在收到客户端的ACK 报文后进入CLOSE 状态。如果客户端等待2MSL没有收到回复，才关闭连接。<br>（2）为什么需要四次挥手</p>
<p>TCP 是全双工通信协议，允许数据在两个方向上传输。因此，任何一方在数据传输完成后，都可以主动发起连接释放请求。当对方确认该请求后，连接进入半关闭状态，即一方不再发送数据，但仍可接收来自对方的数据。只有当另一方也发送连接释放请求，并得到确认后，TCP 连接才会完全关闭。因此，完整的连接释放过程需要四次挥手。</p>
<p>四次挥手的必要性在于确保双方都能正确接收对方的最后一个数据包，并进行确认。具体来说：</p>
<p>主动关闭方 先发送 FIN（终止连接请求）报文，表示不再发送数据，但仍可接收数据。<br>被动关闭方 收到 FIN 后，发送 ACK 确认，但此时连接仍然保持开放，可能还有未发送完的数据。<br>被动关闭方 在数据传输完成后，再发送 FIN，通知主动关闭方可以完全断开连接。<br>主动关闭方 发送 ACK 确认后，进入 TIME-WAIT 状态，等待一段时间，以确保被动关闭方成功接收到 ACK，然后才真正释放连接。<br>如果省略第四次挥手（即仅用三次挥手关闭连接），可能会导致被动关闭方在发送最后一个数据包后立即关闭连接，而主动关闭方还未接收到该数据包的确认，从而造成数据丢失或连接异常。因此，四次挥手是为了确保双方数据传输的完整性和可靠性。</p>
<h2 id="HTTP-的-Keep-Alive-是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？、"><a href="#HTTP-的-Keep-Alive-是什么？TCP-的-Keepalive-和-HTTP-的-Keep-Alive-是一个东西吗？、" class="headerlink" title="HTTP 的 Keep-Alive 是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？、"></a>HTTP 的 Keep-Alive 是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？、</h2><ol>
<li>HTTP 的 Keep-Alive（HTTP 长连接）<br>HTTP 的 Keep-Alive 是应用层实现的长连接机制，用于减少频繁建立和释放 TCP 连接的开销。</li>
</ol>
<p>通常，HTTP 请求的基本流程如下：</p>
<p>建立 TCP 连接<br>发送 HTTP 请求<br>服务器响应请求<br>释放 TCP 连接<br>这种方式称为 HTTP 短连接，每次请求都需要重新建立 TCP 连接。而 HTTP Keep-Alive 允许在同一个 TCP 连接上复用多个 HTTP 请求和响应，从而避免重复建立连接带来的开销，提高性能。这种方式称为 HTTP 长连接，可以通过 HTTP 头部 Connection: keep-alive 来启用。</p>
<ol start="2">
<li>TCP 的 Keepalive（TCP 保活机制）<br>TCP 的 Keepalive 是 TCP 层（内核态） 提供的一种连接存活检测机制，用于判断 TCP 连接是否仍然有效。</li>
</ol>
<p>当 TCP 连接长时间没有数据传输时，TCP Keepalive 机制会周期性发送探测包给对方：</p>
<p>如果对方响应，则说明连接仍然有效；<br>如果对方未响应多次，TCP 可能会认为连接已断开，并终止该连接。<br>TCP Keepalive 适用于多种协议，不仅限于 HTTP，还包括 FTP、SMTP 等网络协议。它的作用类似于垃圾回收机制（GC），用于清理长期不活动但未正式关闭的连接。</p>
<p>3.3. HTTP Keep-Alive 与 TCP Keepalive 的关系<br>虽然 HTTP Keep-Alive 和 TCP Keepalive 听起来相似，但它们是完全不同的机制：</p>
<p>HTTP Keep-Alive：由应用层（HTTP 协议）控制，主要用于在同一 TCP 连接上复用多个 HTTP 请求，减少 TCP 连接的建立与释放。<br>TCP Keepalive：由 TCP 层（传输层）实现，主要用于检测连接是否仍然存活，避免死连接长时间占用资源。<br>两者的配合场景：如果 HTTP 连接开启了 Keep-Alive，但一段时间没有数据传输，而没有显式关闭连接，此时 TCP Keepalive 可能会起作用，检测连接状态并在必要时关闭连接，防止无效连接占用资源。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p> 一、基本定义<br>进程（Process）：是操作系统进行资源分配和调度的基本单位，每个进程有独立的内存空间。<br>线程（Thread）：是程序执行的最小单位，属于进程内部，是进程的子任务。一个进程可以有多个线程，共享该进程的内存资源。<br>二、主要区别对比<br>1️⃣ 资源开销<br>进程：创建、销毁和切换时开销大（因为需要切换完整上下文和内存空间）。<br>线程：开销小，仅切换少量上下文，共享内存更高效。<br>2️⃣ 通信与共享<br>进程：进程间相互隔离，通信需要使用IPC机制（如管道、消息队列、共享内存等）。<br>线程：共享同一个地址空间，可以直接访问共享变量，通信简单高效。<br>3️⃣ 稳定性与安全性<br>进程：隔离性强，一个进程崩溃不会影响其他进程，更安全。<br>线程：共享内存，一个线程出错可能导致整个进程崩溃，风险更大。</p>
<h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>✅ 定义解释<br>1️⃣ 并发（Concurrency）<br>指在同一时间段内有多个任务在执行，<br>但不一定真正同时运行，可能是交替进行。<br>依赖任务调度机制（如时间片轮转、事件驱动）实现“同时进行”的效果。<br>📌 类比：一个人用一只手做饭、接电话、炒菜 —— 来回切换，但表面上都在进行。<br>2️⃣ 并行（Parallelism）<br>指在同一时刻有多个任务真正同时执行，<br>每个任务运行在不同的处理器或核心上。<br>依赖多核 CPU、多线程或多进程来实现任务物理并行处理。<br>📌 类比：三个人分别做饭、接电话、炒菜 —— 真正同时干活。</p>
<h2 id="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"><a href="#解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？" class="headerlink" title="解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？"></a>解释一下用户态和核心态，什么场景下，会发生内核态和用户态的切换？</h2><p>用户态和内核态的区别<br>用户态和内核态是操作系统为了保护系统资源和实现权限控制而设计的两种不同的CPU运行级别，可以控制进程或程序对计算机硬件资源的访问权限和操作范围。</p>
<p>用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源。<br>核心态：核心态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。<br>在什么场景下，会发生内核态和用户态的切换<br>系统调用：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态。<br>异常：当程序执行过程中出现错误或异常情况时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。<br>中断：外部设备（如键盘、鼠标、磁盘等）产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态。</p>
<h2 id="什么是死锁-如何避免死锁"><a href="#什么是死锁-如何避免死锁" class="headerlink" title="什么是死锁 如何避免死锁"></a>什么是死锁 如何避免死锁</h2><p>🔹 方法 1：破坏“循环等待”条件（常见做法）<br>让进程按照固定的顺序请求资源，避免环形等待。</p>
<p>例如：规定所有进程必须先申请 R1，再申请 R2，这样不会形成环路。<br>🔹 方法 2：破坏“请求保持”条件<br>强制进程一次性申请所有资源，如果无法全部分配，则必须先释放已有资源，等所有资源可用时再重新申请。</p>
<p>优点：避免了进程在等待额外资源时持有部分资源。<br>缺点：可能会降低资源利用率。<br>🔹 方法 3：破坏“不可剥夺”条件<br>允许操作系统强行回收资源，将资源从某个进程转移给另一个进程，以解除死锁。</p>
<p>例如：当发现死锁时，系统可以暂停某些进程，并强制回收它们占用的资源。<br>🔹 方法 4：死锁检测 + 解除死锁<br>检测死锁：<br>通过 资源分配图（Resource Allocation Graph, RAG） 或 银行家算法（Banker’s Algorithm） 来判断系统是否进入死锁状态。<br>解除死锁：<br>抢占资源（从某些进程中回收资源）。<br>终止进程（强制结束部分进程，以释放资源）。<br>回滚进程（将进程恢复到安全状态）。</p>
<p>背诵版本：<br>死锁是系统中两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一定的资源并等待其他进程释放它们所需的资源时，如果这些资源都被其他进程占有且不释放，就导致了死锁。</p>
<p>死锁只有同时满足以下四个条件才会发生：</p>
<p>互斥条件：一个进程占用了某个资源时，其他进程无法同时占用该资源。<br>请求保持条件：一个进程因为请求资源而阻塞的时候，不会释放自己的资源。<br>不可剥夺条件：资源不能被强制性地从一个进程中剥夺，只能由持有者自愿释放。<br>循环等待条件：多个进程之间形成一个循环等待资源的链，每个进程都在等待下一个进程所占有的资源。<br>避免死锁：<br>通过破坏死锁的四个必要条件之一来预防死锁。比如破坏循环等待条件，让所有进程按照相同的顺序请求资源。<br>检测死锁：通过检测系统中的资源分配情况来判断是否存在死锁。例如，可以使用资源分配图或银行家算法进行检测。<br>解除死锁：一旦检测到死锁存在，可以采取一些措施来解除死锁。例如，可以通过抢占资源、终止某些进程或进行资源回收等方式来解除死锁。</p>
<h2 id="解释典型的锁"><a href="#解释典型的锁" class="headerlink" title="解释典型的锁"></a>解释典型的锁</h2><p>互斥锁：互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。<br>自旋锁：自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。<br>其他的锁都是基于这两个锁的</p>
<p>读写锁：允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读（共享）和写（排他）两种状态。<br>悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁<br>乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。</p>
<h2 id="讲一讲理解的虚拟内存"><a href="#讲一讲理解的虚拟内存" class="headerlink" title="讲一讲理解的虚拟内存"></a>讲一讲理解的虚拟内存</h2><p>虚拟内存是指在每一个进程创建加载的过程中，会分配一个连续虚拟地址空间，它不是真实存在的，而是通过映射与实际物理地址空间对应，这样就可以使每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存RAM更大的地址空间, 每个程序都可以认为它拥有足够的内存来运行。</p>
<p>需要虚拟内存的原因：</p>
<p>内存扩展： 虚拟内存使得每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据。<br>内存隔离：虚拟内存还提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。<br>物理内存管理：虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。<br>页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。<br>内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。</p>
<h2 id="进程调度算法理解多少"><a href="#进程调度算法理解多少" class="headerlink" title="进程调度算法理解多少"></a>进程调度算法理解多少</h2><p>先来先服务：按照请求的顺序进行调度。 这种调度方式简单，但是能导致较长作业阻塞较短作业。<br>最短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 但是如果一直有短作业到来，那么长作业永远得不到调度，造成长作业“饥饿”现象。<br>最短剩余时间优先：基于最短作业优先改进，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。<br>优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br>时间片轮转：为每个进程分配一个时间片，进程轮流执行，时间片用完后切换到下一个进程。<br>多级队列：时间片轮转调度算法和优先级调度算法的结合。 将进程分为不同的优先级队列，每个队列有自己的调度算法。</p>
<h2 id="进程间有哪些通信方式"><a href="#进程间有哪些通信方式" class="headerlink" title="进程间有哪些通信方式"></a>进程间有哪些通信方式</h2><p>管道：是一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。<br>命名管道： 类似管道，也是半双工的通信方式，但是它允许在不相关的进程间通信。<br>消息队列：允许进程发送和接收消息，而消息队列是消息的链表，可以设置消息优先级。<br>信号：用于发送通知到进程，告知其发生了某种事件或条件。<br>信号量：是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同一进程内不同线程之间的同步手段。<br>共享内存：就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程通信方式，<br>Socket套接字：是支持TCP&#x2F;IP 的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。</p>
<h2 id="解释一下进程同步和互斥，以及如何实现进程同步和互斥"><a href="#解释一下进程同步和互斥，以及如何实现进程同步和互斥" class="headerlink" title="解释一下进程同步和互斥，以及如何实现进程同步和互斥"></a>解释一下进程同步和互斥，以及如何实现进程同步和互斥</h2><p>进程同步 是指多个并发执行的进程之间通过一定的协调机制，保证它们按照特定顺序或规则执行，以避免由于竞争共享资源引发的冲突或不一致性。</p>
<p>互斥 是一种特殊的同步方式，强调在同一时刻只能有一个进程访问某个共享资源，确保对资源的访问具有排他性。</p>
<p>常见的实现方法包括：<br>信号量与PV操作：<br>信号量 是一种表示资源数量或状态的特殊整型变量，用于协调进程间的同步与互斥。信号量的基本操作称为 PV操作。</p>
<p>P操作（等待操作）： 尝试减少信号量的值，如果值大于0，则减1并继续执行；若为0，则进程被阻塞，直到信号量变为正数。</p>
<p>V操作（释放操作）： 增加信号量的值，若有其他进程在等待这个信号量，就唤醒其中一个等待的进程。</p>
<p>互斥 是一种特殊的同步情形，目的是确保在同一时间只有一个进程能够访问共享资源，从而避免竞态条件。实现互斥的典型机制包括：<br>临界区：<br>临界区是一段访问共享资源的代码片段。<br>每次仅允许一个进程进入临界区，通过 锁机制 来实现互斥访问。<br>进入临界区之前必须先获取锁，执行完临界区的代码后再释放锁。</p>
<p>常见的进程同步与互斥实现方法：<br>互斥锁（Mutex）<br>通常用于保护临界区，确保资源同一时刻只被一个进程占用。<br>进程进入临界区前先加锁，退出时释放锁。<br>进程间的Mutex通常借助共享内存实现。<br>信号量（Semaphore）<br>既能用于同步，也能用于互斥。是更一般的同步机制。<br>互斥：信号量初始值设置为1，实现互斥（如二值信号量）。<br>同步：初始值设置为0，用于进程等待某事件或条件满足。<br>条件变量（Condition Variable）<br>条件变量用于在进程之间传递信号，使进程能够在特定条件下等待或被唤醒。<br>一般结合互斥锁使用，确保等待与唤醒操作在合适时机发生。<br>信号（Signal）<br>进程间可以通过发送和捕获信号实现简单同步或通知（例如SIGUSR1、SIGUSR2）。<br>信号是一种异步通知机制，不适合复杂的同步场景</p>
<h2 id="你知道线程同步方式有哪些"><a href="#你知道线程同步方式有哪些" class="headerlink" title="你知道线程同步方式有哪些"></a>你知道线程同步方式有哪些</h2><p>线程同步 指的是多个线程之间协调执行顺序或访问共享资源，以保证程序的正确性，避免数据竞争和不一致的问题。<br>线程互斥 是线程同步的特例，指在同一时刻只允许一个线程访问某个共享资源或临界区。</p>
<p>常见的线程同步与互斥实现方式包括：<br>互斥锁（Mutex）<br>最基础的线程同步机制，确保某个共享资源在同一时间仅被一个线程访问。<br>条件变量（Condition Variable）<br>允许线程等待某个特定条件满足时再继续执行，通常与互斥锁一起使用。<br>读写锁（Read-Write Lock）<br>当共享资源读操作远多于写操作时更为高效。<br>允许多个线程同时读，但在写操作时只能有一个线程独占资源。<br>信号量（Semaphore）<br>常用于线程同步与互斥的通用机制，尤其适合生产者-消费者等场景。</p>
<h2 id="有哪些页面置换算法"><a href="#有哪些页面置换算法" class="headerlink" title="有哪些页面置换算法"></a>有哪些页面置换算法</h2><p>最近最久未使用算法LRU ：LRU算法基于页面的使用历史，通过选择最长时间未被使用的页面进行置换。<br>先进先出FIFO算法：也就是最先进入内存的页面最先被置换出去。<br>最不经常使用LFU ：淘汰访问次数最少的页面，考虑页面的访问频率。<br>时钟算法CLOCK：Clock算法的核心思想是通过使用一个指针(称为时钟指针)在环形链表上遍历，检查页面是否被访问过, 当需要进行页面置换时，Clock算法从时钟指针的位置开始遍历环形链表。 如果当前页面的访问位为0，表示该页面最久未被访问，可以选择进行置换。将访问位设置为1，继续遍历下一个页面。 如果当前页面的访问位为1，表示该页面最近被访问过，它仍然处于活跃状态。将访问位设置为0，并继续遍历下一个页面如果遍历过程中找到一个访问位为0的页面，那么选择该页面进行置换。<br>最佳置换算法: 该算法根据未来的页面访问情况，选择最长时间内不会被访问到的页面进行置换。那么就有一个问题了，未来要访问什么页面，操作系统怎么知道的呢?操作系统当然不会知道，所以这种算法只是一种理想情况下的置换算法，通常是无法实现的。</p>
<h2 id="LINUX常用命令有哪些"><a href="#LINUX常用命令有哪些" class="headerlink" title="LINUX常用命令有哪些"></a>LINUX常用命令有哪些</h2><ol>
<li><p>文件和目录操作<br>ls：列出目录内容。<br>常用：ls -l 详细信息，ls -a 显示隐藏文件。<br>cd：改变当前目录。<br>pwd：显示当前工作目录。<br>cp：复制文件或目录。<br>常用：cp -r 递归复制目录。<br>mv：移动或重命名文件。<br>rm：删除文件或目录。<br>常用：rm -r 删除目录及内容，rm -f 强制删除。<br>touch：创建空文件或更新文件时间戳。</p>
</li>
<li><p>文件内容查看<br>cat：查看文件内容。<br>head：查看文件前几行（默认前10行）。<br>常用：head -n 5 显示前5行。<br>tail：查看文件后几行（默认后10行），常用于查看日志文件。<br>常用：tail -f 动态监控日志变化。</p>
</li>
<li><p>文件编辑<br>vi&#x2F;vim：强大的文本编辑器，支持命令模式和插入模式。</p>
</li>
<li><p>权限管理<br>chmod：更改文件或目录的访问权限。<br>常用：chmod 755 file.sh 为文件赋予执行权限。<br>chown：更改文件或目录的所有者和所属组。<br>常用：chown user:group file</p>
</li>
<li><p>磁盘管理<br>df：查看磁盘空间使用情况。<br>常用：df -h 以人类可读的方式显示（MB&#x2F;GB）。</p>
</li>
<li><p>网络管理<br>ifconfig 或 ip addr：查看和配置网络接口。<br>ping：测试网络连通性。<br>常用：ping -c 4 ip地址 发送4个数据包。<br>netstat：查看网络连接和端口状态。<br>常用：netstat -anp 显示详细网络状态。<br>ssh：安全远程登录到主机。<br>常用：ssh user@host</p>
</li>
<li><p>进程管理<br>ps：查看当前运行的进程。<br>常用：ps aux 查看所有进程详细信息。<br>kill：终止进程或发送信号。<br>常用：kill -9 PID 强制终止进程。</p>
</li>
<li><p>软件包管理（依发行版而定）<br>apt-get（Debian&#x2F;Ubuntu）：<br>apt-get update 更新软件包索引。<br>apt-get install package_name 安装软件包。<br>apt-get remove package_name 删除软件包。</p>
</li>
</ol>
<h2 id="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"><a href="#Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用" class="headerlink" title="Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用"></a>Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用</h2><p>查看进程： 用 ps 命令查看当前运行的进程，比如 ps aux 可以列出所有进程及其详细信息。<br>杀死进程： 首先用 ps 或 top 命令找到进程的PID（进程ID）。 然后用 kill 命令加上进程ID来结束进程，例如 kill -9 PID。”-9” 是强制杀死进程的信号。<br>查看端口占用： 使用 lsof -i:端口号 可以查看占用特定端口的进程。 或者用 netstat -tulnp | grep 端口号，这会显示监听在该端口的服务及其进程ID。<br>-t：显示TCP连接的信息。<br>-u：显示UDP连接的信息。<br>-l：仅显示处于监听（Listening）状态的端口。<br>-n：以数字形式显示地址和端口（不解析为主机名和服务名）。<br>-p：显示使用该端口的进程PID和名称。</p>
<p>list open files（列出打开的文件）。</p>
<h2 id="说一下-select、poll、epoll"><a href="#说一下-select、poll、epoll" class="headerlink" title="说一下 select、poll、epoll"></a>说一下 select、poll、epoll</h2><p>I&#x2F;O多路复用是一种允许应用程序同时监视多个文件描述符（例如：网络套接字）的技术。程序通过单个线程或进程就可以同时等待多个I&#x2F;O事件（如数据可读、可写等），以提高并发性能。</p>
<p>Linux系统中提供的I&#x2F;O多路复用机制主要有：<br>select<br>poll<br>epoll</p>
<p>Linux 提供三种 I&#x2F;O 多路复用技术：</p>
<p>select： select是一个最古老的I&#x2F;O多路复用机制，它可以监视多个文件描述符的可读、可写和错误状态。然而，但是它的效率可能随着监视的文件描述符数量的增加而降低。有上限一般1024个<br>poll： poll是select的一种改进，它使用轮询方式来检查多个文件描述符的状态，避免了select中文件描述符数量有限的问题。但对于大量的文件描述符，poll的性能也可能变得不足够高效。<br>epoll： epoll是Linux特有的I&#x2F;O多路复用机制，相较于select和poll，它在处理大量文件描述符时更加高效。epoll使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不需要应用程序轮询。</p>
<h2 id="一条SQL查询语句是如何执行的"><a href="#一条SQL查询语句是如何执行的" class="headerlink" title="一条SQL查询语句是如何执行的"></a>一条SQL查询语句是如何执行的</h2><p>连接器:连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>查询缓存: MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value 对的形式，被直接缓存在内存中。<br>分析器:你输入的是由多个字符串和空格组成的一条SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。<br>优化器:优化器是在表里面有多个索引的时候，决定使用哪个索引; 或者在一个语句有多表关联(join )的时候，决定各个表的连接顺序。<br>执行器: MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<h2 id="事务的四大特性有哪些"><a href="#事务的四大特性有哪些" class="headerlink" title="事务的四大特性有哪些"></a>事务的四大特性有哪些</h2><p>原子性（A）	事务不可分割，成功 or 失败	失败则回滚，避免数据残留<br>一致性（C）	事务前后一致，数据完整	保证数据遵循约束，不会破坏完整性<br>隔离性（I）	并发事务互不干扰	通过不同隔离级别控制<br>持久性（D）	事务提交后永久生效	依赖数据库日志机制</p>
<p>事务的四大特性通常被称为 ACID 特性<br>原子性：确保事务的所有操作要么全部执行成功，要么全部失败回滚，不存在部分成功的情况。<br>一致性：事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态。<br>隔离性：多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响其他事务的执行。<br>持久性：一旦事务被提交，它对数据库的改变就是永久性的，即使在系统故障或崩溃后也能够保持。</p>
<h2 id="数据库的事务隔离级别有哪些"><a href="#数据库的事务隔离级别有哪些" class="headerlink" title="数据库的事务隔离级别有哪些"></a>数据库的事务隔离级别有哪些</h2><p>数据库事务的隔离性（Isolation）用于控制多个事务并发执行时的互相影响，防止数据不一致问题。SQL 标准定义了 4 种事务隔离级别，分别是 读未提交、读已提交、可重复读、序列化。</p>
<p>数据库的事务隔离级别有哪些？<br>读未提交（Read Uncommitted）：<br>允许一个事务读取另一个事务尚未提交的数据修改。<br>最低的隔离级别，存在脏读、不可重复读和幻读的问题。<br>读已提交（Read Committed）：<br>一个事务只能读取已经提交的数据。其他事务的修改在该事务提交之后才可见。<br>解决了脏读问题，但仍可能出现不可重复读和幻读。<br>可重复读（Repeatable Read）：<br>事务执行期间，多次读取同一数据会得到相同的结果，即在事务开始和结束之间，其他事务对数据的修改不可见。<br>解决了不可重复读问题，但仍可能出现幻读。<br>序列化（Serializable）：<br>最高的隔离级别，确保事务之间的并发执行效果与串行执行的效果相同，即不会出现脏读、不可重复读和幻读。</p>
<h2 id="zynq的启动流程"><a href="#zynq的启动流程" class="headerlink" title="zynq的启动流程"></a>zynq的启动流程</h2><p>Zynq 的启动方式主要有 JTAG、QSPI Flash、SD 卡启动，我们通常采用 SD 卡启动：<br>上电后，FSBL 运行，加载 FPGA Bitstream（配置 AD9361 采集数据）。<br>然后启动 ARM 端的应用程序，通过 AXI-DMA 从 FPGA 读取 AD9361 采集的信号。<br>ARM 端进一步处理数据（如滤波、解调），然后传输到上层系统。</p>
<h2 id="MYSQL使用哪些存储引擎"><a href="#MYSQL使用哪些存储引擎" class="headerlink" title="MYSQL使用哪些存储引擎"></a>MYSQL使用哪些存储引擎</h2><p>MySQL的执行引擎主要负责查询的执行和数据的存储, 其执行引擎主要有MyISAM、InnoDB、Memory 等。<br>InnoDB引擎提供了对事务ACID的支持，还提供了行级锁和外键的约束，是目前MySQL的默认存储引擎，适用于需要事务和高并发的应用。<br>MyISAM引擎是早期的默认存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景。<br>Memery就是将数据放在内存中，访问速度快，但数据在数据库服务器重启后会丢失。</p>
<h2 id="MYSQL为什么选择使用B-树作为索引"><a href="#MYSQL为什么选择使用B-树作为索引" class="headerlink" title="MYSQL为什么选择使用B+树作为索引"></a>MYSQL为什么选择使用B+树作为索引</h2><p>MySQL 主要使用 B+ 树 作为索引结构，是因为 B+ 树在 查询效率、插入删除效率以及范围查询 等方面更适合数据库场景。B+ 树是 B 树的一种变种，结构上做了一些优化：</p>
<ol>
<li>查询性能更稳定、磁盘访问更少<br>B 树的节点既存储索引也存储数据记录，有时可以在中间节点就查到结果，但也可能需要访问叶子节点，查询路径不稳定。<br>B+ 树的所有数据都存储在叶子节点，非叶子节点只存索引。这样每次查询都走到叶子节点，虽然从时间复杂度看仍是 虽然 B 树和 B+ 树的查询时间复杂度都是 O(log n)，但 B+ 树每次查找都必须走到叶子节点，路径更稳定、访问次数更可控。<br>更关键的是，B+ 树的非叶子节点只存储索引，不存储实际数据，所以每个节点可以容纳更多的关键字，同样的数据量下，B+ 树的层级更少，结构更“矮胖”，这能显著减少磁盘 I&#x2F;O 次数，从而提升查询性能。</li>
</ol>
<p>。<br>2. 插入与删除更高效，结构更稳定<br>B+ 树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。B 树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。<br>3. 范围索引更高效<br>B+ 树所有叶子节点间有一个链表进行连接，而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB。</p>
<h2 id="说一下索引失效的场景？"><a href="#说一下索引失效的场景？" class="headerlink" title="说一下索引失效的场景？"></a>说一下索引失效的场景？</h2><p>索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致性能下降，下面一些场景会发生索引失效。</p>
<p>使用OR条件：当使用OR连接多个条件，并且每个条件用到不同的索引列时，索引可能不会被使用。<br>使用非等值查询：当使用!&#x3D;或&lt;&gt;操作符时，索引可能不会被使用，特别是当非等值条件在WHERE子句的开始部分时。<br>对列进行类型转换： 如果在查询中对列进行类型转换，例如将字符列转换为数字或日期，索引可能会失效。<br>查询时发生隐式类型转换，等价于函数操作，索引失效。<br>使用LIKE语句：以通配符%开头的LIKE查询会导致索引失效。<br>函数或表达式：在列上使用函数或表达式作为查询条件，通常会导致索引失效。<br>表连接中的列类型不匹配： 如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。</p>
<p>索引失效的本质原因大多是：破坏了字段的“原始顺序或原始值”，从而使 MySQL 无法利用 B+ 树的区间定位能力。避免函数、类型转换、不连续匹配、模糊起始等操作，是保障索引生效的关键。</p>
<h2 id="什么是慢查询？原因是什么？可以怎么优化？"><a href="#什么是慢查询？原因是什么？可以怎么优化？" class="headerlink" title="什么是慢查询？原因是什么？可以怎么优化？"></a>什么是慢查询？原因是什么？可以怎么优化？</h2><p>慢查询指的是：在 MySQL 中执行时间超过设定阈值的 SQL 语句。<br>默认情况下，执行时间超过 long_query_time（如 1 秒） 的语句就会被记录到 慢查询日志（slow query log） 中，用于性能分析和优化。<br>二、慢查询的常见原因<br>查询语句复杂<br>包含多个表连接、嵌套子查询、大量计算逻辑等，执行计划复杂，耗时增加。<br>数据量过大<br>即使语句简单，扫描或处理的数据过多，也会导致查询慢。<br>缺少索引<br>没有合适的索引，MySQL 只能进行全表扫描，查询效率下降。<br>数据库设计不合理<br>表设计冗余、缺少范式、字段类型选择不当，都会影响查询效率。<br>并发冲突<br>多个查询争抢同一资源（如锁、IO），导致等待或阻塞。<br>硬件瓶颈<br>如磁盘 IO 慢、内存不足、CPU 占用高，也会造成查询响应变慢。</p>
<p>优化<br>使用慢查询日志找出慢 SQL<br>启用 slow_query_log，定位执行时间长的 SQL，结合执行计划分析。<br>使用 EXPLAIN 分析执行计划<br>查看是否命中索引、扫描行数、使用了临时表或排序等，指导优化方向。<br>优化 SQL 语句结构<br>减少子查询、避免 SELECT *、使用合适的 JOIN 顺序和 LIMIT 分页方式。<br>建立合适的索引<br>优先为查询频率高、区分度高的字段建立索引，合理利用联合索引和覆盖索引。<br>优化 ORDER BY + LIMIT<br>避免对大数据集排序后再分页，尽量通过索引排序或子查询裁剪数据量。<br>避免函数操作导致索引失效<br>比如不要写 WHERE DATE(create_time) &#x3D; …，改用范围查询方式。<br>合理设计表结构<br>分表分区、字段规范、范式设计，减小每条记录的数据体积。</p>
<h2 id="：undo-log、redo-log、binlog-有什么作用？"><a href="#：undo-log、redo-log、binlog-有什么作用？" class="headerlink" title="：undo log、redo log、binlog 有什么作用？"></a>：undo log、redo log、binlog 有什么作用？</h2><p>在 MySQL 的事务管理中，undo log、redo log 和 binlog 是三种关键的日志机制，它们作用不同，分别服务于事务的原子性、持久性和可恢复性。<br>🔹 1. Undo Log（回滚日志）<br>由 InnoDB 存储引擎生成；<br>作用是：在事务回滚时撤销已经执行的操作，保证事务的原子性（A）；<br>也用于 MVCC（多版本并发控制），帮助实现读已提交 &#x2F; 可重复读等隔离级别。<br>🔹 2. Redo Log（重做日志）<br>也是 InnoDB 层的日志，属于物理日志；<br>作用是：记录了数据页的物理修改操作，即“将什么页改成了什么内容”；<br>保证了事务的持久性（D），即使崩溃后，也可以通过 redo log 重做已提交事务的修改；<br>采用 WAL（Write Ahead Logging）预写日志机制：先写日志，再改数据页。<br>🔹 3. Binlog（归档日志 &#x2F; 二进制日志）<br>是由 MySQL Server 层生成的逻辑日志；<br>作用有两个：<br>主从复制：从库通过 binlog 同步主库数据；<br>增量备份和恢复：结合全量备份 + binlog，可以恢复数据到某个时间点；<br>binlog 是追加写入、不可修改的.</p>
<h2 id="MySQL-和-Redis-的区别是什么？"><a href="#MySQL-和-Redis-的区别是什么？" class="headerlink" title="MySQL 和 Redis 的区别是什么？"></a>MySQL 和 Redis 的区别是什么？</h2><ol>
<li>数据存储方式：<br>Redis：基于键值对，支持多种数据结构（如字符串、哈希、列表、集合、有序集合等），存储在内存中。<br>MySQL：关系型数据库，使用表来组织数据，存储在磁盘中。<br>🔹 2. 数据持久化：<br>Redis：主要存储数据在内存中，支持持久化机制（如 RDB 快照和 AOF 日志）将数据写入磁盘。<br>MySQL：数据持久化存储在磁盘中。<br>🔹 3. 查询语言：<br>Redis：使用自定义命令集，不支持 SQL 查询。<br>MySQL：使用标准的<strong>SQL（结构化查询语言）</strong>进行数据操作。<br>🔹 4. 性能和应用场景：<br>Redis：专注于高性能和低延迟，适用于高速、高并发的读写，特别是缓存系统、会话存储等场景。<br>MySQL：适用于复杂查询、事务处理和需要大规模数据存储的场景，尤其是在涉及关系数据和数据一致性时。<br>🔹 5. 使用场景：<br>Redis：适合缓存系统、实时数据处理、排行榜、消息队列等。<br>MySQL：适合需要复杂查询、多表关联、事务支持的应用，如电商系统、社交网络等。<br>🔹 6. 结合使用：<br>在实际应用中，许多系统同时使用 MySQL 和 Redis，Redis 用作缓存，加速读写性能，MySQL 用作持久化存储和处理复杂查询。</li>
</ol>
<h2 id="Redis有什么优缺点-为什么查询快"><a href="#Redis有什么优缺点-为什么查询快" class="headerlink" title="Redis有什么优缺点 为什么查询快"></a>Redis有什么优缺点 为什么查询快</h2><p>一、Redis 有什么优缺点？ 优点：<br>基于内存，读写速度极快，适合作为缓存中间层；<br>支持多种数据结构：如字符串、哈希、列表、集合、有序集合等；<br>丰富的应用场景：可以用于缓存、消息队列、排行榜、分布式锁等；<br>支持持久化机制：如 RDB 和 AOF，数据可落盘；<br>支持高可用和分布式部署：如主从复制、哨兵、集群等；<br>操作原子性强：命令是原子执行，保证数据一致性；<br>缺点：<br>基于内存存储，成本高：对内存容量要求大，不适合超大数据集；<br>数据容量受限于物理内存；<br>单线程核心处理：虽然高效，但部分复杂操作仍可能成为瓶颈；<br>不适合作为主数据库，更适合作为“辅助缓存”。<br>二、 为什么查询快<br>基于内存操作：<br>所有数据都在内存中，避免磁盘 I&#x2F;O 的瓶颈，访问速度是纳秒级。<br>高效数据结构设计：<br>Redis 为不同场景设计了专用的数据结构（如 ziplist, intset, skiplist 等）；<br>查询和操作复杂度低，如 O(1)、O(logN)。<br>单线程模型：<br>核心命令处理是单线程，没有线程上下文切换开销；<br>不存在资源竞争和加锁问题，每个命令执行快且安全。<br>I&#x2F;O 多路复用机制：<br>Redis 使用 epoll + 非阻塞 I&#x2F;O，能同时处理大量客户端连接而不阻塞。<br>✅ 总结一句话：<br>Redis 查询快，核心原因是：全内存 + 高效结构 + 单线程无锁 + I&#x2F;O 多路复用。<br>它的设计目标就是在高并发场景下保证“低延迟 + 高吞吐”。</p>
<h2 id="Redis的数据类型有哪些？"><a href="#Redis的数据类型有哪些？" class="headerlink" title="Redis的数据类型有哪些？"></a>Redis的数据类型有哪些？</h2><p>Redis 常见的五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)。<br>字符串STRING：存储字符串数据，最基本的数据类型。<br>哈希表HASH：存储字段和值的映射，用于存储对象。<br>列表LIST：存储有序的字符串元素列表。<br>集合SET：存储唯一的字符串元素，无序。<br>有序集合ZSET：类似于集合，但每个元素都关联一个分数，可以按分数进行排序。<br>Redis版本更新，又增加了几种数据类型，<br>BitMap: 存储位的数据结构，可以用于处理一些位运算操作。<br>HyperLogLog：用于基数估算的数据结构，用于统计元素的唯一数量。<br>GEO： 存储地理位置信息的数据结构。<br>Stream：专门为消息队列设计的数据类型</p>
<h2 id="Redis是单线程吗？为什么Redis能支持高并发？"><a href="#Redis是单线程吗？为什么Redis能支持高并发？" class="headerlink" title="Redis是单线程吗？为什么Redis能支持高并发？"></a>Redis是单线程吗？为什么Redis能支持高并发？</h2><p>一、核心结论：<br>Redis 的核心逻辑处理是单线程的（如命令解析、数据读写），但从 Redis 6.0 开始，部分 I&#x2F;O 操作使用多线程进行了优化。<br>✅ 二、为什么 Redis 采用单线程模型？<br>Redis 最初采用单线程（处理客户端命令）的原因主要有以下几点：<br>简化并发模型：<br>单线程避免了多线程编程中常见的锁竞争、数据同步等问题，程序逻辑更简单，稳定性更高。<br>内存操作快：<br>Redis 所有数据都在内存中操作，本身就非常快，单线程处理效率就足够高，不是瓶颈。<br>原子性天然保证：<br>同一时间只有一个命令在执行，天然具备原子性，简化了事务、并发控制的处理。<br>顺序执行有利于调试和可控性：<br>命令执行顺序可预测，系统行为更可控。<br>✅ 三、那 Redis 是完全单线程吗？<br>不是的，从 Redis 6.0 开始，引入了多线程的 I&#x2F;O 模块，主要优化的是：<br>连接建立<br>读写网络数据<br>协议解析前的准备工作<br>这部分耗时在高并发下影响大，使用多线程后，可以充分利用多核 CPU 资源，降低网络 I&#x2F;O 阻塞带来的开销。<br>⚠️ 注意：核心命令执行逻辑仍然是单线程的！<br>✅ 四、总结一句话：<br>Redis 是<strong>“单线程为主 + 多线程做 I&#x2F;O 辅助”的模型</strong>，<br>既保证了执行的简单与安全，又在 Redis 6.0 后实现了更好的性能优化。</p>
<h2 id="Redis的持久化方式有哪些"><a href="#Redis的持久化方式有哪些" class="headerlink" title="Redis的持久化方式有哪些"></a>Redis的持久化方式有哪些</h2><p>✅ 1. RDB（快照）持久化   (一个按时间保存 一个按命令记录)<br>方式：在某个时间点，将内存中的数据生成快照，保存为 .rdb 文件（二进制格式）。<br>触发时机：<br>手动执行 SAVE 或 BGSAVE 命令<br>或通过配置的保存策略自动触发（如 save 900 1）<br>优点：体积小、恢复快、适合全量备份<br>缺点：可能会丢失最近一次快照之后的数据（不实时）<br>✅ 2. AOF（Append Only File）日志持久化<br>方式：将 Redis 的每一条写命令（如 SET, DEL）以日志方式追加写入到 .aof 文件。<br>刷盘策略：<br>每次写入都同步（最安全但最慢）<br>每秒同步（默认）<br>操作系统控制刷盘（性能最好）<br>优点：数据更完整，丢失更少（几乎实时）<br>缺点：文件体积较大，恢复速度较慢<br>✅ 3. 混合持久化（Hybrid）<br>方式：从 Redis 4.0 开始，支持将 RDB 快照 + AOF 日志融合为一个 AOF 文件。<br>过程：先写入一个 RDB 格式的内存快照，然后继续以 AOF 方式记录写操作。<br>优点：同时具备 RDB 的快速恢复能力 + AOF 的数据完整性<br>✅ 总结一句话：<br>Redis 有 RDB 快照（按时间保存）、AOF 日志（按命令记录）和混合持久化三种机制，<br>实际使用中可以单独使用，也可以搭配使用以实现更高的数据可靠性。</p>
<h2 id="Redis-有什么优缺点？为什么-Redis-查询会比较快？"><a href="#Redis-有什么优缺点？为什么-Redis-查询会比较快？" class="headerlink" title="Redis 有什么优缺点？为什么 Redis 查询会比较快？"></a>Redis 有什么优缺点？为什么 Redis 查询会比较快？</h2><p>优点：<br>基于内存：读写速度非常快，适用于需要高性能的场景，如 缓存、消息队列、分布式锁 和 键值存储。<br>丰富的数据结构：支持字符串、哈希、列表、集合、有序集合等多种数据类型，方便处理不同的应用场景。<br>分布式特性：可以将数据分布在多个节点上，提高 可扩展性 和 可用性，并支持主从复制、哨兵和集群模式。<br>缺点：<br>受限于物理内存：由于数据存储在内存中，存储空间受到物理内存的限制，存储超大数据时不适合。<br>高内存成本：相比磁盘存储，内存成本较高，因此存储大量数据时需要付出较高的成本。</p>
<p>2 基于内存操作：Redis 数据完全存储在内存中，减少了磁盘 I&#x2F;O 操作，大幅提升了查询速度。<br>高效的数据结构：Redis 使用 专门设计的数据结构（如字符串、哈希、列表、集合等）优化了读写操作，提升了查询效率。<br>单线程模型：Redis 采用单线程处理请求，省去了上下文切换的开销，避免了多线程带来的资源竞争和死锁问题。<br>I&#x2F;O 多路复用：Redis 使用 I&#x2F;O 多路复用机制，可以同时监听多个请求，根据事件处理不同的客户端请求，减少了阻塞操作，提高了并发性能。</p>
<h2 id="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"><a href="#介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？" class="headerlink" title="介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？"></a>介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？</h2><p>缓存雪崩是指在某个时间点，大量缓存同时失效，导致请求直接访问数据库或其他后端系统，增加了系统负载。<br>对于缓存雪崩，可以通过合理设置缓存的过期时间，分散缓存失效时间点，或者采用永不过期的策略，再结合定期更新缓存。</p>
<p>缓存击穿是指一个缓存中不存在但是数据库中存在的数据，当有大量并发请求查询这个缓存不存在的数据时，导致请求直接访问数据库，增加数据库的负载。典型的场景是当一个缓存中的数据过期或被清理，而此时有大量请求访问这个缓存中不存在的数据，导致大量请求直接访问底层存储系统。<br>对于缓存击穿，可以采用<strong>互斥锁（例如分布式锁）</strong>或者在查询数据库前先检查缓存是否存在，如果不存在再允许查询数据库，并将查询结果写入缓存。</p>
<p>缓存穿透是指查询一个在缓存和数据库都不存在的数据，这个数据始终无法被缓存，导致每次请求都直接访问数据库，增加数据库的负载。典型的情况是攻击者可能通过构造不存在的 key 大量访问缓存，导致对数据库的频繁查询。<br>对于缓存穿透，可以采用布隆过滤器等手段来过滤掉恶意请求，或者在查询数据库前先进行参数的合法性校验。</p>
<h2 id="如何保证数据库和缓存的一致性"><a href="#如何保证数据库和缓存的一致性" class="headerlink" title="如何保证数据库和缓存的一致性"></a>如何保证数据库和缓存的一致性</h2><ol>
<li>Cache Aside（旁路缓存）<br>这是最常见的策略：<br>读操作：先查缓存，查不到再查数据库，然后回写到缓存；<br>写操作：先更新数据库，再删除缓存。<br>这样可以保证下次读取时缓存是最新的。<br>✅ 问题点： 如果并发出现一个写操作和一个读操作，可能出现：先更新数据库、还没删缓存，读操作查到旧值，之后才删缓存，这就会产生短时间的不一致。<br>✅ 解决方向：<br>加写操作锁；<br>异步延迟双删；<br>设置短期过期；<br>或者引入队列串行写。</li>
<li>Read&#x2F;Write Through（读&#x2F;写直通）<br>应用程序不直接操作数据库，而是通过缓存服务代理；<br>读操作如果缓存中没有，由缓存组件自动加载数据库并更新缓存（Read Through）；<br>写操作先更新缓存，再由缓存同步更新数据库（Write Through）。<br>✅ 特点：一致性比 Cache Aside 更强，操作对应用来说是透明的。</li>
<li>Write Behind（异步写）<br>写操作只更新缓存，不立即更新数据库；<br>缓存会异步、批量地把数据刷新到数据库。<br>✅ 优点：写操作性能非常高；<br>⚠️ 缺点：一致性较差，可能会造成数据丢失，比如系统异常崩溃还没来得及刷盘。<br>✅ 总结：<br>Cache Aside 是最常用的，适合对一致性要求没那么高的场景；<br>Read&#x2F;Write Through 一致性更强但实现复杂；<br>Write Behind 性能高但一致性最弱。<br>实际项目中，通常用 Cache Aside + 延迟双删&#x2F;分布式锁等手段 来平衡一致性与性能。</li>
</ol>
<p>✅ 金句总结版（便于快速记忆）<br>Cache Aside：查不到再查库，写完删缓存；<br>Read&#x2F;Write Through：缓存当代理，自动同步库；<br>Write Behind：先写缓存，再异步刷库，一致性差但性能高。</p>
<h2 id="静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量"><a href="#静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量" class="headerlink" title="静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量"></a>静态变量和全局变量、局部变量的区别、在内存上是怎么分布的静态局部变量</h2><p>静态变量、全局变量和局部变量的主要区别可以从三个方面来看：作用域、生命周期和内存分布。<br>局部变量的作用域只在函数或代码块内部，生命周期是随着函数的调用创建并结束后销毁，它们一般存储在栈区；<br>全局变量在整个程序中都可见，生命周期从程序启动一直到结束，存储在静态存储区；<br>静态变量和全局变量一样，生命周期是整个程序期间，但它的作用域可以是局部的（比如函数内部的静态变量），这种变量同样存储在静态区，但是只初始化一次，后续函数调用会记住它的值。<br>使用场景方面：<br>局部变量适合存储临时数据，比如循环计数器、计算结果等；<br>静态变量适合函数中需要保留上一次调用状态的场景，比如缓存某个值；<br>全局变量适合多个函数之间共享信息，但要注意封装性和可维护性。<br>总的来说，静态变量像是局部变量和全局变量的结合体：作用域是局部的，生命周期是全局的。</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>指针和引用的主要区别在于本质、初始化方式、可变性和用法。<br>指针是一个变量，存储另一个变量的地址，可以为空（比如设为 nullptr），也可以随时指向别的地址；<br>引用是变量的别名，定义时必须初始化，而且一旦绑定就不能再改为引用别的变量，也不能是空引用。<br>操作上，指针需要通过 * 解引用、通过 &amp; 取地址，而引用使用起来和变量本身一样，不需要额外操作符。<br>用途方面：<br>指针更灵活，适用于动态内存管理、数据结构操作（比如链表）；<br>引用更安全，常用于函数参数传递（特别是避免拷贝开销）或运算符重载等场景。<br>简单说，引用更像“语法糖”，更安全，但灵活性不如指针。</p>
<h2 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++内存分区"></a>C++内存分区</h2><p>栈区（Stack）：由编译器自动管理，存储局部变量和函数调用时的上下文，比如函数参数、返回地址等。特点是分配释放快，但空间较小。<br>堆区（Heap）：由程序员手动管理，用于动态分配内存，比如使用 new&#x2F;delete 或 malloc&#x2F;free。不及时释放可能造成内存泄漏。<br>全局&#x2F;静态区：用于存储全局变量和静态变量，这部分内存在程序整个生命周期内都存在。具体来说又可以细分为：<br>数据段：放初始化过的全局&#x2F;静态变量；<br>BSS 段：放未初始化的全局&#x2F;静态变量，系统会自动初始化为 0。</p>
<p>常量区：存放像字符串常量、const 修饰的全局变量等不可修改的数据，通常是只读的。<br>代码段：也叫 text segment，存放程序的机器指令，也就是代码本身，这部分一般是只读的。</p>
<h2 id="static关键字和const关键字的作用"><a href="#static关键字和const关键字的作用" class="headerlink" title="static关键字和const关键字的作用"></a>static关键字和const关键字的作用</h2><p>static 和 const 是 C++ 中两个常用的关键字，分别用于控制生命周期&#x2F;作用域和只读性。<br>🔹 static 的作用：<br>静态变量：在函数内部声明 static 变量，它只会初始化一次，生命周期直到程序结束，适合保存函数的状态；<br>类的静态成员变量：属于整个类而不是某个对象，所有对象共享同一份数据；<br>静态成员函数：在类内使用static关键字修饰的成员函数，所有对象共享同一个函数；静态成员函数只能访问静态成员变量；静态成员函数调用可以不需要通过创建类的实例，而是直接通过类名调用。<br>作用域控制：在全局或文件作用域中，static 还可以限制函数或变量只能在本文件中使用（编译单元私有）。<br>静态变量在多线程环境中要注意线程安全。</p>
<p>🔹 const 的作用：<br>const变量：定义不可修改的值，防止意外修改；<br>const成员函数：承诺不会修改对象的成员变量；<br>const指针：可以限定“指针的值”或“指向的对象”是只读的；<br>const 本质上强调“只读”，而且天然具有线程安全性。<br>static + const 可以组合使用<br>常用于类中的静态常量，比如定义全局配置信息，既不变又共享。</p>
<p>🔚 总结一句话：<br>static 控生命周期和作用域，const 控只读性；<br>一个管“活多久和谁能用”，一个管“能不能改”。</p>
<h2 id="常量指针和指针常量之间有什么区别"><a href="#常量指针和指针常量之间有什么区别" class="headerlink" title="常量指针和指针常量之间有什么区别"></a>常量指针和指针常量之间有什么区别</h2><p>常量指针”和 “指针常量”是两种不同的概念，它们的区别主要在于它们所指向的数据是否可以被修改，以及它们自己的值是否可以改变。<br>常量指针是指指针所指向的数据是常量，不能通过这个指针来修改它指向的数据。但是，指针本身的值（即它所指向的地址）是可以改变的。<br>指针常量是指指针本身的值是常量，一旦被初始化后就不能指向其他地址。但是，它所指向的数据是可以修改的（除非那个数据本身是常量）<br>也可以同时使用 const 关键字来定义一个指针，既是常量指针又是指针常量，即它所指向的数据不能被修改，同时指针本身的值也不能改变。<br>总结<br>常量指针：可以改变指针本身的值，但不能修改它所指向的数据。<br>指针常量：指针本身的值不能改变，但可以修改它所指向的数据（除非数据本身是常量）。</p>
<h2 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h2><p>在 C++ 中，struct 和 class 的本质是一样的，两者都可以有成员变量、成员函数、构造函数、继承和多态。<br>它们的主要区别在于默认访问权限和默认继承方式：<br>struct 默认的成员和继承是 public；<br>class 默认的成员和继承是 private。<br>其他方面，如是否能定义模板、是否能写成员函数、继承虚函数等，其实都是支持的。<br>使用习惯上：<br>struct 更多用于表示一些简单的数据结构，比如 POD（plain old data）类型，类似于 C 语言中的数据块；<br>class 更常用于真正的面向对象设计，比如封装、继承、多态等。<br>总结一句话：<br>struct 和 class 在 C++ 中功能几乎一样；<br>区别只在默认权限不同；<br>语义上通常用 struct 表示“数据”，用 class 表示“对象”。</p>
<h2 id="什么是智能指针-有哪几种智能指针"><a href="#什么是智能指针-有哪几种智能指针" class="headerlink" title="什么是智能指针 有哪几种智能指针"></a>什么是智能指针 有哪几种智能指针</h2><p>在 C++ 中，智能指针是一种自动管理动态内存的工具类，用于避免手动调用 delete 带来的内存泄漏或悬空指针问题。<br>智能指针会在对象生命周期结束时，自动释放所管理的内存资源。<br>C++11 起，标准库中提供了三种主要的智能指针：<br>✅ 1. std::unique_ptr —— 独占式智能指针<br>只能有一个 unique_ptr 拥有同一块内存资源（不可拷贝，只能移动）。<br>离开作用域时自动释放资源。<br>适合对象所有权唯一、不共享的场景，比如栈对象、局部资源等。<br>📌 关键词：独占、不可共享、资源唯一。<br>✅ 2. std::shared_ptr —— 引用计数型智能指针<br>多个 shared_ptr 可以共同指向同一个资源。<br>内部使用引用计数机制来记录有多少个指针在共享资源。<br>当最后一个 shared_ptr 被销毁时，才释放资源。<br>适合多个对象需要共享同一资源的场景。<br>📌 关键词：共享、引用计数、生命周期自动管理。<br>✅ 3. std::weak_ptr —— 弱引用智能指针<br>不拥有对象，仅作为 shared_ptr 的旁观者。<br>用于解决 shared_ptr 循环引用的问题，不会增加引用计数。<br>通常用于观察者模式或缓存系统中。<br>📌 关键词：不参与计数、解决循环引用、配合 shared_ptr 使用。<br>✅ 总结一句话：<br>智能指针让我们写 C++ 时不再担心手动释放内存：<br>unique_ptr 独占资源，shared_ptr 共享资源，weak_ptr 安全旁观。</p>
<h2 id="智能指针的原理"><a href="#智能指针的原理" class="headerlink" title="智能指针的原理"></a>智能指针的原理</h2><p>在 C++11 中，智能指针是一种自动管理内存资源的封装类模板，主要通过析构时释放资源 + 引用计数机制来避免内存泄漏。三种核心智能指针分别如下：<br>✅ 1. std::unique_ptr —— 独占式智能指针<br>核心原理：确保资源在任何时刻只被一个指针拥有。<br>实现方式：<br>禁用拷贝构造和拷贝赋值（&#x3D; delete）<br>提供移动构造和移动赋值，实现所有权转移<br>析构时自动调用 delete 释放资源<br>📌 特点：轻量、安全、无引用计数，适合独占资源的场景。<br>✅ 2. std::shared_ptr —— 引用计数式智能指针<br>核心原理：多个 shared_ptr 共享资源，通过引用计数决定何时释放。<br>实现方式：<br>每个资源对应一个控制块（control block）<br>控制块中包含：<br>资源指针<br>引用计数（use_count）<br>每次拷贝&#x2F;赋值引用计数+1，销毁&#x2F;重置引用计数-1<br>当引用计数为 0，资源与控制块一并销毁<br>📌 特点：适合多个对象共享同一资源的场景。<br>✅ 3. std::weak_ptr —— 非拥有型智能指针<br>核心原理：观察 shared_ptr 管理的资源，不增加引用计数。<br>实现方式：<br>weak_ptr 指向 shared_ptr 的控制块<br>不参与资源生命周期控制<br>使用 lock() 可临时转换为 shared_ptr 使用资源</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Person&gt; p = std::<span class="built_in">make_shared</span>&lt;Person&gt;();</span><br><span class="line">std::weak_ptr&lt;Person&gt; wp = p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> sp = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    sp-&gt;<span class="built_in">sayHello</span>();  <span class="comment">// ✅ 资源还在，临时用 shared_ptr 使用对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对象已经被释放，不能用了\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用途：用于解决 shared_ptr 的循环引用问题<br>📌 特点：轻量、安全，常用于缓存、观察者等非强依赖场景。<br>✅ 总结一句话：<br>unique_ptr 独占资源，不拷贝只转移；<br>shared_ptr 通过引用计数共享资源；<br>weak_ptr 观察资源，打破循环引用，防止内存泄漏。</p>
<h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h2><p>在 C++ 中，new 和 malloc 都可以用于动态内存分配，但它们在语法、类型安全、构造析构和异常处理等方面有明显区别。<br>一、语法层面：<br>new 是 C++ 的运算符，可以直接用于分配对象或对象数组。<br>malloc 是 C 语言的函数，需要包含 <cstdlib> 头文件，只负责分配一块原始内存。<br>二、类型安全：<br>new 是类型安全的，分配时会自动推导和返回正确类型的指针。<br>malloc 返回的是 void*，需要手动强制类型转换。<br>三、构造和析构行为：<br>new 分配内存的同时会自动调用构造函数，释放时用 delete，会自动调用析构函数。<br>malloc 只负责内存分配，不会调用构造函数，释放时用 free，也不会自动调用析构函数，如果是类对象，必须手动调用析构函数。<br>四、异常处理：<br>new 分配失败时会抛出 std::bad_alloc 异常。<br>malloc 分配失败时返回 NULL 指针，程序员需要手动判断。<br>五、内存管理机制：<br>new 和 delete 是由 C++ 编译器管理的，符合面向对象的语言特性。<br>malloc 和 free 是 C 标准库提供的，更底层，和编译器无关。<br>✅ 总结一句话：<br>new 提供类型安全、自动构造与析构，更符合 C++ 的设计理念；<br>malloc 更底层，仅适合手动内存管理，不建议在现代 C++ 中直接使用。</p>
<h2 id="delete和free的区别"><a href="#delete和free的区别" class="headerlink" title="delete和free的区别"></a>delete和free的区别</h2><p>在 C++ 中，delete 和 free 都可以用来释放动态内存，但它们的适用场景、语法行为和底层机制都有明显不同：<br>一、语法和来源<br>delete 是 C++ 的关键字，用于释放 new 分配的对象或数组。<br>free 是 C 语言的函数，定义在 <cstdlib>（或 &lt;stdlib.h&gt;）中，用于释放 malloc 分配的内存。<br>二、对象销毁行为<br>使用 delete 释放对象时，会自动调用析构函数，用于清理资源。<br>使用 free 只释放内存，不调用析构函数。如果释放 C++ 对象，需要手动调用析构函数后再 free。<br>三、数组处理方式<br>C++ 中，如果是数组，必须使用 delete[] 来释放；否则行为未定义。对应着new[]创建<br>C 中没有数组区分，所有 malloc 分配的内存都统一用 free 释放。<br>四、类型检查和安全性<br>delete 会进行类型检查，确保类型匹配。<br>free 不进行类型检查，参数为 void*，不感知实际类型。<br>五、返回值处理<br>delete 没有返回值，执行后指针仍然有效（需手动设为 nullptr）。<br>free 也没有返回值，释放失败时也不会提示，可能导致悬空指针。<br>⚠️ 注意：你原文说 “delete 之后指针会自动置为 nullptr” 是错误的，不会自动变为 nullptr，必须手动置空 👇</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;  <span class="comment">// 必须手动写</span></span><br></pre></td></tr></table></figure>
<p>✅ 总结一句话：<br>delete 是 C++ 专用，自动调用析构函数，类型安全；<br>free 是 C 风格，只释放内存，不会清理对象，不适合处理 C++ 对象。</p>
<h2 id="什么是内存泄漏，如何检测和防止"><a href="#什么是内存泄漏，如何检测和防止" class="headerlink" title="什么是内存泄漏，如何检测和防止"></a>什么是内存泄漏，如何检测和防止</h2><p>当程序在内存池中动态申请了一块内存而没有及时释放，这块内存就会一直处于占用状态，无法被其他操作使用，从而造成资源浪费。虽然这块内存并没有物理上“消失”，但由于程序无法再访问它，外界就认为这块内存“泄漏”了。<br>内存泄漏的常见原因包括：</p>
<ol>
<li>忘记释放内存<br>使用 new 或 malloc 分配内存后，没有使用 delete 或 free 进行释放。</li>
<li>.基类析构函数未定义为虚函数<br>当子类继承父类时，如果父类的析构函数不是 virtual，使用基类指针删除子类对象时不会调用子类析构函数，导致内存未正确释放。</li>
<li>野指针<br>指针被置为 nullptr 或指向其他地址后，丢失了对原先动态分配内存的引用，导致无法释放。</li>
<li>循环引用<br>使用引用计数智能指针（如 std::shared_ptr）时，如果两个对象互相持有对方的 shared_ptr，会导致引用计数无法归零，从而内存无法释放。</li>
<li>释放方式不匹配<br>使用 delete 释放由 new[] 分配的内存，或使用 delete[] 释放由 new 分配的内存，会导致未定义行为，可能引发内存泄漏。</li>
<li>资源未释放<br>对于文件、网络连接等系统资源，如果没有正确关闭，虽然不属于严格的内存泄漏，但也会占用资源，可能导致资源耗尽。</li>
</ol>
<h3 id="检测内存泄漏的方法："><a href="#检测内存泄漏的方法：" class="headerlink" title="检测内存泄漏的方法："></a>检测内存泄漏的方法：</h3><p>可使用以下工具进行检测：<br>Valgrind（Linux 平台）瓦尔格赖（德）<br>AddressSanitizer（跨平台，GCC&#x2F;Clang 支持）啊-dress 三尼-taɪ-zər<br>Visual Studio 内存诊断工具（Windows 平台）</p>
<h3 id="如何防止内存泄漏："><a href="#如何防止内存泄漏：" class="headerlink" title="如何防止内存泄漏："></a>如何防止内存泄漏：</h3><ol>
<li>使用智能指针<br>优先使用 std::unique_ptr 或 std::shared_ptr 来自动管理内存，避免手动释放。</li>
<li>手动释放资源时要谨慎<br>对于必须手动分配的内存，确保在不再需要时及时释放。</li>
<li>使用内存检测工具<br>在开发和测试阶段，定期使用内存检测工具，及时发现潜在问题。</li>
</ol>
<h2 id="什么是野指针"><a href="#什么是野指针" class="headerlink" title="什么是野指针"></a>什么是野指针</h2><p><strong>野指针</strong>是指“指向已经被释放或无效内存地址的指针”。在 C 和 C++ 这类允许直接操作内存的语言中，如果指针没有被正确初始化，或者它所指<code>向的内存已经被释放，那么这个指针就成为了野指针。</code></p>
<p>使用野指针可能会导致程序崩溃、数据损坏，甚至出现不可预测的行为。</p>
<hr>
<h2 id="哪些情况会产生野指针？"><a href="#哪些情况会产生野指针？" class="headerlink" title="哪些情况会产生野指针？"></a>哪些情况会产生野指针？</h2><ol>
<li><p><strong>释放后未置空指针</strong><br>使用 <code>delete</code> 或 <code>free</code> 释放内存后，如果没有将指针设置为 <code>nullptr</code>，指针仍然指向一块无效内存。</p>
</li>
<li><p><strong>返回局部变量的指针</strong><br>如果一个函数返回了指向其局部变量的指针，那么函数返回后这些局部变量就失效了，返回的指针就成了野指针。</p>
</li>
<li><p><strong>越界访问</strong><br>指针访问超过其合法内存范围，也可能导致指向无效内存，从而变成野指针。</p>
</li>
<li><p><strong>函数参数指针被释放</strong><br>如果一个函数内部错误地释放了通过参数传进来的指针，那么该指针在外部就变成了野指针。</p>
</li>
</ol>
<hr>
<h2 id="如何避免野指针？"><a href="#如何避免野指针？" class="headerlink" title="如何避免野指针？"></a>如何避免野指针？</h2><ul>
<li>在释放内存后，**将指针设置为 <code>nullptr</code>**，避免误用。</li>
<li><strong>不要返回局部变量的指针</strong>，因为它们的生命周期会在函数返回后结束。</li>
<li><strong>使用智能指针</strong>（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>），让资源管理自动化，避免手动释放。</li>
<li><strong>注意指针参数的生命周期管理</strong>，特别要避免在函数内部释放外部传入的资源。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>野指针是“指着不该再用的内存”，它隐蔽又危险，<strong>规范使用指针和资源管理机制</strong>是避免它的关键。</p>
</blockquote>
<h2 id="C-面向对象的三大特性"><a href="#C-面向对象的三大特性" class="headerlink" title="C++面向对象的三大特性"></a>C++面向对象的三大特性</h2><p>一、什么是面向对象？<br>面向对象编程（OOP）是 C++ 的核心思想，它通过“对象”组织数据和行为，通过对象间的交互完成任务。<br>核心特性有 三大支柱：封装、继承、多态。<br>二、三大特性详解<br>1️⃣ 封装（Encapsulation）<br>定义：把数据和操作数据的方法封装到一个类中，对外只暴露必要接口。<br>目的：保护内部数据，防止被随意访问或修改，提高代码的安全性和稳定性。<br>关键词：private &#x2F; public、访问权限、接口与实现分离。<br>📌 一句话总结：封装让对象像“黑盒子”，外部只能通过接口与之交互。<br>2️⃣ 继承（Inheritance）<br>定义：一个类（子类）可以继承另一个类（父类）的属性和行为。<br>作用：代码复用 + 建立层次结构 + 易于扩展和维护。<br>关键词：class Derived : public Base<br>📌 一句话总结：继承让“旧类”变成“新类”的起点，写一次复用多次。<br>3️⃣ 多态（Polymorphism）<br>定义：相同的操作作用在不同对象上，表现出不同的行为。<br>实现方式：主要通过虚函数（virtual）+ 指针或引用 + 重写（override）<br>区分：<br>编译时多态：函数重载 &#x2F; 运算符重载<br>运行时多态：虚函数 + 动态绑定<br>📌 一句话总结：多态让“统一的调用”变成“不同的响应”。<br>三、收尾升华（面试通杀）<br>所以，C++ 通过封装保证模块安全，通过继承实现代码复用，通过多态提升扩展能力，这三者构成了面向对象编程的核心基础。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>重载和重写是两种不同的概念，它们都用于实现多态性，但方式和使用场景有所不同。<br>重载：在同一个类或命名空间中，声明多个同名函数， 但是参数列表不同。编译器根据参数的类型、数量或顺序来区分不同的函数。<br>重写：重写发生在继承体系中，在子类中，声明一个与父类中虚函数具有相同名称、相同参数列表和相同返回类型的函数，并在子类函数前加上 override 关键字。<br>区别：<br>作用域：重载发生在同一个作用域内，而重写发生在继承体系中。<br>参数列表：对于重载的函数，参数列表必须不同；对于重写的函数，参数列表必须与被重写的函数完全相同。<br>返回类型：重载函数的返回类型可以不同，但重写函数的返回类型必须与被重写的函数相同（或与之兼容，C++中称为协变返回类型）。<br>虚函数：重写通常与虚函数一起使用，以实现运行时多态性；而重载是编译时多态性，由编译器在编译期间确定调用哪个函数。<br>关键字：重写函数可以使用 override 关键字，明确指出该函数是对父类虚函数的重写。</p>
<h2 id="C-怎么实现多态"><a href="#C-怎么实现多态" class="headerlink" title="C++怎么实现多态"></a>C++怎么实现多态</h2><p>C++ 的多态分为两类：</p>
<ul>
<li><strong>编译时多态</strong>（也被称为静态多态）</li>
<li><strong>运行时多态</strong>（也被称为动态多态）</li>
</ul>
<hr>
<h2 id="一、编译时多态"><a href="#一、编译时多态" class="headerlink" title="一、编译时多态"></a>一、编译时多态</h2><p>编译时多态在 <strong>编译期间</strong> 就确定了具体的函数或类型调用方式，由编译器根据函数的签名或模板实例化选择正确的函数或实例。</p>
<h3 id="常见实现方式："><a href="#常见实现方式：" class="headerlink" title="常见实现方式："></a>常见实现方式：</h3><ul>
<li><p><strong>函数重载（Function Overloading）</strong>：<br>允许在同一作用域内声明多个同名函数，只要它们的参数列表不同。</p>
</li>
<li><p><strong>运算符重载（Operator Overloading）</strong>：<br>允许为自定义类型定义或修改运算符的行为。</p>
</li>
<li><p><strong>模板（Templates）</strong>：<br>允许创建泛型类和函数，使代码能够适用于多种数据类型。</p>
</li>
</ul>
<hr>
<h2 id="二、运行时多态"><a href="#二、运行时多态" class="headerlink" title="二、运行时多态"></a>二、运行时多态</h2><p>运行时多态主要通过<strong>虚函数和抽象类</strong>实现。父类中定义虚函数，子类中重写该虚函数，通过基类指针或引用在运行时调用时，由程序根据对象实际类型决定调用哪个函数。</p>
<h3 id="常见实现方式：-1"><a href="#常见实现方式：-1" class="headerlink" title="常见实现方式："></a>常见实现方式：</h3><ul>
<li><p><strong>虚函数（Virtual Functions）</strong>：<br>在基类中定义虚函数，派生类可以重写这些函数，实现多态行为。</p>
</li>
<li><p><strong>抽象类（Abstract Classes）</strong>：<br>包含至少一个纯虚函数的类，不能被实例化，但可以作为其他类的基类。</p>
</li>
</ul>
<hr>
<h2 id="三、运行时多态的实现原理"><a href="#三、运行时多态的实现原理" class="headerlink" title="三、运行时多态的实现原理"></a>三、运行时多态的实现原理</h2><p>运行时多态依赖以下两个机制：</p>
<ul>
<li><strong>虚函数表（vtable）</strong></li>
<li><strong>虚函数指针（vptr）</strong></li>
</ul>
<h3 id="具体说明："><a href="#具体说明：" class="headerlink" title="具体说明："></a>具体说明：</h3><ul>
<li>当类中包含虚函数时，编译器会为该类创建一个虚函数表（vtable），表中记录所有虚函数的地址。</li>
<li>每个对象中包含一个指向虚函数表的指针（vptr）。</li>
<li>子类的虚函数表会继承父类的表，并将被重写的函数地址覆盖原有的对应项。</li>
<li>当通过基类指针或引用调用虚函数时，程序在运行时会通过 vptr 定位到 vtable，并调用实际对象对应的函数，从而实现多态。</li>
</ul>
<hr>
<h2 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h2><p>虚函数和纯虚函数都用于实现 <strong>多态性（Polymorphism）</strong>。</p>
<hr>
<h2 id="一、虚函数（Virtual-Function）"><a href="#一、虚函数（Virtual-Function）" class="headerlink" title="一、虚函数（Virtual Function）"></a>一、虚函数（Virtual Function）</h2><ul>
<li>在普通成员函数前加上 <code>virtual</code> 关键字。</li>
<li>在<strong>基类中声明</strong>，可以在<strong>派生类中被重写（override）</strong>。</li>
<li>可以<strong>有实现</strong>（即函数体）：<ul>
<li>派生类可以选择是否提供自己的实现；</li>
<li>也可以使用基类的默认实现。</li>
</ul>
</li>
<li>通过虚函数，可以在<strong>基类指针或引用中实现动态绑定</strong>，<br>即在运行时决定调用哪一个类中的函数实现（运行时多态）。</li>
</ul>
<hr>
<h2 id="二、纯虚函数（Pure-Virtual-Function）"><a href="#二、纯虚函数（Pure-Virtual-Function）" class="headerlink" title="二、纯虚函数（Pure Virtual Function）"></a>二、纯虚函数（Pure Virtual Function）</h2><ul>
<li>在虚函数声明后加上 <code>= 0</code>，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">只有函数声明，没有实现。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当一个类中包含至少一个纯虚函数，它就成为了一个抽象类（Abstract Class）：</p>
<p>抽象类不能被实例化；</p>
<p>但可以声明该类型的指针或引用；</p>
<p>通常用于定义接口，要求派生类提供具体实现。</p>
<h2 id="三、区别对比"><a href="#三、区别对比" class="headerlink" title="三、区别对比"></a>三、区别对比</h2><ol>
<li>是否有实现<br>虚函数：提供函数声明和默认实现。<br>纯虚函数：只有函数声明，没有具体实现。</li>
<li>派生类是否必须重写<br>虚函数：派生类可以选择是否重写。<br>纯虚函数：派生类必须提供实现，否则该派生类也变成抽象类。</li>
<li>是否可实例化<br>包含虚函数的类：只要不含纯虚函数，可以被实例化。<br>包含纯虚函数的类：是抽象类，不能被实例化。</li>
<li>使用目的<br>虚函数：用于提供可被重写的默认方法，实现多态。<br>纯虚函数：用于定义接口规范，强制派生类必须实现。</li>
<li>动态绑定行为<br>虚函数：支持动态绑定。<br>纯虚函数：本身不参与动态绑定（因为没有实现），但作为接口的组成部分影响多态性。</li>
</ol>
<h2 id="四、总结表格"><a href="#四、总结表格" class="headerlink" title="四、总结表格"></a>四、总结表格</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>虚函数</th>
<th>纯虚函数</th>
</tr>
</thead>
<tbody><tr>
<td>是否有实现</td>
<td>有默认实现</td>
<td>无实现（只有声明）</td>
</tr>
<tr>
<td>是否必须重写</td>
<td>可选</td>
<td>必须重写</td>
</tr>
<tr>
<td>是否可实例化</td>
<td>可实例化</td>
<td>不可实例化（抽象类）</td>
</tr>
<tr>
<td>使用目的</td>
<td>提供默认行为，支持多态</td>
<td>定义接口规范，强制实现</td>
</tr>
<tr>
<td>是否支持多态</td>
<td>支持</td>
<td>本身不绑定，但影响类的多态性</td>
</tr>
</tbody></table>
<h2 id="虚函数是怎么实现的"><a href="#虚函数是怎么实现的" class="headerlink" title="虚函数是怎么实现的"></a>虚函数是怎么实现的</h2><p>一、核心结论一句话：<br>虚函数是通过“虚函数表（vtable）”和“虚指针（vptr）”机制实现的动态绑定。<br>二、实现机制逐步拆解<br>✅ 1. 虚函数表（vtable）是什么？<br>编译器为含有虚函数的类生成一个 虚函数表。<br>它本质上是一个函数指针数组，每个元素指向类的一个虚函数实现。<br>✅ 2. 虚指针（vptr）是什么？<br>编译器会在类的每个对象中插入一个隐藏指针（vptr）。<br>这个指针指向对象所属类的 vtable。<br>✅ 3. 调用过程（动态绑定）<br>当通过 基类指针或引用 调用虚函数时：<br>程序通过对象的 vptr 找到其对应的 vtable<br>在 vtable 中查找对应函数的指针<br>然后调用该函数（实现动态派发）<br>三、重写虚函数的处理<br>当派生类重写基类的虚函数时：<br>编译器会在派生类的 vtable 中用新的函数地址替换基类的对应项。<br>所以用基类指针指向派生类对象时，仍然能调用到派生类的版本。<br>四、总结口诀：<br>每个类有一个虚表（vtable），<br>每个对象有一个虚指针（vptr），<br>虚表里放的是虚函数地址，<br>调用虚函数就靠它们动态派发。<br>五、面试收尾升华一句话：<br>所以虚函数底层就是通过 vtable 和 vptr 实现的多态机制，解决了运行时动态选择函数版本的问题，也是 C++ 实现面向对象多态性的关键。</p>
<h2 id="什么是虚函数表"><a href="#什么是虚函数表" class="headerlink" title="什么是虚函数表"></a>什么是虚函数表</h2><p>一、核心定义<br>虚函数表（vtable）是 C++ 实现运行时多态（动态绑定）的关键机制。<br>它是一个由函数指针组成的表，用于在运行时决定调用哪个虚函数版本。<br>二、虚函数表的组成和作用<br>✅ 内容：存的是类中所有虚函数的地址（函数指针数组）。<br>✅ 目的：当我们通过基类指针或引用调用虚函数时，能够根据对象的真实类型，调用正确的派生类函数实现。<br>三、工作原理（一步步理解）<br>1️⃣ 编译器生成虚表<br>只要类里有至少一个虚函数，编译器就会为这个类生成一张虚函数表。<br>每个虚函数在表里占一个“入口”，表项指向函数实现。<br>2️⃣ 每个对象含有一个隐藏的虚函数表指针（vptr）<br>vptr 是一个隐藏成员变量，它指向该对象所属类的虚函数表。<br>每个对象都有自己的 vptr，但它们一般共享同一张虚表。<br>3️⃣ 调用虚函数时的过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">f</span>(); <span class="comment">// 实际调用 Derived::f()，不是 Base::f()</span></span><br></pre></td></tr></table></figure>
<p>调用流程：<br>通过 ptr 找到对象的 vptr<br>vptr 指向虚表<br>在虚表中查找 f() 对应的地址<br>跳转到 Derived::f() 执行<br>四、总结记忆口诀<br>虚函数进表，<br>每类一表，<br>每个对象一个指针（vptr）指向它；<br>调用走表，<br>动态派发靠它查！<br>五、面试结尾升华一句话<br>所以虚函数表是 C++ 实现面向对象多态性的核心机制，它让程序能够在运行时根据对象的真实类型调用正确的函数，实现动态绑定。</p>
<h2 id="什么是构造函数和析构函数？构造函数、析构函数可以是虚函数嘛"><a href="#什么是构造函数和析构函数？构造函数、析构函数可以是虚函数嘛" class="headerlink" title="什么是构造函数和析构函数？构造函数、析构函数可以是虚函数嘛"></a>什么是构造函数和析构函数？构造函数、析构函数可以是虚函数嘛</h2><h2 id="一、构造函数（Constructor）"><a href="#一、构造函数（Constructor）" class="headerlink" title="一、构造函数（Constructor）"></a>一、构造函数（Constructor）</h2><p>构造函数是在创建对象时<strong>自动调用</strong>的成员函数，作用是：</p>
<ul>
<li>初始化成员变量；</li>
<li>分配资源（如内存）；</li>
<li>执行其他必要的初始化操作。</li>
</ul>
<h3 id="📌-特点"><a href="#📌-特点" class="headerlink" title="📌 特点"></a>📌 特点</h3><ul>
<li>函数名必须与类名<strong>完全相同</strong>；</li>
<li>没有返回类型（甚至不能写 <code>void</code>）；</li>
<li>可以<strong>重载</strong>（即：可以定义多个构造函数）；</li>
<li>如果没有定义，编译器会自动生成一个<strong>默认构造函数</strong>；</li>
<li><strong>构造函数不能是虚函数</strong>。</li>
</ul>
<hr>
<h2 id="❗-为什么构造函数不能是虚函数？"><a href="#❗-为什么构造函数不能是虚函数？" class="headerlink" title="❗ 为什么构造函数不能是虚函数？"></a>❗ 为什么构造函数不能是虚函数？</h2><ol>
<li><strong>构造函数在对象创建前就需要调用</strong>，而虚函数的调用机制依赖于对象的虚函数表（vtable），这个表是在对象构造完成之后才设置的；</li>
<li><strong>虚函数是运行时绑定</strong>，而构造函数需要在<strong>编译期就确定</strong>；</li>
<li>如果允许构造函数是虚的，创建派生类对象时就可能存在<strong>多重候选构造函数</strong>，造成<strong>调用二义性</strong>；</li>
<li>构造函数常用于分配资源，如内存、文件句柄等；若无法确定调用哪个构造函数，就无法正确初始化资源；</li>
<li>C++中，<strong>基类构造函数总在派生类构造函数之前调用</strong>，若构造函数为虚的，就无法保证这种顺序；</li>
<li>构造函数是对象生命周期的<strong>起点</strong>，虚函数在生命周期内起作用，二者在时机上不兼容。</li>
</ol>
<hr>
<h2 id="二、析构函数（Destructor）"><a href="#二、析构函数（Destructor）" class="headerlink" title="二、析构函数（Destructor）"></a>二、析构函数（Destructor）</h2><p>析构函数是在对象生命周期结束时<strong>自动调用</strong>的函数，主要负责：</p>
<ul>
<li>释放对象持有的资源（如堆内存）；</li>
<li>执行清理操作。</li>
</ul>
<h3 id="📌-特点-1"><a href="#📌-特点-1" class="headerlink" title="📌 特点"></a>📌 特点</h3><ul>
<li>函数名为 <code>~类名</code>；</li>
<li><strong>没有参数</strong>，也没有返回值；</li>
<li>可以定义，也可以使用编译器自动生成的默认析构函数；</li>
<li><strong>析构函数可以是虚函数</strong>。</li>
</ul>
<hr>
<h2 id="✅-为什么析构函数可以（而且应当）是虚函数？"><a href="#✅-为什么析构函数可以（而且应当）是虚函数？" class="headerlink" title="✅ 为什么析构函数可以（而且应当）是虚函数？"></a>✅ 为什么析构函数可以（而且应当）是虚函数？</h2><ul>
<li>析构函数作为多态类的成员，<strong>必须是虚的</strong>，才能在通过基类指针删除派生类对象时，<strong>正确调用派生类的析构函数</strong>；</li>
<li>如果不是虚析构，只有基类的析构函数会被调用，派生类资源不会被释放，<strong>可能导致资源泄漏</strong>。</li>
</ul>
<hr>
<h2 id="三、经典示例"><a href="#三、经典示例" class="headerlink" title="三、经典示例"></a>三、经典示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived constructor\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 正确释放基类和派生类资源（因为Base析构是virtual的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Base constructor<br>Derived constructor<br>Derived destructor<br>Base destructor</p>
<h2 id="C-构造函数有哪些"><a href="#C-构造函数有哪些" class="headerlink" title="C++构造函数有哪些"></a>C++构造函数有哪些</h2><p>在C++中，构造函数有几种不同的类型，每种都有其特定的作用：</p>
<p>默认构造函数：没有参数的构造函数，用于创建对象的默认实例。<br>参数化构造函数：带参数的构造函数，允许在创建对象时初始化成员变量。<br>拷贝构造函数：以同一类的实例为参数的构造函数，用于复制已有对象。<br>移动构造函数：以同一类的实例的右值引用为参数，用于利用即将销毁的对象的资源。<br>转换构造函数：允许将其他类型或值隐式转换为当前类类型的实例。<br>委托构造函数：一个构造函数调用另一个构造函数来完成初始化，可以是同一个类的其他构造函数。<br>初始化列表构造函数：使用成员初始化列表来初始化成员变量，这是最高效的初始化方式。<br>常量构造函数：声明为const的构造函数，可以用于创建常量对象。<br>⚠️ 注意：你提到的“常量构造函数”其实并不存在。构造函数不能声明为 const，因为它会修改对象状态。<br>🧠 正确说法应该是：构造函数可以构造出 const 对象，但自身不能是 const 的。<br>📌 示例：<br>const A a(5);  &#x2F;&#x2F; OK，构造出来的对象是 const 的<br>constexpr构造函数：允许在编译时初始化对象，用于定义和初始化字面量类型的对象。<br>每种构造函数的使用场景不同，例如：</p>
<h2 id="默认构造函数用于快速创建对象，而不需要显式提供任何初始化参数。参数化构造函数提供了灵活性，允许在创建对象时定制其状态。拷贝构造函数和移动构造函数分别用于对象的复制和移动，是实现资源管理的关键。转换构造函数和委托构造函数提供了更灵活的对象初始化方式。初始化列表构造函数是C-中推荐的成员初始化方式，因为它可以提高效率。-常用容器有哪些C-STL-提供了多种容器，主要分为三类：序列容器、关联容器-和-容器适配器。"><a href="#默认构造函数用于快速创建对象，而不需要显式提供任何初始化参数。参数化构造函数提供了灵活性，允许在创建对象时定制其状态。拷贝构造函数和移动构造函数分别用于对象的复制和移动，是实现资源管理的关键。转换构造函数和委托构造函数提供了更灵活的对象初始化方式。初始化列表构造函数是C-中推荐的成员初始化方式，因为它可以提高效率。-常用容器有哪些C-STL-提供了多种容器，主要分为三类：序列容器、关联容器-和-容器适配器。" class="headerlink" title="默认构造函数用于快速创建对象，而不需要显式提供任何初始化参数。参数化构造函数提供了灵活性，允许在创建对象时定制其状态。拷贝构造函数和移动构造函数分别用于对象的复制和移动，是实现资源管理的关键。转换构造函数和委托构造函数提供了更灵活的对象初始化方式。初始化列表构造函数是C++中推荐的成员初始化方式，因为它可以提高效率。## 常用容器有哪些C++ STL 提供了多种容器，主要分为三类：序列容器、关联容器 和 容器适配器。"></a>默认构造函数用于快速创建对象，而不需要显式提供任何初始化参数。<br>参数化构造函数提供了灵活性，允许在创建对象时定制其状态。<br>拷贝构造函数和移动构造函数分别用于对象的复制和移动，是实现资源管理的关键。<br>转换构造函数和委托构造函数提供了更灵活的对象初始化方式。<br>初始化列表构造函数是C++中推荐的成员初始化方式，因为它可以提高效率。<br>## 常用容器有哪些<br>C++ STL 提供了多种容器，主要分为三类：<strong>序列容器</strong>、<strong>关联容器</strong> 和 <strong>容器适配器</strong>。</h2><h2 id="一、序列容器（Sequence-Containers）"><a href="#一、序列容器（Sequence-Containers）" class="headerlink" title="一、序列容器（Sequence Containers）"></a>一、序列容器（Sequence Containers）</h2><p>按元素插入顺序存储，常用于线性结构。</p>
<ul>
<li>**<code>std::vector</code>**：动态数组，支持快速随机访问。</li>
<li>**<code>std::deque</code>**：双端队列，支持从两端快速插入和删除。</li>
<li>**<code>std::list</code>**：双向链表，适合频繁的插入和删除操作。</li>
<li>**<code>std::forward_list</code>**：单向链表，仅支持向前遍历，内存开销更小。</li>
<li>**<code>std::array</code>**：固定大小的数组，大小在编译时确定，内存为静态分配。</li>
</ul>
<hr>
<h2 id="二、关联容器（Associative-Containers）"><a href="#二、关联容器（Associative-Containers）" class="headerlink" title="二、关联容器（Associative Containers）"></a>二、关联容器（Associative Containers）</h2><p>基于平衡树（如红黑树）或哈希表，提供高效的查找和排序。</p>
<h3 id="🌲-有序容器（基于红黑树）："><a href="#🌲-有序容器（基于红黑树）：" class="headerlink" title="🌲 有序容器（基于红黑树）："></a>🌲 有序容器（基于红黑树）：</h3><ul>
<li>**<code>std::set</code>**：存储唯一元素，自动排序（默认升序）。</li>
<li>**<code>std::multiset</code>**：允许有重复元素，自动排序。</li>
<li>**<code>std::map</code>**：键值对映射，键唯一，自动排序。</li>
<li>**<code>std::multimap</code>**：允许多个相同键的键值对。</li>
</ul>
<h3 id="🔢-无序容器（基于哈希表）："><a href="#🔢-无序容器（基于哈希表）：" class="headerlink" title="🔢 无序容器（基于哈希表）："></a>🔢 无序容器（基于哈希表）：</h3><ul>
<li>**<code>std::unordered_set</code>**：哈希集合，元素唯一，平均查找时间复杂度 O(1)。</li>
<li>**<code>std::unordered_map</code>**：哈希映射，存储键值对，键唯一，无序。</li>
</ul>
<hr>
<h2 id="三、容器适配器（Container-Adapters）"><a href="#三、容器适配器（Container-Adapters）" class="headerlink" title="三、容器适配器（Container Adapters）"></a>三、容器适配器（Container Adapters）</h2><p>对底层容器进行封装，提供特定接口行为。</p>
<ul>
<li>**<code>std::stack</code>**：栈，后进先出（LIFO）。</li>
<li>**<code>std::queue</code>**：队列，先进先出（FIFO）。</li>
<li>**<code>std::priority_queue</code>**：优先队列，元素按优先级自动排序（默认大顶堆）。</li>
</ul>
<hr>
<h2 id="💡-小结记忆口诀（可选）"><a href="#💡-小结记忆口诀（可选）" class="headerlink" title="💡 小结记忆口诀（可选）"></a>💡 小结记忆口诀（可选）</h2><ul>
<li><strong>vector &#x2F; deque &#x2F; list</strong> 是拿来“排队”的；</li>
<li><strong>set &#x2F; map</strong> 是用来“查找”的；</li>
<li><strong>stack &#x2F; queue &#x2F; priority_queue</strong> 是用来“排流程”的；</li>
<li><strong>unordered_xxx</strong> 是查找更快但不排序的版本。</li>
</ul>
<h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><h2 id="一、浅拷贝（Shallow-Copy）"><a href="#一、浅拷贝（Shallow-Copy）" class="headerlink" title="一、浅拷贝（Shallow Copy）"></a>一、浅拷贝（Shallow Copy）</h2><h3 id="✅-定义："><a href="#✅-定义：" class="headerlink" title="✅ 定义："></a>✅ 定义：</h3><p>浅拷贝<strong>仅复制对象本身的值</strong>，不复制对象内部<strong>指向的动态内存</strong>，多个对象共享同一份资源。</p>
<h3 id="🔧-实现方式："><a href="#🔧-实现方式：" class="headerlink" title="🔧 实现方式："></a>🔧 实现方式：</h3><ul>
<li>默认的复制构造函数</li>
<li>默认的赋值运算符 <code>=</code></li>
</ul>
<h3 id="⭐-特点："><a href="#⭐-特点：" class="headerlink" title="⭐ 特点："></a>⭐ 特点：</h3><ul>
<li>拷贝快，只复制基本成员变量。</li>
<li>如果包含指针，多个对象会指向同一块内存，可能出现：<ul>
<li><strong>悬空指针（Dangling Pointer）</strong></li>
<li><strong>重复释放内存（Double Free）</strong></li>
</ul>
</li>
<li>易出 bug，资源管理不安全。</li>
</ul>
<hr>
<h2 id="二、深拷贝（Deep-Copy）"><a href="#二、深拷贝（Deep-Copy）" class="headerlink" title="二、深拷贝（Deep Copy）"></a>二、深拷贝（Deep Copy）</h2><h3 id="✅-定义：-1"><a href="#✅-定义：-1" class="headerlink" title="✅ 定义："></a>✅ 定义：</h3><p>深拷贝不仅复制对象的成员变量，还会<strong>重新分配内存并复制指针指向的内容</strong>，实现完全独立的副本。</p>
<h3 id="🔧-实现方式：-1"><a href="#🔧-实现方式：-1" class="headerlink" title="🔧 实现方式："></a>🔧 实现方式：</h3><ul>
<li>需要<strong>自定义复制构造函数</strong>和<strong>赋值运算符</strong></li>
<li>使用 <code>new</code> 手动分配内存，并进行内容拷贝</li>
</ul>
<h3 id="⭐-特点：-1"><a href="#⭐-特点：-1" class="headerlink" title="⭐ 特点："></a>⭐ 特点：</h3><ul>
<li>拷贝慢，因为涉及内存分配和内容复制；</li>
<li>但更<strong>安全可靠</strong>，每个对象管理自己的资源，避免资源冲突；</li>
<li>不会出现共享内存导致的问题。</li>
</ul>
<hr>
<h2 id="三、对比总结"><a href="#三、对比总结" class="headerlink" title="三、对比总结"></a>三、对比总结</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>浅拷贝</th>
<th>深拷贝</th>
</tr>
</thead>
<tbody><tr>
<td>拷贝内容</td>
<td>对象本身（指针地址）</td>
<td>对象本身 + 指针所指内容</td>
</tr>
<tr>
<td>内存使用</td>
<td>多个对象共享同一份资源</td>
<td>每个对象独立拥有一份资源</td>
</tr>
<tr>
<td>性能</td>
<td>拷贝快</td>
<td>拷贝慢</td>
</tr>
<tr>
<td>安全性</td>
<td>可能导致悬空指针、重复释放等问题</td>
<td>安全，资源独立管理</td>
</tr>
<tr>
<td>是否需要自定义构造函数</td>
<td>不需要</td>
<td>通常需要自定义复制构造或赋值运算</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、小例子（加深理解）"><a href="#四、小例子（加深理解）" class="headerlink" title="四、小例子（加深理解）"></a>四、小例子（加深理解）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝（默认构造）</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        data = other.data; <span class="comment">// 指针共享</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝（自定义）</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 创建一份新拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="C-STL-中-vector-和-list-的区别"><a href="#C-STL-中-vector-和-list-的区别" class="headerlink" title="C++ STL 中 vector 和 list 的区别"></a>C++ STL 中 vector 和 list 的区别</h2><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li><p><strong>基于动态数组</strong>：<code>std::vector</code> 基于可以动态扩展的数组实现，元素在内存中是连续存储的。</p>
</li>
<li><p><strong>随机访问</strong>：提供快速的随机访问能力，可以通过索引快速访问任何元素。</p>
</li>
<li><p><strong>内存分配</strong>：内存分配较紧凑，元素紧密排列，没有额外空间用于指针或链接。</p>
</li>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>元素访问</strong>：<code>O(1)</code>，即常数时间复杂度。</li>
<li><strong>插入和删除</strong>：在末尾是 <code>O(1)</code>，但如果在中间插入或删除，可能需要 <code>O(n)</code>，因为需要移动后续所有元素。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：使用连续内存分配，能利用缓存优化访问速度。</p>
</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li><p><strong>基于双向链表</strong>：<code>std::list</code> 基于双向链表，元素通过节点链接到前后元素。</p>
</li>
<li><p><strong>非连续存储</strong>：元素在内存中不连续存储，每个元素包含指向前后元素的指针。</p>
</li>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>元素访问</strong>：<code>O(n)</code>，需要从头开始遍历到所需位置。</li>
<li><strong>插入和删除</strong>：特别高效，尤其是插入或删除中间元素时，操作为 <code>O(1)</code>，前提是已有指向目标元素的迭代器。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：由于指针链接，内存分配较分散，但插入和删除操作不需要移动其他元素。</p>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><p>**<code>std::vector</code>**：</p>
<ul>
<li>需要快速随机访问元素时。</li>
<li>需要在末尾快速添加或删除元素时。</li>
<li>需要关心内存使用效率时。</li>
</ul>
</li>
<li><p>**<code>std::list</code>**：</p>
<ul>
<li>需要高效在列表中间插入或删除元素时。</li>
<li>不需要随机访问元素时。</li>
<li>需要一个灵活容器来动态地添加和删除元素而不会导致大量内存复制或移动时。</li>
</ul>
</li>
</ul>
<h2 id="vector-底层原理和扩容过程"><a href="#vector-底层原理和扩容过程" class="headerlink" title="vector 底层原理和扩容过程"></a>vector 底层原理和扩容过程</h2><h2 id="一、底层原理"><a href="#一、底层原理" class="headerlink" title="一、底层原理"></a>一、底层原理</h2><ul>
<li><code>vector</code> 是 C++ STL 中的动态数组容器，底层通过在 <strong>堆</strong> 上分配一块 <strong>连续内存空间</strong> 来存储元素。</li>
<li>支持 <strong>O(1)</strong> 时间复杂度的随机访问（可以像数组一样通过下标访问）。</li>
</ul>
<h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><code>vector</code> 底层维护了：</p>
<ul>
<li><p><strong>三个指针（迭代器）</strong>：</p>
<ul>
<li><code>begin</code>：指向起始元素位置；</li>
<li><code>end</code>：指向最后一个元素之后的位置；</li>
<li><code>end_of_storage</code>：指向整块内存空间的末尾。</li>
</ul>
</li>
<li><p><strong>两个变量</strong>：</p>
<ul>
<li><code>size</code>：当前已存储的元素个数；</li>
<li><code>capacity</code>：当前分配的最大存储容量（不一定等于 size）。</li>
</ul>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>创建 <code>vector</code> 时会分配一块初始内存，默认大小为 0，也可以通过构造函数指定。</li>
<li>添加或删除元素时，只需调整 <code>end</code> 指针，不涉及移动整个内存块（前提是不扩容）。</li>
</ul>
<hr>
<h2 id="二、扩容机制"><a href="#二、扩容机制" class="headerlink" title="二、扩容机制"></a>二、扩容机制</h2><p>当添加的元素数 <strong>超过当前 capacity</strong> 时，会触发扩容操作：</p>
<ol>
<li>重新申请一块<strong>更大的内存空间</strong>；</li>
<li>将旧元素 <strong>拷贝到新内存</strong>；</li>
<li>释放旧内存；</li>
<li>更新指针和容量。</li>
</ol>
<p>⚠️ 注意：<strong>扩容会使原来的指针和迭代器失效</strong>，必须使用新返回的指针或迭代器。</p>
<hr>
<h2 id="三、扩容策略"><a href="#三、扩容策略" class="headerlink" title="三、扩容策略"></a>三、扩容策略</h2><h3 id="1-固定扩容（Fixed-Growth）"><a href="#1-固定扩容（Fixed-Growth）" class="headerlink" title="1. 固定扩容（Fixed Growth）"></a>1. 固定扩容（Fixed Growth）</h3><ul>
<li>每次扩容按固定大小增加（例如每次增加 N 个元素容量）。</li>
<li>缺点：可能频繁扩容，导致效率低。</li>
</ul>
<h3 id="2-加倍扩容（Doubling-Growth）"><a href="#2-加倍扩容（Doubling-Growth）" class="headerlink" title="2. 加倍扩容（Doubling Growth）"></a>2. 加倍扩容（Doubling Growth）</h3><ul>
<li>每次扩容时将当前容量翻倍。</li>
<li>优点：扩容次数少，摊销时间复杂度更低；</li>
<li>缺点：可能造成内存浪费，空间利用率低。</li>
</ul>
<hr>
<h2 id="四、总结一句话"><a href="#四、总结一句话" class="headerlink" title="四、总结一句话"></a>四、总结一句话</h2><blockquote>
<p>vector 底层是一个支持快速访问的动态数组，随着元素增加自动扩容，扩容时通过重新分配内存并拷贝旧数据来实现，通常采用<strong>加倍策略</strong>以提升性能。</p>
</blockquote>
<h2 id="push-back-和emplace-back的区别"><a href="#push-back-和emplace-back的区别" class="headerlink" title="push_back 和emplace_back的区别"></a>push_back 和emplace_back的区别</h2><p>在 C++ 中，push_back() 和 emplace_back() 都是标准库容器（如 std::vector）用于在末尾添加元素的方法，但它们的实现机制有所不同：<br>✅ push_back()<br>用法：container.push_back(value);<br>作用：将一个已构造好的对象（可以是拷贝或移动构造）添加到容器末尾。<br>特点：需要先构造出一个对象，再通过拷贝或移动的方式插入容器。<br>✅ emplace_back()<br>用法：container.emplace_back(args…);<br>作用：直接在容器的内存空间中构造对象，即”就地构造”。<br>特点：不需要预先创建对象，传入构造参数，容器内部直接调用构造函数。<br>🔧 性能比较：<br>emplace_back() 通常比 push_back() 更高效，因为它避免了临时对象的创建和复制&#x2F;移动操作。<br>特别是在构造代价较高或者禁止复制的对象类型上，emplace_back() 的优势更明显。</p>
<h2 id="map-deque-list"><a href="#map-deque-list" class="headerlink" title="map deque list"></a>map deque list</h2><p>STL 常见容器的实现原理：map、list、deque<br>🟥 std::map —— 基于红黑树的有序关联容器<br>底层结构：采用红黑树（一种自平衡的二叉搜索树）实现。<br>自动排序：元素按照键值自动排序，通常依据 &lt; 运算符定义的顺序。<br>键唯一性：每个键只能出现一次，不允许重复。<br>性能特点：<br>查找 &#x2F; 插入 &#x2F; 删除：O(log n)<br>迭代器特性：支持有序遍历（中序遍历），迭代器稳定，但不支持随机访问。<br>🟦 std::list —— 基于双向链表的序列容器<br>底层结构：双向链表，每个节点包含前驱和后继指针。<br>元素顺序：按插入顺序维护，无自动排序。<br>性能特点：<br>任意位置插入 &#x2F; 删除：O(1)（需已知位置）<br>查找：O(n)<br>迭代器特性：只支持顺序访问（前进&#x2F;后退），不支持随机访问（比如用 [] 不行）。<br>🟨 std::deque —— 双端队列，基于分段数组实现<br>底层结构：动态分段数组，不是单块连续内存，支持前后扩展。<br>两端操作高效：支持从头部和尾部高效插入&#x2F;删除。<br>性能特点：<br>头尾插入&#x2F;删除：O(1)<br>中间插入&#x2F;删除：O(n)（因为可能涉及元素移动）<br>迭代器特性：支持随机访问（如 vec[i]），性能类似 vector。</p>
<h2 id="map-和unordered-map的区别"><a href="#map-和unordered-map的区别" class="headerlink" title="map 和unordered_map的区别"></a>map 和unordered_map的区别</h2><p>一、核心区别一句话总结<br>map 用红黑树，有序；unordered_map 用哈希表，无序。<br>二、std::map 的特点（关键词：有序 &#x2F; 红黑树）<br>✅ 底层结构：基于红黑树，属于自平衡二叉搜索树。<br>✅ 元素有序：自动按键的大小关系排序（按 &lt; 运算符）。<br>✅ 键唯一：不允许重复键。<br>✅ 时间复杂度：查找 &#x2F; 插入 &#x2F; 删除操作都是 O(log n)。<br>✅ 迭代器稳定：除非删除元素，其他插入&#x2F;修改操作不会使迭代器失效。<br>✅ 适用场景：当需要有序遍历或者对迭代器稳定性有要求时使用。<br>三、std::unordered_map 的特点（关键词：无序 &#x2F; 哈希表）<br>✅ 底层结构：基于哈希表实现。<br>✅ 元素无序：不能按照键的顺序遍历。<br>✅ 键唯一：同样不允许重复键；冲突通过链表或开放寻址解决。<br>✅ 时间复杂度：<br>平均：查找 &#x2F; 插入 &#x2F; 删除为 O(1)<br>最坏：退化到 O(n)<br>⚠️ 迭代器不稳定：rehash 可能使所有迭代器失效。<br>✅ 适用场景：当只关心查找效率，不关心顺序时使用。<br>五、结尾升华一句话（面试收尾用）<br>所以，当我需要有序数据结构或稳定遍历时我会选用 map，否则我更倾向于使用性能更高的 unordered_map。</p>
<h2 id="C-11的新特性"><a href="#C-11的新特性" class="headerlink" title="C++ 11的新特性"></a>C++ 11的新特性</h2><p>一、类型推导（Type Deduction）<br>✅ auto<br>编译器自动推导变量类型，省去了显式声明。<br>👉 例：auto x &#x3D; 1.0; 推导为 double<br>✅ decltype<br>根据表达式的类型来声明变量类型，不会真正执行表达式。<br>👉 例：decltype(x + y) z &#x3D; 0;<br>二、范围 for 循环（Range-based for）<br>✅ 更简洁的容器遍历方式<br>👉 例：for (auto&amp; elem : vec) { … }<br>替代 begin() ~ end() 循环，代码更清晰。<br>三、Lambda 表达式（匿名函数）<br>✅ 在需要的地方内联定义函数对象，简洁高效。<br>👉 例：auto f &#x3D; [](int a, int b) { return a + b; };<br>用于算法、自定义排序、回调等场景。<br>四、智能指针（Smart Pointer）<br>✅ 自动管理内存，避免内存泄露<br>std::unique_ptr：独占所有权，不可拷贝<br>std::shared_ptr：引用计数，可共享所有权<br>五、右值引用 &amp; 移动语义<br>✅ 引入 T&amp;&amp; 右值引用，实现资源的“移动”而非“复制”<br>👉 适用于临时对象、提升性能<br>移动构造函数 &#x2F; 移动赋值运算符<br>std::move() 用于将左值转换为右值<br>六、nullptr 关键字<br>✅ 新的空指针类型，替代 NULL 和 0<br>👉 明确表示指针为空，更类型安全，防止重载歧义<br>七、补充记忆建议（可选扩展）<br>可提一句还有如下 C++11 常用特性（但不需要展开）：<br>constexpr：编译期常量<br>static_assert：静态断言<br>std::function、std::bind：函数封装与绑定<br>thread、mutex：多线程支持</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/" data-id="cm8mfwu1j0000eovq7428cesn" data-title="高频八股" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/12/25/hot100/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">hot100</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hot100/" rel="tag">hot100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" rel="tag">动态规划，算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" rel="tag">动态规划，背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">数据结构，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">算法，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">算法，单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" rel="tag">算法，图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">背包，动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" rel="tag">贪心算法，数学结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/hot100/" style="font-size: 10px;">hot100</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 10px;">八股文</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">动态规划，算法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E8%83%8C%E5%8C%85/" style="font-size: 10px;">动态规划，背包</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">回溯算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 12.5px;">图论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 20px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">数据结构，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 17.5px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法，动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">算法，单调栈</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">算法，图论</a> <a href="/tags/%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">背包，动态规划</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">语法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%BB%93%E6%9E%84/" style="font-size: 10px;">贪心算法，数学结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/10/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1/">高频八股</a>
          </li>
        
          <li>
            <a href="/2024/12/25/hot100/">hot100</a>
          </li>
        
          <li>
            <a href="/2024/12/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </li>
        
          <li>
            <a href="/2024/12/13/xv6/">xv6</a>
          </li>
        
          <li>
            <a href="/2024/12/12/%E5%9B%BE%E8%AE%BA-%E6%80%BB%E7%BB%93/">图论-总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>